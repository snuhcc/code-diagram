[src/components/ChatUI.tsx]
import { useState, useEffect, useRef, FormEvent } from 'react';
import { XMarkIcon, PlusIcon } from '@heroicons/react/24/outline';
import { useFS, getAllFilePaths } from '@/store/files';
import { marked } from 'marked'; // ÎßàÌÅ¨Îã§Ïö¥ ÌååÏÑú Ï∂îÍ∞Ä

interface Message {
  role: 'user' | 'bot';
  t: string;
}

interface Session {
  id: string;
  log: Message[];
}

const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';

export default function ChatUI() {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [input, setInput] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownItems, setDropdownItems] = useState<string[]>([]);
  const [isBotTyping, setIsBotTyping] = useState(false);
  const { tree } = useFS();
  const allFiles = getAllFilePaths(tree);
  const chatContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    async function init() {
      const newSessionId = await openNewSession();
      if (newSessionId) setCurrentSessionId(newSessionId);
    }
    init();

    return () => {
      sessions.forEach((session) => {
        fetch(`${apiUrl}/api/chatbot/session/close`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: session.id }),
        });
      });
    };
  }, []);

  const openNewSession = async () => {
    try {
      const res = await fetch(`${apiUrl}/api/chatbot/session/open`, { method: 'GET' });
      if (!res.ok) throw new Error(`Failed to open session: ${res.status}`);
      const data = await res.json();
      const newSessionId = data.session_id;
      setSessions((prev) => [...prev, { id: newSessionId, log: [] }]);
      setCurrentSessionId(newSessionId);
      return newSessionId;
    } catch (err) {
      console.error('Failed to open session:', err);
      setError('Failed to open session. Please try again.');
      return null;
    }
  };

  const closeSession = async (sessionId: string) => {
    try {
      await fetch(`${apiUrl}/api/chatbot/session/close`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId }),
      });
      setSessions((prevSessions) => {
        const newSessions = prevSessions.filter((s) => s.id !== sessionId);
        if (currentSessionId === sessionId) {
          setCurrentSessionId(newSessions.length > 0 ? newSessions[0].id : null);
        }
        return newSessions;
      });
    } catch (err) {
      console.error('Failed to close session:', err);
      setError('Failed to close session. Please try again.');
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInput(value);

    const atIndex = value.lastIndexOf('@');
    if (atIndex >= 0) {
      const afterAt = value.slice(atIndex + 1);
      const spaceIndex = afterAt.indexOf(' ');
      const word = spaceIndex >= 0 ? afterAt.slice(0, spaceIndex) : afterAt;
      if (word) {
        const filtered = allFiles.filter((path) =>
          path.toLowerCase().includes(word.toLowerCase())
        );
        setDropdownItems(filtered);
        setShowDropdown(true);
      } else {
        setDropdownItems(allFiles); // Show all files when just "@" is typed
        setShowDropdown(true);
      }
    } else {
      setShowDropdown(false); // Hide dropdown if no "@" present
    }
  };

  const handleSelectItem = (selected: string) => {
    const atIndex = input.lastIndexOf('@');
    if (atIndex >= 0) {
      const beforeAt = input.slice(0, atIndex + 1);
      const afterAt = input.slice(atIndex + 1);
      const spaceIndex = afterAt.indexOf(' ');
      const endIndex = spaceIndex >= 0 ? atIndex + 1 + spaceIndex : input.length;
      const newInput = beforeAt + selected + input.slice(endIndex);
      setInput(newInput); // Update input with selected file
    }
    setShowDropdown(false); // Hide dropdown after selection
  };

  const send = async (e: FormEvent) => {
    e.preventDefault();
    if (!input.trim() || !currentSessionId) return;

    setSessions((prev) =>
      prev.map((s) =>
        s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'user', t: input }] } : s
      )
    );
    setInput('');
    setIsBotTyping(true); // ÎãµÎ≥Ä ÎåÄÍ∏∞ ÏãúÏûë

    try {
      const res = await fetch(`${apiUrl}/api/chatbot/session/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: currentSessionId,
          query: input,
          code: '',
          diagram: '',
          context_files: input.match(/@(\S+)/g)?.map((m) => m.slice(1)) || [],
        }),
      });
      if (!res.ok) throw new Error(`Failed to send message: ${res.status}`);
      const data = await res.json();
      const text = data.answer;
      setSessions((prev) =>
        prev.map((s) =>
          s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'bot', t: text }] } : s
        )
      );
      setIsBotTyping(false); // ÎãµÎ≥Ä ÎèÑÏ∞©
    } catch (err) {
      console.error('Failed to send message:', err);
      setSessions((prev) =>
        prev.map((s) =>
          s.id === currentSessionId
            ? { ...s, log: [...s.log, { role: 'bot', t: 'Error: Failed to send message.' }] }
            : s
        )
      );
      setIsBotTyping(false); // ÏóêÎü¨ Î∞úÏÉù ÏãúÎèÑ ÎãµÎ≥Ä ÎåÄÍ∏∞ Ï¢ÖÎ£å
    }
  };

  const currentLog = sessions.find((s) => s.id === currentSessionId)?.log || [];

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [currentLog, currentSessionId]);

  return (
    <div className="flex flex-col h-full">
      <div className="flex items-center space-x-2 bg-slate-200 border-b border-slate-300 p-2 overflow-x-auto">
        {sessions.map((session, index) => (
          <div
            key={session.id}
            onClick={() => setCurrentSessionId(session.id)}
            className={`flex items-center px-3 py-1 cursor-pointer rounded-t-md ${
              session.id === currentSessionId ? 'bg-white border-t border-x border-slate-300' : ''
            }`}
          >
            <span style={{ fontWeight: 'bold' }}>üí¨ Chat # {index + 1}</span>
            <button
              onClick={(e) => {
                e.stopPropagation();
                closeSession(session.id);
              }}
              className="ml-2"
            >
              <XMarkIcon className="w-4 h-4" />
            </button>
          </div>
        ))}
        <button onClick={openNewSession} className="px-2 py-1">
          <PlusIcon className="w-5 h-5" />
        </button>
      </div>

      <div
        ref={chatContainerRef}
        className="flex-1 p-4 overflow-y-auto"
      >
        {sessions.length === 0 ? (
          <p className="text-center text-gray-500">
            No active sessions. Click '+' to start a new session.
          </p>
        ) : (
          currentLog.map((msg, i) => (
            <div key={i} className={`mb-2 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}>
              <span
                className={`inline-block p-2 rounded ${
                  msg.role === 'user' ? 'bg-blue-100' : 'bg-gray-100'
                }`}
                // ÎßàÌÅ¨Îã§Ïö¥ Î†åÎçîÎßÅ
                dangerouslySetInnerHTML={{ __html: marked.parse(msg.t) }}
              />
            </div>
          ))
        )}
        {isBotTyping && (
          <div className="mb-2 text-left">
            <span className="inline-block p-2 rounded bg-gray-100 text-gray-500 animate-pulse">
              <TypingIndicator />
            </span>
          </div>
        )}
        {error && <p className="text-red-500">{error}</p>}
      </div>

      {currentSessionId && (
        <div className="relative p-4 border-t border-slate-300">
          <form onSubmit={send}>
            <input
              type="text"
              value={input}
              onChange={handleInputChange}
              className="w-full p-2 border rounded"
              placeholder="Type your message..."
            />
            <button type="submit" className="hidden">
              Send
            </button>
          </form>
          {showDropdown && (
            <div
              className="absolute z-10 bg-white border border-slate-300 rounded shadow-md max-h-60 overflow-y-auto"
              style={{ bottom: '100%', left: 0 }}
            >
              {dropdownItems.map((item, i) => (
                <div
                  key={i}
                  onClick={() => handleSelectItem(item)}
                  className="px-3 py-1 hover:bg-slate-100 cursor-pointer"
                >
                  {item}
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// Ï±ÑÌåÖ ÌÉÄÏù¥Ìïë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïª¥Ìè¨ÎÑåÌä∏
function TypingIndicator() {
  return (
    <span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0s' }}></span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0.2s' }}></span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></span>
    </span>
  );
}

[src/components/CodeViewer.tsx]
'use client';

import { useEffect, useState } from 'react';
import Editor from '@monaco-editor/react';

export default function CodeViewer({ filePath }: { filePath: string }) {
  const [code, setCode] = useState('// loading‚Ä¶');

  /* ‚ë† Ïã§Ï†ú ÌååÏùº ÎÇ¥Ïö© Í∞ÄÏ†∏Ïò§Í∏∞ -------------------------------------- */
  useEffect(() => {
    (async () => {
      const c = await fetch(`/api/file?path=${encodeURIComponent(filePath)}`).then((r) =>
        r.text()
      );
      setCode(c);
    })();
  }, [filePath]);

  /* ‚ë° ÌôïÏû•ÏûêÎ°ú Ïñ∏Ïñ¥ Í≤∞Ï†ï ----------------------------------------- */
  const lang = (() => {
    if (filePath.endsWith('.tsx') || filePath.endsWith('.ts')) return 'typescript';
    if (filePath.endsWith('.py')) return 'python';
    if (filePath.endsWith('.md')) return 'markdown';
    return 'plaintext';
  })();

  /* ‚ë¢ ÏóêÎîîÌÑ∞ + Ï†úÎ™© Î∞î ------------------------------------------- */
  return (
    <div className="h-full bg-slate-100 rounded-md shadow-sm overflow-hidden">
      <div className="h-8 flex items-center px-3 bg-slate-200 border-b border-slate-300 text-xs">
        {filePath.split('/').pop()}
      </div>
      <Editor
        height="calc(100% - 2rem)"
        defaultLanguage={lang}
        value={code}
        theme="vs-dark"
        options={{
          minimap: { enabled: true },
          fontSize: 11.5,
          automaticLayout: true,
          readOnly: true,
        }}
      />
    </div>
  );
}


[src/components/DiagramViewer.tsx]
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import {
  ReactFlow,
  Background,
  MiniMap,
  Controls,
  MarkerType,
  type Node,
  type Edge,
  type NodeMouseHandler,
  applyNodeChanges,
  NodeChange,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { nanoid } from 'nanoid';
import { useEditor } from '@/store/editor';
import { useFS, type FileNode } from '@/store/files';
import {
  RawNode,
  RawEdge,
  CFGPanel,
  snippetCache,
  extractFunctionSnippet,
  highlightWithLineNumbers,
  isNodeHidden,
  findRepresentativeNode,
  calculateLayout,
  CustomGroupNode,
  parseApiResponse,
  cleanFilePath,
  calculateNodeWidth,
  ENDPOINTS,
  STYLES,
} from './diagramUtils';

// Constants
let diagramCache: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> | null = null;
const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';
const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export default function DiagramViewer() {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>();
  const [hoverId, setHoverId] = useState<string | null>(null);
  const [snippet, setSnippet] = useState<string>('');
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [cfgMessage, setCfgMessage] = useState<string | null>(null);
  const [cfgPanels, setCfgPanels] = useState<CFGPanel[]>([]);
  const [cfgLoading, setCfgLoading] = useState(false);
  const [diagramReady, setDiagramReady] = useState(false);
  const [hoveredEdgeId, setHoveredEdgeId] = useState<string | null>(null);
  const [collapsedGroups, setCollapsedGroups] = useState<Set<string>>(new Set());
  const [cfgPanelMessage, setCfgPanelMessage] = useState<string | null>(null);

  const editorState = useEditor.getState();
  const fsState = useFS.getState();

  const activePath = editorState.tabs.find(t => t.id === editorState.activeId)?.path ?? '';

  // Handlers
  const toggleCollapse = useCallback((groupId: string) => {
    setCollapsedGroups(prev => {
      const newSet = new Set(prev);
      newSet.has(groupId) ? newSet.delete(groupId) : newSet.add(groupId);
      return newSet;
    });
  }, []);

  const openFile = useCallback((filePath: string, line?: number, highlight?: { from: number; to: number }) => {
    const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
    editorState.open({
      id: nanoid(),
      path: cleanPath,
      name: cleanPath.split(/[\\/]/).pop() ?? cleanPath,
      line,
      highlight,
    });
    const target = findByPath(fsState.tree, cleanPath);
    if (target) fsState.setCurrent(target.id);
  }, [editorState, fsState]);

  const onNodeClick: NodeMouseHandler = useCallback((_, node) => {
    if (node.type === 'group') {
      const childNode = nodes.find(n => n.parentId === node.id && !isNodeHidden(n.id, collapsedGroups, nodes));
      const filePath = (childNode?.data as any)?.file || (node.data as any)?.file;
      if (filePath) openFile(filePath, 1);
      return;
    }
    setSelectedNodeId(prev => prev === node.id ? null : node.id);
    const filePath = (node.data as any)?.file;
    if (filePath) openFile(filePath);
  }, [nodes, collapsedGroups, openFile]);

  const onNodeMouseEnter: NodeMouseHandler = useCallback(async (_, node) => {
    if (node.type === 'group') return;
    
    setHoverId(node.id);
    const filePath = (node.data as any)?.file;
    const functionName = (node.data as any)?.label;
    if (!filePath || !functionName) {
      setSnippet('');
      return;
    }

    const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
    const cacheKey = `${cleanPath}_${functionName}`;
    
    try {
      let code = snippetCache.get(cacheKey);
      if (!code) {
        const response = await fetch(`/api/file?path=${encodeURIComponent(cleanPath)}`);
        code = await response.text();
      }
      
      const result = extractFunctionSnippet(code, functionName);
      if (result) {
        snippetCache.set(cacheKey, result.snippet);
        setSnippet(highlightWithLineNumbers(result.snippet, result.startLine));
      } else {
        setSnippet('(function not found)');
      }
    } catch {
      setSnippet('(preview unavailable)');
    }
  }, []);

  const onNodeMouseLeave = useCallback(() => {
    setHoverId(null);
    setSnippet('');
  }, []);

  const handleCFGPanelUpdate = useCallback((id: string, updates: Partial<CFGPanel>) => {
    setCfgPanels(panels => panels.map(p => p.id === id ? { ...p, ...updates } : p));
  }, []);

  const handleCFGPanelClose = useCallback((id: string) => {
    setCfgPanels(panels => panels.filter(p => p.id !== id));
  }, []);

  const handleCFGNodeHover = useCallback(async (node: Node | null, panel: CFGPanel) => {
    if (!node) {
      setCfgPanelMessage(null);
      return;
    }

    const { line_start, line_end } = node.data as any;
    
    setCfgPanelMessage(
      `<div style="display:flex;align-items:flex-start;gap:8px;">
        <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
        <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
          ÏÑ§Î™ÖÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...
        </span>
      </div>`
    );

    try {
      const res = await fetch(`${apiUrl}${ENDPOINTS.INLINE_CODE_EXPLANATION}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_path: panel.file, line_start, line_end }),
      });
      const data = await res.json();
      const explanation = data.explanation || data.data?.explanation || 'ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';
      
      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:320px;display:inline-block;">
            ${explanation}
          </span>
        </div>`
      );
    } catch {
      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
            ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
          </span>
        </div>`
      );
    }

    openFile(node.data.file || panel.file, line_start, { from: line_start, to: line_end });
  }, [apiUrl, openFile]);

  const handleGenerateCFG = useCallback(async () => {
    setCfgMessage(null);
    setCfgLoading(true);
    
    const selectedNode = nodes.find(n => n.id === selectedNodeId && n.type !== 'group');
    if (!selectedNode) {
      setCfgMessage('ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }
    
    const { file, label: functionName } = selectedNode.data as any;
    if (!file || !functionName) {
      setCfgMessage('ÎÖ∏Îìú Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }

    if (cfgPanels.some(p => p.file === file && p.functionName === functionName)) {
      setCfgMessage('Ïù¥ÎØ∏ Ìï¥Îãπ Ìï®ÏàòÏùò CFG Ìå®ÎÑêÏù¥ Ïó¥Î†§ ÏûàÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }

    try {
      const res = await fetch(`${apiUrl}${ENDPOINTS.CFG}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_path: file, function_name: functionName }),
      });
      
      const data = await res.json();
      if (data.status && data.status !== 200) {
        setCfgMessage('API Ìò∏Ï∂ú Ïã§Ìå®: ' + (data.data || ''));
        return;
      }
      
      const cfgData = parseApiResponse(data);
      let cfgNodes = (cfgData.nodes || []).map((n: any) => ({
        id: n.id,
        data: { 
          label: n.label || n.id,
          file: n.file || file,
          line_start: n.line_start || 1,
          line_end: n.line_end || 1,
        },
        position: { x: n.x ?? 0, y: n.y ?? 0 },
        style: {
          padding: 4,
          borderRadius: 3,
          border: '1px solid #0284c7',
          background: '#fff',
          fontSize: 12,
          minWidth: 40,
          minHeight: 24,
        },
      }));
      
      const cfgEdges = (cfgData.edges || []).map((e: any) => ({
        id: e.id || `${e.source}-${e.target}`,
        source: e.source,
        target: e.target,
        markerEnd: { type: MarkerType.ArrowClosed },
        animated: true,
        style: { stroke: '#0284c7', strokeWidth: 2 },
      }));

      if (cfgData.nodes?.length > 0 && cfgData.nodes.every((n: any) => !n.x && !n.y)) {
        const posMap = calculateLayout({ [file]: { nodes: cfgData.nodes, edges: cfgData.edges } }, {});
        cfgNodes = cfgNodes.map((n: any) => ({
          ...n,
          position: posMap[n.id] ?? { x: 0, y: 0 }
        }));
      }

      setCfgPanels(panels => [
        ...panels,
        {
          id: `${file}__${functionName}__${Date.now()}`,
          functionName,
          file,
          result: { nodes: cfgNodes, edges: cfgEdges },
          expanded: true,
          pos: { x: 24 + panels.length * 32, y: 24 + panels.length * 32 },
          dragging: false,
          dragOffset: { x: 0, y: 0 },
          width: STYLES.CFG_PANEL.WIDTH,
          height: STYLES.CFG_PANEL.HEIGHT,
        },
      ]);
      setCfgMessage(null);
    } catch (e: any) {
      setCfgMessage('API Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. error: ' + e.message);
    } finally {
      setCfgLoading(false);
    }
  }, [nodes, selectedNodeId, cfgPanels, apiUrl]);

  const hydrate = useCallback((json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>) => {
    const nodeWidths: Record<string, number> = {};
    const nodeFont = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`;

    // Calculate node widths
    Object.values(json).forEach(data => {
      data.nodes.forEach(node => {
        const label = node.label || node.function_name || node.id;
        nodeWidths[node.id] = calculateNodeWidth(label);
      });
    });

    // Create nodes
    let allFunctionNodes: Node[] = [];
    let allRawEdges: RawEdge[] = [];
    
    Object.entries(json).forEach(([file, data]) => {
      const functionNodes = data.nodes.map(n => ({
        id: n.id,
        data: { label: n.label || n.function_name || n.id, file: n.file },
        position: { x: 0, y: 0 },
        style: {
          padding: '6px 8px',
          borderRadius: 4,
          border: '1px solid #3b82f6',
          background: '#fff',
          width: nodeWidths[n.id],
          fontSize: STYLES.NODE.FONT_SIZE,
          fontFamily: STYLES.NODE.FONT_FAMILY,
        },
        zIndex: 1,
      }));
      allFunctionNodes = allFunctionNodes.concat(functionNodes);
      allRawEdges = allRawEdges.concat(data.edges);
    });

    // Create edges
    const nodeIds = new Set(allFunctionNodes.map(n => n.id));
    const allEdges: Edge[] = allRawEdges
      .filter(e => nodeIds.has(e.source) && nodeIds.has(e.target))
      .map(e => ({
        id: e.id,
        source: e.source,
        target: e.target,
        markerEnd: {
          type: MarkerType.ArrowClosed,
          width: 15,
          height: 15,
          color: STYLES.COLORS.EDGE.DEFAULT,
        },
        animated: true,
        style: { stroke: STYLES.COLORS.EDGE.DEFAULT, strokeWidth: 2 },
        zIndex: 10000,
        type: 'step',
      }));

    // Calculate layout
    const posMap = calculateLayout(json, nodeWidths);
    const laidOutNodes = allFunctionNodes.map(n => ({
      ...n,
      position: posMap[n.id] ?? { x: 0, y: 0 },
    }));

    // Create groups
    const groupNodes: Node[] = [];
    const fileToNodes: Record<string, Node[]> = {};
    
    laidOutNodes.forEach(node => {
      const file = (node.data as any).file;
      if (!fileToNodes[file]) fileToNodes[file] = [];
      fileToNodes[file].push(node);
    });

    Object.entries(fileToNodes).forEach(([file, nodesInGroup]) => {
      if (nodesInGroup.length === 0) return;
      
      const xs = nodesInGroup.map(n => n.position.x);
      const ys = nodesInGroup.map(n => n.position.y);
      const minX = Math.min(...xs);
      const minY = Math.min(...ys);
      const maxX = Math.max(...nodesInGroup.map(n => n.position.x + ((n.style?.width as number) || STYLES.NODE.MIN_WIDTH)));
      const maxY = Math.max(...nodesInGroup.map(n => n.position.y + ((n.style?.height as number) || STYLES.NODE.HEIGHT.DEFAULT)));
      
      const groupId = `group-${file.replace(/[^a-zA-Z0-9]/g, '_')}`;
      groupNodes.push({
        id: groupId,
        type: 'group',
        data: { 
          label: file.split('/').pop() || file,
          file: file
        },
        position: { x: minX - STYLES.GROUP.PADDING, y: minY - STYLES.GROUP.PADDING },
        style: {
          width: maxX - minX + 2 * STYLES.GROUP.PADDING,
          height: maxY - minY + 2 * STYLES.GROUP.PADDING,
          background: 'rgba(0, 0, 0, 0.05)',
          border: '1px dashed #fb923c',
          borderRadius: 8,
        },
        zIndex: 0,
      });
      
      nodesInGroup.forEach(node => {
        node.position = {
          x: node.position.x - (minX - STYLES.GROUP.PADDING),
          y: node.position.y - (minY - STYLES.GROUP.PADDING),
        };
        node.parentId = groupId;
        node.extent = 'parent';
      });
    });

    setNodes([...groupNodes, ...laidOutNodes]);
    setEdges(allEdges);
  }, []);

  // Load diagram
  useEffect(() => {
    if (!diagramReady) return;
    
    (async () => {
      if (diagramCache) {
        hydrate(diagramCache);
        setLoading(false);
        return;
      }
      
      setLoading(true);
      setError(undefined);
      
      try {
        const res = await fetch(`${apiUrl}${ENDPOINTS.CG}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: `../../${TARGET_FOLDER}`, file_type: 'py' }),
        });
        
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        
        const data = await res.json();
        const json = parseApiResponse(data);
        diagramCache = json;
        hydrate(json);
      } catch (e: any) {
        setError(String(e));
        setNodes([]);
        setEdges([]);
      } finally {
        setLoading(false);
      }
    })();
  }, [diagramReady, apiUrl, hydrate]);

  // Process edges for collapsed groups
  const processedEdges = useMemo(() => {
    const processed = edges.map(e => {
      const sourceRep = findRepresentativeNode(e.source, collapsedGroups, nodes);
      const targetRep = findRepresentativeNode(e.target, collapsedGroups, nodes);
      
      if (sourceRep === targetRep && collapsedGroups.has(sourceRep)) {
        return { ...e, hidden: true };
      }
      
      const isRedirected = sourceRep !== e.source || targetRep !== e.target;
      const finalEdge = isRedirected ? {
        ...e,
        id: `${e.id}_redirected_${sourceRep}_${targetRep}`,
        source: sourceRep,
        target: targetRep,
        data: {
          ...e.data,
          originalSource: e.source,
          originalTarget: e.target,
          isRedirected: true,
        },
      } : e;
      
      const isHover = hoveredEdgeId === finalEdge.id;
      
      return {
        ...finalEdge,
        hidden: false,
        style: {
          ...(finalEdge.style || {}),
          stroke: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
          strokeWidth: isHover ? 4 : (isRedirected ? 3 : 2),
          strokeDasharray: isRedirected ? '5 5' : undefined,
          transition: 'all 0.13s',
          cursor: 'pointer',
        },
        markerEnd: {
          ...(finalEdge.markerEnd || {}),
          color: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
        },
        zIndex: isRedirected ? 10001 : 10000,
      };
    });

    // Remove duplicates
    const seen = new Map<string, Edge>();
    processed.forEach(edge => {
      const key = `${edge.source}-${edge.target}`;
      if (!seen.has(key) || edge.data?.isRedirected) {
        seen.set(key, edge);
      }
    });
    
    return Array.from(seen.values());
  }, [edges, collapsedGroups, nodes, hoveredEdgeId]);

  // Process nodes for styling
  const finalNodes = useMemo(() => {
    return nodes.map(n => {
      const cleanPath = cleanFilePath((n.data as any)?.file || '', TARGET_FOLDER);
      const isActive = cleanPath === activePath;
      const isHover = hoverId === n.id;
      const isSelected = selectedNodeId === n.id;
      const isGroup = n.type === 'group';
      const isCollapsed = isGroup && collapsedGroups.has(n.id);
      const isHidden = !isGroup && isNodeHidden(n.id, collapsedGroups, nodes);

      return {
        ...n,
        type: isGroup ? 'group' : (n.type || 'default'),
        hidden: isHidden,
        style: {
          ...n.style,
          background: isGroup
            ? isCollapsed 
              ? STYLES.COLORS.GROUP.COLLAPSED
              : isHover
                ? STYLES.COLORS.NODE.HOVER
                : isSelected
                  ? STYLES.COLORS.NODE.SELECTED
                  : isActive
                    ? STYLES.COLORS.NODE.ACTIVE
                    : STYLES.COLORS.GROUP.DEFAULT
            : isHover
              ? STYLES.COLORS.NODE.HOVER
              : isSelected
                ? STYLES.COLORS.NODE.SELECTED
                : isActive
                  ? STYLES.COLORS.NODE.ACTIVE
                  : STYLES.COLORS.NODE.DEFAULT,
          border: isGroup
            ? isCollapsed
              ? `2px solid ${STYLES.COLORS.GROUP.BORDER_COLLAPSED}`
              : isHover
                ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
                : isActive
                  ? `1px solid ${STYLES.COLORS.GROUP.BORDER_ACTIVE}`
                  : `1px solid ${STYLES.COLORS.GROUP.BORDER}`
            : isHover
              ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
              : isSelected
                ? `4px solid ${STYLES.COLORS.NODE.BORDER_SELECTED}`
                : isActive
                  ? `1px solid ${STYLES.COLORS.NODE.BORDER_ACTIVE}`
                  : `1px solid ${STYLES.COLORS.NODE.BORDER}`,
          transition: 'all 0.1s ease-in-out',
          minWidth: isGroup ? (isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : undefined) : (n.style?.width as number),
          width: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : n.style?.width,
          height: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_HEIGHT : n.style?.height,
          cursor: isGroup && isCollapsed ? 'pointer' : 'default',
        },
        data: isGroup
          ? {
              ...n.data,
              isCollapsed,
              onToggleCollapse: () => toggleCollapse(n.id),
            }
          : n.data,
      };
    });
  }, [nodes, activePath, hoverId, selectedNodeId, collapsedGroups, toggleCollapse]);

  if (!diagramReady) {
    return (
      <div className="flex items-center justify-center h-full w-full">
        <button
          onClick={() => setDiagramReady(true)}
          className="min-w-[180px] px-8 py-3 rounded-lg bg-white text-gray-700 font-semibold text-lg border border-gray-300 shadow-sm hover:bg-gray-50 hover:border-indigo-500 hover:text-indigo-700 transition-all"
        >
          <span className="inline-block mr-2 text-indigo-500">‚ñ∂</span>
          Generate Diagram
        </button>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full w-full">
        <svg className="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" />
        </svg>
        <span className="ml-3 text-sm text-slate-500">diagram loading‚Ä¶</span>
      </div>
    );
  }

  if (error) {
    return <div className="p-4 text-sm text-red-600 whitespace-pre-wrap">{error}</div>;
  }

  return (
    <div className="relative h-full w-full border-l border-slate-300">
      <ReactFlow
        nodes={finalNodes}
        edges={processedEdges}
        onNodesChange={(changes) => setNodes(nds => applyNodeChanges(changes, nds))}
        onNodeClick={onNodeClick}
        onNodeMouseEnter={onNodeMouseEnter}
        onNodeMouseLeave={onNodeMouseLeave}
        onEdgeMouseEnter={(_, edge) => setHoveredEdgeId(edge.id)}
        onEdgeMouseLeave={() => setHoveredEdgeId(null)}
        fitView
        minZoom={0.2}
        maxZoom={2}
        className="bg-gray-50"
        nodeTypes={{ group: CustomGroupNode }}
        onPaneClick={() => {
          setSelectedNodeId(null);
          setCfgMessage(null);
        }}
      >
        <Background variant="dots" gap={16} size={1} />
        <MiniMap
          pannable
          zoomable
          nodeColor={n => {
            if (n.type === 'group') return collapsedGroups.has(n.id) ? '#6b7280' : '#bdbdbd';
            const bg = n.style?.background;
            return bg === STYLES.COLORS.NODE.HOVER ? '#facc15' :
                   bg === STYLES.COLORS.NODE.ACTIVE ? '#0284c7' : '#2563eb';
          }}
          nodeStrokeColor={n => {
            if (n.type === 'group') return collapsedGroups.has(n.id) ? '#374151' : '#757575';
            const border = n.style?.border;
            return border?.includes(STYLES.COLORS.NODE.BORDER_HOVER) ? STYLES.COLORS.NODE.BORDER_HOVER :
                   border?.includes(STYLES.COLORS.NODE.BORDER_ACTIVE) ? STYLES.COLORS.NODE.BORDER_ACTIVE : '#1e40af';
          }}
          nodeStrokeWidth={2}
          maskColor="rgba(255,255,255,0.7)"
          style={{
            background: '#f3f4f6',
            border: '1.5px solid #cbd5e1',
            borderRadius: 6,
            boxShadow: '0 2px 8px #0002',
          }}
        />
        <Controls>
          <button
            type="button"
            title="Re-layout"
            onClick={() => diagramCache && hydrate(diagramCache)}
            className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow"
          >
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <rect x="2" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="2" y="10" width="4" height="4" rx="1" fill="#222" />
              <rect x="6" y="6" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="10" width="4" height="4" rx="1" fill="#222" />
            </svg>
          </button>
          <button
            type="button"
            title="Generate Control Flow Graph"
            onClick={handleGenerateCFG}
            disabled={cfgLoading}
            className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow relative disabled:cursor-not-allowed"
          >
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style={{ opacity: cfgLoading ? 0.3 : 1 }}>
              <circle cx="6" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="14" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="10" cy="14" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <line x1="7.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="12.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="8.2" y1="6" x2="11.8" y2="6" stroke="#222" strokeWidth="1.2" />
              <g>
                <circle cx="16.5" cy="16.5" r="3.2" fill="#222" />
                <rect x="16" y="14.2" width="1" height="4.6" rx="0.5" fill="#fff" />
                <rect x="14.2" y="16" width="4.6" height="1" rx="0.5" fill="#fff" />
              </g>
            </svg>
            {cfgLoading && (
              <span className="absolute inset-0 flex items-center justify-center bg-white/70 rounded">
                <svg className="animate-spin" width="16" height="16" viewBox="0 0 16 16">
                  <circle cx="8" cy="8" r="6" stroke="#0284c7" strokeWidth="2" fill="none" strokeDasharray="28" strokeDashoffset="10" />
                </svg>
              </span>
            )}
          </button>
        </Controls>
      </ReactFlow>
      
      {cfgMessage && (
        <div className="absolute top-[60px] right-6 bg-red-100 text-red-800 px-4 py-2 rounded-md z-[100] text-sm shadow-md">
          {cfgMessage}
        </div>
      )}
      
      {cfgPanels.map((panel, idx) => (
        <CFGPanelComponent
          key={panel.id}
          panel={panel}
          index={idx}
          onUpdate={handleCFGPanelUpdate}
          onClose={handleCFGPanelClose}
          onNodeHover={handleCFGNodeHover}
          message={cfgPanelMessage}
        />
      ))}
      
      {hoverId && snippet && (
        <div
          className="fixed z-50 top-4 right-4 min-w-[320px] max-w-[40vw] min-h-[40px] max-h-[80vh] bg-gray-50 text-slate-800 text-xs rounded-lg shadow-lg p-4 overflow-auto font-mono"
          dangerouslySetInnerHTML={{ __html: `<pre class="hljs">${snippet}</pre>` }}
        />
      )}
    </div>
  );
}

// CFG Panel Component
function CFGPanelComponent({
  panel,
  index,
  onUpdate,
  onClose,
  onNodeHover,
  message,
}: {
  panel: CFGPanel;
  index: number;
  onUpdate: (id: string, updates: Partial<CFGPanel>) => void;
  onClose: (id: string) => void;
  onNodeHover: (node: Node | null, panel: CFGPanel) => void;
  message?: string | null;
}) {
  const [isDragging, setIsDragging] = useState(false);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if ((e.target as HTMLElement).closest('button')) return;

    const startX = e.clientX;
    const startY = e.clientY;
    const origX = panel.pos.x;
    const origY = panel.pos.y;
    
    setIsDragging(true);
    onUpdate(panel.id, { dragging: true });

    const onMouseMove = (moveEvent: MouseEvent) => {
      const dx = moveEvent.clientX - startX;
      const dy = moveEvent.clientY - startY;
      
      const newX = origX - dx;
      const newY = origY + dy;
      
      const panelWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
      const panelHeight = panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : 44;
      
      const boundedX = Math.max(20, Math.min(newX, window.innerWidth - panelWidth - 20));
      const boundedY = Math.max(20, Math.min(newY, window.innerHeight - panelHeight - 20));
      
      onUpdate(panel.id, { pos: { x: boundedX, y: boundedY } });
    };

    const onMouseUp = () => {
      setIsDragging(false);
      onUpdate(panel.id, { dragging: false });
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    e.preventDefault();
  }, [panel, onUpdate]);

  const handleResize = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
    const startHeight = panel.height ?? STYLES.CFG_PANEL.HEIGHT;

    onUpdate(panel.id, { resizing: true });

    const onMouseMove = (moveEvent: MouseEvent) => {
      const dx = moveEvent.clientX - startX;
      const dy = moveEvent.clientY - startY;
      
      const newWidth = Math.max(300, Math.min(1600, startWidth + dx));
      const newHeight = Math.max(200, Math.min(1200, startHeight + dy));
      
      onUpdate(panel.id, { width: newWidth, height: newHeight });
    };

    const onMouseUp = () => {
      onUpdate(panel.id, { resizing: false });
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  }, [panel, onUpdate]);

  return (
    <div
      style={{
        position: 'fixed',
        top: panel.pos.y,
        right: panel.pos.x,
        background: '#f1f5f9',
        color: '#222',
        padding: panel.expanded ? '12px 18px 18px 18px' : '8px 18px',
        borderRadius: 8,
        zIndex: 200 + index,
        fontSize: 13,
        minWidth: 220,
        maxWidth: 1600,
        maxHeight: panel.expanded ? 1200 : 44,
        boxShadow: '0 2px 8px #0002',
        overflow: panel.expanded ? 'auto' : 'hidden',
        transition: 'all 0.2s cubic-bezier(.4,2,.6,1)',
        display: 'flex',
        flexDirection: 'column',
        cursor: isDragging ? 'move' : 'default',
        userSelect: isDragging ? 'none' : 'auto',
        width: panel.width ?? STYLES.CFG_PANEL.WIDTH,
        height: panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : undefined,
      }}
    >
      {message && (
        <div
          style={{
            position: 'absolute',
            top: 8,
            right: 12,
            zIndex: 300,
            fontSize: 13,
            fontWeight: 500,
            pointerEvents: 'none',
            maxWidth: 340,
          }}
          dangerouslySetInnerHTML={{ __html: message }}
        />
      )}
      
      <div
        style={{
          width: '100%',
          minHeight: 28,
          display: 'flex',
          alignItems: 'center',
          fontWeight: 600,
          fontSize: 13,
          color: '#555',
          userSelect: 'none',
          marginBottom: panel.expanded ? 8 : 0,
          gap: 4,
          cursor: 'move',
        }}
        onMouseDown={handleMouseDown}
      >
        <span style={{ flex: 1 }}>
          CFG ({panel.functionName}
          {panel.file && <> @ {panel.file.split(/[\\/]/).pop()}</>})
        </span>
        <button
          onClick={e => {
            e.stopPropagation();
            onUpdate(panel.id, { expanded: !panel.expanded });
          }}
          style={{
            background: 'transparent',
            border: 'none',
            color: '#888',
            cursor: 'pointer',
            padding: 0,
            width: 24,
            height: 24,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            transition: 'transform 0.15s',
            transform: panel.expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
          }}
          aria-label={panel.expanded ? 'Collapse' : 'Expand'}
        >
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M4 6l4 4 4-4" stroke="#888" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>
        <button
          onClick={e => {
            e.stopPropagation();
            onClose(panel.id);
          }}
          style={{
            background: 'transparent',
            border: 'none',
            color: '#888',
            cursor: 'pointer',
            padding: 0,
            width: 24,
            height: 24,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
          aria-label="Close"
        >
          √ó
        </button>
      </div>
      
      {panel.expanded && (
        <div style={{ width: '100%', height: panel.height ?? STYLES.CFG_PANEL.HEIGHT, overflow: 'auto', position: 'relative' }}>
          {panel.result?.nodes && panel.result?.edges ? (
            <div style={{ width: '100%', height: '100%', background: '#f8fafc', borderRadius: 6 }}>
              <ReactFlow
                nodes={panel.result.nodes}
                edges={panel.result.edges}
                fitView
                minZoom={0.2}
                maxZoom={2}
                className="bg-gray-50"
                style={{ width: '100%', height: '100%' }}
                defaultViewport={{ x: 0, y: 0, zoom: 1.2 }}
                onNodeMouseEnter={(_, node) => onNodeHover(node, panel)}
                onNodeMouseLeave={() => onNodeHover(null, panel)}
              >
                <Background variant="dots" gap={16} size={1} />
                <Controls showInteractive={false} />
              </ReactFlow>
            </div>
          ) : (
            <pre style={{
              margin: 0,
              fontSize: 13,
              background: 'none',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              maxWidth: 560,
              maxHeight: 520,
              padding: 0,
            }}>
              {typeof panel.result === 'string' ? panel.result : JSON.stringify(panel.result, null, 2)}
            </pre>
          )}
          
          <div
            style={{
              position: 'absolute',
              right: 2,
              bottom: 2,
              width: 18,
              height: 18,
              cursor: 'nwse-resize',
              zIndex: 10,
              userSelect: 'none',
            }}
            onMouseDown={handleResize}
          >
            <svg width="18" height="18" style={{ pointerEvents: 'none' }}>
              <polyline points="4,18 18,4" stroke="#888" strokeWidth="2" fill="none" />
              <rect x="12" y="12" width="5" height="5" fill="#e5e7eb" stroke="#888" strokeWidth="1" />
            </svg>
          </div>
        </div>
      )}
    </div>
  );
}

// Helper function
function findByPath(nodes: FileNode[] = [], p: string): FileNode | undefined {
  const regex = new RegExp(`^${process.env.NEXT_PUBLIC_TARGET_FOLDER}[\\\\/]`);
  for (const n of nodes) {
    if (n.path?.replace(regex, '') === p) return n;
    if (n.children) {
      const r = findByPath(n.children, p);
      if (r) return r;
    }
  }
}

[src/components/EditorTabs.tsx]
'use client';

import { useEffect, useState } from 'react';
import Editor from '@monaco-editor/react';
import { useEditor } from '@/store/editor';

function CodePane({
  path,
  highlights,
  highlight,
}: {
  path: string;
  highlights?: { line: number; query: string };
  highlight?: { from: number; to: number };
}) {
  const [code, setCode] = useState('// loading‚Ä¶');
  const [err, setErr] = useState<string>();
  const [editor, setEditor] = useState<any>(null);

  useEffect(() => {
    let active = true;
    (async () => {
      const res = await fetch(`/api/file?path=${encodeURIComponent(path)}`);
      if (!active) return;

      if (res.ok) {
        setCode(await res.text());
      } else {
        const { error } = await res.json().catch(() => ({ error: res.statusText }));
        setErr(`${res.status}: ${error}`);
      }
    })();
    return () => {
      active = false;
    };
  }, [path]);

  useEffect(() => {
    if (!editor) return;

    // Remove all decorations first
    editor.deltaDecorations(
      editor.__currentDecorations || [],
      []
    );
    let decorations: any[] = [];

    // Highlight search results
    if (highlights) {
      const { line, query } = highlights;
      editor.revealLineInCenter(line);
      decorations.push({
        range: new monaco.Range(line, 1, line, 1),
        options: { isWholeLine: true, className: 'highlight-line' },
      });
      const matches = editor.getModel().findMatches(query, true, false, true, null, true);
      decorations = decorations.concat(
        matches.map((match) => ({
          range: match.range,
          options: { inlineClassName: 'highlight-text' },
        }))
      );
    }
    console.log('highlight', highlight);
    // Highlight range
    if (highlight && highlight.from !== undefined && highlight.to !== undefined) {
      const model = editor.getModel();
      if (model) {
        const line_start = highlight.from;
        const line_end = highlight.to;
        decorations.push({
          range: new monaco.Range(
            line_start,
            1,
            line_end,
            1
          ),
          options: { isWholeLine: true, className: 'highlight-line' },
        });
      }
    }

    editor.__currentDecorations = editor.deltaDecorations(
      editor.__currentDecorations || [],
      decorations
    );
  }, [editor, highlights, highlight]);

  const lang = (() => {
    if (path.endsWith('.py')) return 'python';
    if (path.endsWith('.tsx') || path.endsWith('.ts')) return 'typescript';
    if (path.endsWith('.md')) return 'markdown';
    return 'plaintext';
  })();

  if (err) {
    return (
      <pre className="p-4 text-sm text-red-600 whitespace-pre-wrap">{err}</pre>
    );
  }

  return (
    <Editor
      height="calc(100% - 2rem)"
      defaultLanguage={lang}
      value={code}
      theme="vs"
      onMount={(editor) => setEditor(editor)}
      options={{
        readOnly: true,
        fontSize: 11.5,
        minimap: { enabled: true },
        automaticLayout: true,
        wordWrap: 'on',
      }}
    />
  );
}

export default function EditorTabs() {
  const { tabs, activeId, setActive, close, searchHighlights, highlight } = useEditor();

  if (!tabs.length) {
    return (
      <div className="h-full flex items-center justify-center text-sm text-slate-500">
        Open a file to begin
      </div>
    );
  }

  const active = tabs.find((t) => t.id === activeId) ?? tabs[0];

  return (
    <div className="flex flex-col h-full">
      {/* ‚≠êÔ∏è ÌÉ≠ Î∞îÏóê Ïä§ÌÅ¨Î°§ Ï∂îÍ∞Ä */}
      <div
        className="h-8 flex items-center bg-slate-200 border-b border-slate-300 select-none overflow-x-auto"
        style={{ whiteSpace: 'nowrap' }}
      >
        <div className="flex flex-row flex-nowrap">
          {tabs.map((t) => {
            const on = t.id === active.id;
            return (
              <div
                key={t.id}
                onClick={() => setActive(t.id)}
                className={
                  'h-full flex items-center px-3 text-xs cursor-pointer border-r border-slate-300 transition-colors ' +
                  (on
                    ? 'bg-white text-sky-700 font-semibold border-b-2 border-b-sky-600'
                    : 'text-slate-600 hover:bg-slate-100 border-b-2 border-b-transparent')
                }
                style={{ flex: '0 0 auto' }} // ‚≠êÔ∏è ÌÉ≠Ïù¥ Ï§ÑÎ∞îÍøàÎêòÏßÄ ÏïäÎèÑÎ°ù
              >
                {t.name}
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    close(t.id);
                  }}
                  className="ml-2 text-slate-400 hover:text-slate-600 transition-colors"
                >
                  √ó
                </button>
              </div>
            );
          })}
        </div>
      </div>
      <div className="flex-1">
        <CodePane path={active.path} highlights={searchHighlights} highlight={highlight} />
      </div>
    </div>
  );
}

[src/components/FileExplorer.tsx]
'use client';

import { useEffect, useState } from 'react';
import clsx from 'clsx';
import { useFS, FileNode } from '@/store/files';
import { useEditor } from '@/store/editor';
import { nanoid } from 'nanoid';

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER ?? 'study1/face_classification';

function filterTree(nodes: FileNode[] = []): FileNode[] {
  return nodes
    .filter((n) => n.name !== '__pycache__' && n.name !== '.DS_Store')
    .sort((a, b) => {
      const aIsDir = Array.isArray(a.children);
      const bIsDir = Array.isArray(b.children);
      if (aIsDir && !bIsDir) return -1;
      if (!aIsDir && bIsDir) return 1;
      return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
    })
    .map((n) =>
      Array.isArray(n.children)
        ? { ...n, children: filterTree(n.children) }
        : n
    );
}

const arr = (x: FileNode[] | FileNode | undefined): FileNode[] =>
  Array.isArray(x) ? x : x ? [x] : [];

function getIcon(n: FileNode, isDir: boolean, isOpen: boolean) {
  if (isDir) {
    // VSCode Ïä§ÌÉÄÏùº Ìè¥Îçî ÏïÑÏù¥ÏΩò (Ïó¥Î¶º/Îã´Ìûò)
    return isOpen ? (
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <path
          d="M2 4.5A1.5 1.5 0 0 1 3.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H13a1 1 0 0 1 1 1v6.5A1.5 1.5 0 0 1 12.5 14h-9A1.5 1.5 0 0 1 2 12.5v-8Z"
          fill="#eab308"
          stroke="#b45309"
          strokeWidth="0.7"
        />
      </svg>
    ) : (
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <rect
          x="2"
          y="4"
          width="12"
          height="8"
          rx="1.5"
          fill="#fde68a"
          stroke="#b45309"
          strokeWidth="0.7"
        />
        <path
          d="M5.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H2V4.5A1.5 1.5 0 0 1 3.5 3h2Z"
          fill="#fbbf24"
          stroke="#b45309"
          strokeWidth="0.7"
        />
      </svg>
    );
  }
  if (n.name.endsWith('.py')) {
    // Python ÏïÑÏù¥ÏΩò (Ïã¨Ìîå)
    return (
      <svg
        width="16"
        height="16"
        viewBox="0 0 32 32"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <rect x="4" y="7" width="24" height="18" rx="6" fill="#3776AB" />
        <rect x="4" y="7" width="24" height="9" rx="4.5" fill="#FFD43B" />
        <circle cx="10" cy="12" r="1.5" fill="#222" />
        <circle cx="22" cy="20" r="1.5" fill="#fff" />
      </svg>
    );
  }
  // Í∏∞Î≥∏ ÌååÏùº ÏïÑÏù¥ÏΩò
  return (
    <svg
      width="16"
      height="16"
      viewBox="0 0 16 16"
      style={{ marginRight: 4, display: 'inline' }}
      fill="none"
    >
      <rect
        x="3"
        y="2"
        width="10"
        height="12"
        rx="2"
        fill="#e5e7eb"
        stroke="#94a3b8"
        strokeWidth="0.7"
      />
      <rect x="5" y="5" width="6" height="1" rx="0.5" fill="#94a3b8" />
      <rect x="5" y="8" width="6" height="1" rx="0.5" fill="#94a3b8" />
    </svg>
  );
}

function Row({
  n,
  depth,
  isDir,
  isOpen,
  isActive,
  onClick,
}: {
  n: FileNode;
  depth: number;
  isDir: boolean;
  isOpen: boolean;
  isActive: boolean;
  onClick: () => void;
}) {
  return (
    <div
      style={{ paddingLeft: depth * 12 }}
      className={clsx(
        'cursor-pointer select-none text-xs py-[2px] px-1',
        'hover:bg-slate-100 transition-colors',
        isActive && 'bg-sky-100 text-sky-700'
      )}
      onClick={onClick}
    >
      {getIcon(n, isDir, isOpen)}
      {n.name}
    </div>
  );
}

export default function FileExplorer() {
  const { tree, current, setCurrent, load } = useFS();
  const [open, setOpen] = useState<Record<string, boolean>>({ [TARGET_FOLDER]: true });
  const { activePath } = useEditor();

  useEffect(() => {
    (async () => {
      const data: FileNode[] = await fetch('/api/files').then((r) => r.json());
      const filteredTree = filterTree(data);
      load(filteredTree);
      useFS.getState().loadContents(); // ÌååÏùº ÎÇ¥Ïö© Î°úÎìú
    })();
  }, [load]);

  const click = (n: FileNode) => {
    if (Array.isArray(n.children)) {
      setOpen((o) => ({ ...o, [n.path ?? '']: !o[n.path ?? ''] }));
    } else if (n.path) {
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const clean = n.path.replace(regex, '');
      setCurrent(n.id);
      useEditor.getState().open({
        id: nanoid(),
        path: clean,
        name: n.name,
      });
    }
  };

  const render = (nodes: FileNode[] | FileNode | undefined, depth = 0): JSX.Element[] =>
    arr(nodes).map((n) => {
      const isDir = Array.isArray(n.children);
      const isOpen = !!open[n.path ?? ''];
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const isActive = n.path?.replace(regex, '') === activePath;

      return (
        <div key={n.id}>
          <Row
            n={n}
            depth={depth}
            isDir={isDir}
            isOpen={isOpen}
            isActive={isActive}
            onClick={() => click(n)}
          />
          {isDir && isOpen && render(n.children, depth + 1)}
        </div>
      );
    });

  return (
    <aside className="w-full pl-2 h-full overflow-y-auto border-r border-slate-300 bg-slate-50">
      {render(tree)}
    </aside>
  );
}

[src/components/IconBar.tsx]
import {
  FolderIcon,
  MagnifyingGlassIcon,
  Squares2X2Icon,
  ChatBubbleLeftRightIcon,
} from '@heroicons/react/24/outline';
import type { ComponentType, SVGProps } from 'react';

type IconType = ComponentType<SVGProps<SVGSVGElement>>;
interface Props {
  states?: {
    explorer?: boolean;
    search?: boolean;
    diagram?: boolean;
    chat?: boolean;
  };
  toggle?: {
    explorer?: () => void;
    search?: () => void;
    diagram?: () => void;
    chat?: () => void;
  };
}

export default function IconBar({ states = {}, toggle = {} }: Props) {
  const Btn = ({
    on = false,
    click = () => {},
    Icon,
  }: {
    on?: boolean;
    click?: () => void;
    Icon: IconType;
  }) => (
    <button
      onClick={click}
      className={
        'w-10 h-10 flex items-center justify-center transition-colors ' +
        (on ? 'bg-white' : 'hover:bg-slate-100')
      }
    >
      <Icon className={'w-6 ' + (on ? 'stroke-sky-600' : 'stroke-slate-600')} />
    </button>
  );

  return (
    <div className="flex flex-col border-r border-slate-300 bg-slate-200">
      <Btn on={states.explorer} click={toggle.explorer} Icon={FolderIcon} />
      <Btn on={states.search} click={toggle.search} Icon={MagnifyingGlassIcon} />
      <Btn on={states.diagram} click={toggle.diagram} Icon={Squares2X2Icon} />
      <Btn on={states.chat} click={toggle.chat} Icon={ChatBubbleLeftRightIcon} />
    </div>
  );
}

[src/components/SearchPanel.tsx]
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useEditor } from '@/store/editor';
import { nanoid } from 'nanoid';
import { useFS, getAllFilePaths } from '@/store/files';

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

// ÌÉÄÏûÖ Ï†ïÏùò: Í≤ÄÏÉâ Í≤∞Í≥ºÎäî ÌååÏùº, ÎùºÏù∏, ÎùºÏù∏ ÌÖçÏä§Ìä∏
type SearchResult = {
  file: string;
  line: number;
  text: string;
};

export default function SearchPanel() {
  const [query, setQuery] = useState('');
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [expandedFiles, setExpandedFiles] = useState<{ [file: string]: boolean }>({});
  const { tree, fileContents } = useFS();

  const allFiles = useMemo(() => getAllFilePaths(tree, false), [tree]); // Ìè¥Îçî Ï†úÏô∏, ÌååÏùºÎßå

  useEffect(() => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }
    const results: SearchResult[] = [];
    for (const file of allFiles) {
      const content = fileContents[file];
      if (!content) continue;
      const lines = content.split('\n');
      lines.forEach((lineText, idx) => {
        if (lineText.toLowerCase().includes(query.toLowerCase())) {
          results.push({
            file,
            line: idx + 1,
            text: lineText.trim(),
          });
        }
      });
    }
    setSearchResults(results);
  }, [query, allFiles, fileContents]);

  // ÌååÏùºÎ≥ÑÎ°ú Í≤∞Í≥ºÎ•º Í∑∏Î£πÌôî
  const groupedResults = useMemo(() => {
    const groups: { [file: string]: SearchResult[] } = {};
    for (const result of searchResults) {
      if (!groups[result.file]) groups[result.file] = [];
      groups[result.file].push(result);
    }
    return groups;
  }, [searchResults]);

  // Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä Î∞îÎÄåÎ©¥ Î™®Îì† ÌååÏùºÏùÑ expand
  useEffect(() => {
    const initial: { [file: string]: boolean } = {};
    Object.keys(groupedResults).forEach((file) => {
      initial[file] = true;
    });
    setExpandedFiles(initial);
  }, [groupedResults]);

  const handleToggleFile = (file: string) => {
    setExpandedFiles((prev) => ({
      ...prev,
      [file]: !prev[file],
    }));
  };

  const handleResultClick = (result: SearchResult) => {
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

    const cleanPath = result.file.replace(regex, '');
    const name = cleanPath.split('/').pop() || cleanPath;
    const editorState = useEditor.getState();
    editorState.open({
      id: nanoid(),
      path: cleanPath,
      name,
    });
    // Í≤ÄÏÉâÏñ¥Í∞Ä ÏûàÏúºÎ©¥ ÌïòÏù¥ÎùºÏù¥Ìä∏Î•º ÏúÑÌï¥ Ï†ÄÏû•
    if (query.trim()) {
      editorState.setSearchHighlights(result.line, query);
    }
  };

  return (
    <div className="w-full h-full p-2 bg-slate-50 border-r border-slate-300">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search in all files..."
        className="w-full p-2 mb-2 border rounded"
      />
      <div className="overflow-y-auto max-h-[calc(100%-2rem)]">
        {query.trim() === '' ? (
          <p className="text-xs text-gray-500">Enter a keyword</p>
        ) : searchResults.length > 0 ? (
          Object.entries(groupedResults).map(([file, results]) => (
            <div key={file} className="mb-2">
              <div
                className="font-mono text-xs font-semibold text-slate-700 mb-1 flex items-center cursor-pointer select-none"
                onClick={() => handleToggleFile(file)}
              >
                <span className="mr-1">
                  {expandedFiles[file] ? '‚ñº' : '‚ñ∂'}
                </span>
                {file}
                <span className="ml-2 text-slate-400">({results.length})</span>
              </div>
              {expandedFiles[file] && results.map((result, i) => (
                <div
                  key={i}
                  onClick={() => handleResultClick(result)}
                  className="text-xs py-1 px-2 hover:bg-slate-100 cursor-pointer flex"
                >
                  <span className="text-slate-400 mr-2">:{result.line}</span>
                  <span className="truncate text-slate-600">{result.text}</span>
                </div>
              ))}
            </div>
          ))
        ) : (
          <p className="text-xs text-gray-500">No search results found</p>
        )}
      </div>
    </div>
  );
}

[src/components/diagramUtils.tsx]
import { Node, Edge, NodeProps, Handle, Position } from '@xyflow/react';
import dagre from 'dagre';
import hljs from 'highlight.js/lib/core';
import python from 'highlight.js/lib/languages/python';
import 'highlight.js/styles/atom-one-light.css';

hljs.registerLanguage('python', python);

// Constants
export const ENDPOINTS = {
  CG: '/api/generate_call_graph',
  CFG: '/api/generate_control_flow_graph',
  INLINE_CODE_EXPLANATION: '/api/inline_code_explanation',
} as const;

export const STYLES = {
  NODE: {
    MIN_WIDTH: 60,
    PADDING: 16,
    HEIGHT: { SMALL: 35, DEFAULT: 40 },
    FONT_SIZE: '12px',
    FONT_FAMILY: 'Arial, sans-serif',
  },
  GROUP: {
    PADDING: 20,
    COLLAPSED_WIDTH: 200,
    COLLAPSED_HEIGHT: 50,
  },
  COLORS: {
    NODE: {
      DEFAULT: '#ffffff',
      HOVER: '#fef9c3',
      SELECTED: '#fca5a5',
      ACTIVE: '#dbeafe',
      BORDER: '#4A90E2',
      BORDER_HOVER: '#eab308',
      BORDER_SELECTED: '#b91c1c',
      BORDER_ACTIVE: '#0284c7',
    },
    GROUP: {
      DEFAULT: '#FAFAFA',
      COLLAPSED: '#f3f4f6',
      BORDER: '#b9bfc9',
      BORDER_COLLAPSED: '#6b7280',
      BORDER_ACTIVE: '#fb923c',
    },
    EDGE: {
      DEFAULT: '#34A853',
      HOVER: '#f59e42',
    },
  },
  CFG_PANEL: {
    WIDTH: 800,
    HEIGHT: 600,
  },
} as const;

// Types
export interface RawNode {
  id: string;
  label?: string;
  function_name?: string;
  file: string;
}

export interface RawEdge {
  id: string;
  source: string;
  target: string;
  type?: string;
}

export interface CFGPanel {
  id: string;
  functionName: string;
  file: string;
  result: any;
  expanded: boolean;
  pos: { x: number; y: number };
  dragging: boolean;
  dragOffset: { x: number; y: number };
  width?: number;
  height?: number;
  resizing?: boolean;
}

// Cache
export const snippetCache = new Map<string, string>();

// Helper Functions
export function getTextWidth(text: string, font: string = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`): number {
  if (typeof document === 'undefined') return text.length * 7;
  const canvas = (getTextWidth as any).canvas || ((getTextWidth as any).canvas = document.createElement("canvas"));
  const context = canvas.getContext("2d");
  if (!context) return text.length * 7;
  context.font = font;
  return context.measureText(text).width;
}

export function extractFunctionSnippet(code: string, functionName: string): { snippet: string, startLine: number } | null {
  const lines = code.split('\n');
  const startIndex = lines.findIndex(line => line.trim().startsWith(`def ${functionName}(`));
  if (startIndex === -1) return null;
  
  for (let i = startIndex + 1; i < lines.length; i++) {
    if (lines[i].trim() === '') continue;
    if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
      return { snippet: lines.slice(startIndex, i).join('\n'), startLine: startIndex + 1 };
    }
  }
  return { snippet: lines.slice(startIndex).join('\n'), startLine: startIndex + 1 };
}

export function highlightWithLineNumbers(snippet: string, startLine: number = 1): string {
  const highlighted = hljs.highlight(snippet, { language: 'python' }).value;
  const lines = highlighted.split('\n');
  const padding = String(startLine + lines.length - 1).length;
  return lines
    .map((line, idx) => `<span style="color:#64748b">${String(startLine + idx).padStart(padding, ' ')}</span>  ${line}`)
    .join('\n');
}

export function isNodeHidden(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): boolean {
  const node = nodes.find(n => n.id === nodeId);
  if (!node?.parentId) return false;
  return collapsedGroups.has(node.parentId) || isNodeHidden(node.parentId, collapsedGroups, nodes);
}

export function findRepresentativeNode(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): string {
  const node = nodes.find(n => n.id === nodeId);
  if (!node) return nodeId;
  if (node.type === 'group' || !node.parentId) return nodeId;
  if (collapsedGroups.has(node.parentId)) return node.parentId;
  
  let current = node;
  while (current.parentId) {
    const parent = nodes.find(n => n.id === current.parentId);
    if (!parent) break;
    if (parent.type === 'group' && collapsedGroups.has(parent.id)) return parent.id;
    current = parent;
  }
  return nodeId;
}

export function calculateLayout(
  files: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>,
  nodeWidths: Record<string, number>
): Record<string, { x: number; y: number }> {
  const totalNodes = Object.values(files).reduce((sum, f) => sum + f.nodes.length, 0);
  const nodesep = totalNodes > 50 ? 15 : totalNodes > 30 ? 20 : 25;
  const ranksep = totalNodes > 50 ? 40 : totalNodes > 30 ? 50 : 60;
  
  const g = new dagre.graphlib.Graph({ compound: true, multigraph: true })
    .setGraph({
      rankdir: 'TB',
      nodesep,
      ranksep,
      ranker: 'tight-tree',
      align: 'DL',
      marginx: 10,
      marginy: 10,
    })
    .setDefaultEdgeLabel(() => ({}));
    
  Object.keys(files).forEach(file => g.setNode(`cluster_${file}`, { marginx: 10, marginy: 10 }));
  
  Object.entries(files).forEach(([file, { nodes, edges }]) => {
    nodes.forEach(n => {
      const width = nodeWidths[n.id] || STYLES.NODE.MIN_WIDTH;
      const height = totalNodes > 50 ? STYLES.NODE.HEIGHT.SMALL : STYLES.NODE.HEIGHT.DEFAULT;
      g.setNode(n.id, { width, height });
      g.setParent(n.id, `cluster_${file}`);
    });
  });
  
  Object.values(files).forEach(({ edges }) => {
    edges.forEach(({ source, target }) => {
      if (!g.hasEdge(source, target)) g.setEdge(source, target, { weight: 1 });
    });
  });
  
  dagre.layout(g);
  
  const positions: Record<string, { x: number; y: number }> = {};
  g.nodes().forEach(id => {
    const node = g.node(id);
    if (node && !id.startsWith('cluster_') && node.x != null && node.y != null) {
      positions[id] = { x: node.x, y: node.y };
    }
  });
  
  return positions;
}

// Custom Group Node Component
export function CustomGroupNode({ data }: NodeProps) {
  const { label, isCollapsed, onToggleCollapse } = data;

  const ChevronIcon = ({ direction = 'down' }: { direction: 'down' | 'right' }) => (
    <svg
      width={20}
      height={20}
      viewBox="0 0 24 24"
      style={{
        color: '#6366f1',
        transition: 'transform 0.15s',
        transform: direction === 'right' ? 'rotate(-90deg)' : 'none',
      }}
      fill="none"
      stroke="currentColor"
      strokeWidth={2.5}
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <polyline points="6 9 12 15 18 9" />
    </svg>
  );

  if (isCollapsed) {
    return (
      <>
        <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
        <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
        <div
          style={{
            width: '100%',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontWeight: 600,
            fontSize: 13,
            color: '#444',
            cursor: 'pointer',
            gap: 8,
          }}
          onClick={(e) => {
            e.stopPropagation();
            onToggleCollapse();
          }}
        >
          <ChevronIcon direction="right" />
          <span>{label}</span>
        </div>
      </>
    );
  }

  return (
    <>
      <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
      <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
      <div
        style={{
          position: 'absolute',
          top: -32,
          left: 0,
          width: '100%',
          fontWeight: 600,
          fontSize: 13,
          color: '#444',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: 8,
          height: 32,
        }}
      >
        <span
          onClick={(e) => {
            e.stopPropagation();
            onToggleCollapse();
          }}
          style={{ cursor: 'pointer', display: 'flex', alignItems: 'center' }}
        >
          <ChevronIcon direction="down" />
        </span>
        <span>{label}</span>
      </div>
    </>
  );
}

// Utility functions
export function parseApiResponse(response: any): any {
  return typeof response?.data === 'string' ? JSON.parse(response.data) : response.data;
}

export function cleanFilePath(path: string, targetFolder?: string): string {
  if (!targetFolder) return path;
  const regex = new RegExp(`^${targetFolder}[\\\\/]`);
  return path.replace(regex, '');
}

export function calculateNodeWidth(label: string): number {
  const textWidth = getTextWidth(label);
  return Math.max(STYLES.NODE.MIN_WIDTH, textWidth + STYLES.NODE.PADDING);
}

[src/components/export_code.py]
from pathlib import Path

COMP = Path(__file__).resolve().parent

# ÌäπÏ†ï Ïª¥Ìè¨ÎÑåÌä∏ ÌååÏùºÎßå ÏÑ†ÌÉù
target_components = [
    COMP / "diagramUtils.tsx",
    COMP / "DiagramViewer.tsx"
]

# Ï°¥Ïû¨ÌïòÎäî ÌååÏùºÎßå ÌïÑÌÑ∞ÎßÅ
targets = [f for f in target_components if f.is_file()]

# ÏÉÅÎåÄ Í≤ΩÎ°ú Ï∂úÎ†• Ìï®Ïàò
def get_rel_path(p: Path) -> str:
    try:
        return p.relative_to(COMP).as_posix()
    except ValueError:
        return p.relative_to(COMP.parent).as_posix()

print("ÏÑ†ÌÉùÎêú ÌååÏùºÎì§:")
print([get_rel_path(p) for p in targets])

# ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
out_path = COMP / "selected_components.txt"
with out_path.open("w", encoding="utf-8") as out:
    for file_path in targets:
        rel_path = get_rel_path(file_path)
        out.write(f"[{rel_path}]\n")
        out.write(file_path.read_text(encoding="utf-8"))
        out.write("\n\n")

print(f"‚úÖ ÏôÑÎ£å: {out_path.relative_to(COMP)} ÏÉùÏÑ±")

[src/components/selected_components.txt]
[diagramUtils.tsx]
import { Node, Edge, NodeProps, Handle, Position } from '@xyflow/react';
import dagre from 'dagre';
import hljs from 'highlight.js/lib/core';
import python from 'highlight.js/lib/languages/python';
import 'highlight.js/styles/atom-one-light.css';

hljs.registerLanguage('python', python);

// Types
export interface RawNode {
  id: string;
  label?: string;
  function_name?: string;
  file: string;
}

export interface RawEdge {
  id: string;
  source: string;
  target: string;
  type?: string;
}

export interface CFGPanel {
  id: string;
  functionName: string;
  file: string;
  result: any;
  expanded: boolean;
  pos: { x: number; y: number };
  dragging: boolean;
  dragOffset: { x: number; y: number };
  width?: number;
  height?: number;
  resizing?: boolean;
}

// Cache
export const snippetCache = new Map<string, string>();

// Helper Functions
export function getTextWidth(text: string, font: string = '12px Arial'): number {
  if (typeof document === 'undefined') return text.length * 7;
  const canvas = (getTextWidth as any).canvas || ((getTextWidth as any).canvas = document.createElement("canvas"));
  const context = canvas.getContext("2d");
  if (!context) {
    return text.length * 7;
  }
  context.font = font;
  const metrics = context.measureText(text);
  return metrics.width;
}
(getTextWidth as any).canvas = null;

export function extractFunctionSnippetWithLine(code: string, functionName: string): { snippet: string, startLine: number } | null {
  const lines = code.split('\n');
  let startLine = -1;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim().startsWith(`def ${functionName}(`) && line === line.trim()) {
      startLine = i;
      break;
    }
  }
  if (startLine === -1) return null;
  for (let i = startLine + 1; i < lines.length; i++) {
    if (lines[i].trim() === '') continue;
    if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
      return { snippet: lines.slice(startLine, i).join('\n'), startLine: startLine + 1 };
    }
  }
  return { snippet: lines.slice(startLine).join('\n'), startLine: startLine + 1 };
}

export function addLineNumbersAndHighlight(snippet: string, start: number = 1): string {
  const highlighted = hljs.highlight(snippet, { language: 'python' }).value;
  const lines = highlighted.split('\n');
  const pad = String(start + lines.length - 1).length;
  return lines
    .map((line, idx) => {
      const num = String(start + idx).padStart(pad, ' ');
      return `<span style="color:#64748b">${num}</span>  ${line}`;
    })
    .join('\n');
}

export function isNodeHidden(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): boolean {
  const node = nodes.find(n => n.id === nodeId);
  if (!node || !node.parentId) return false;
  
  if (collapsedGroups.has(node.parentId)) {
    return true;
  }
  
  return isNodeHidden(node.parentId, collapsedGroups, nodes);
}

export function findRepresentativeGroup(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): string {
  const node = nodes.find(n => n.id === nodeId);
  if (!node) {
    return nodeId;
  }
  
  if (node.type === 'group') {
    return nodeId;
  }
  
  if (node.parentId && collapsedGroups.has(node.parentId)) {
    return node.parentId;
  }
  
  let currentNode = node;
  while (currentNode.parentId) {
    const parentNode = nodes.find(n => n.id === currentNode.parentId);
    if (!parentNode) break;
    
    if (parentNode.type === 'group' && collapsedGroups.has(parentNode.id)) {
      return parentNode.id;
    }
    currentNode = parentNode;
  }
  
  return nodeId;
}

export function getRedirectedEdge(edge: Edge, collapsedGroups: Set<string>, nodes: Node[]): Edge | null {
  const sourceNode = nodes.find(n => n.id === edge.source);
  const targetNode = nodes.find(n => n.id === edge.target);
  
  if (!sourceNode || !targetNode) {
    return edge;
  }
  
  const newSource = findRepresentativeGroup(edge.source, collapsedGroups, nodes);
  const newTarget = findRepresentativeGroup(edge.target, collapsedGroups, nodes);
  
  if (newSource === newTarget) {
    return null;
  }
  
  if (newSource === edge.source && newTarget === edge.target) {
    return edge;
  }
  
  return {
    ...edge,
    id: `${edge.id}_redirected_${newSource}_${newTarget}`,
    source: newSource,
    target: newTarget,
    data: {
      ...edge.data,
      originalSource: edge.source,
      originalTarget: edge.target,
      isRedirected: true,
    },
  };
}

// Layout Function
export function layoutWithCluster(
  files: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>,
  nodeWidths: Record<string, number>
): Record<string, { x: number; y: number }> {
  const totalFiles = Object.keys(files).length;
  const totalNodes = Object.values(files).reduce((sum, f) => sum + f.nodes.length, 0);
  
  const maxWidth = window.innerWidth * 0.5;
  
  const averageNodeWidth = Object.values(nodeWidths).length > 0 
    ? Object.values(nodeWidths).reduce((sum, w) => sum + w, 0) / Object.values(nodeWidths).length
    : (totalNodes > 50 ? 100 : 120);

  const maxNodesPerRank = Math.floor(maxWidth / (averageNodeWidth + 30));
  
  const nodesep = totalNodes > 50 ? 15 : totalNodes > 30 ? 20 : 25;
  const ranksep = totalNodes > 50 ? 40 : totalNodes > 30 ? 50 : 60;
  
  const g = new dagre.graphlib.Graph({ compound: true, multigraph: true })
    .setGraph({
      rankdir: 'TB',
      nodesep: nodesep,
      ranksep: ranksep,
      ranker: 'tight-tree',
      align: 'DL',
      marginx: 10,
      marginy: 10,
    })
    .setDefaultEdgeLabel(() => ({}));
    
  Object.keys(files).forEach((file) => {
    g.setNode(`cluster_${file}`, {
      marginx: 10,
      marginy: 10,
    });
  });
  
  Object.entries(files).forEach(([file, { nodes, edges }]) => {
    const nodeDepths = new Map<string, number>();
    const nodeChildren = new Map<string, string[]>();
    
    edges.forEach(({ source, target }) => {
      if (!nodeChildren.has(source)) {
        nodeChildren.set(source, []);
      }
      nodeChildren.get(source)!.push(target);
    });
    
    const visited = new Set<string>();
    const queue: { node: string; depth: number }[] = [];
    const incomingEdges = new Set(edges.map(e => e.target));
    const rootNodes = nodes.filter(n => !incomingEdges.has(n.id));
    
    rootNodes.forEach(root => {
      queue.push({ node: root.id, depth: 0 });
    });
    
    while (queue.length > 0) {
      const { node, depth } = queue.shift()!;
      if (visited.has(node)) continue;
      
      visited.add(node);
      nodeDepths.set(node, depth);
      
      const children = nodeChildren.get(node) || [];
      children.forEach(child => {
        queue.push({ node: child, depth: depth + 1 });
      });
    }
    
    const depthGroups = new Map<number, string[]>();
    nodeDepths.forEach((depth, nodeId) => {
      if (!depthGroups.has(depth)) {
        depthGroups.set(depth, []);
      }
      depthGroups.get(depth)!.push(nodeId);
    });
    
    let virtualNodeCount = 0;
    depthGroups.forEach((nodesAtDepth, depth) => {
      if (nodesAtDepth.length > maxNodesPerRank && depth > 0) {
        const chunks = [];
        for (let i = 0; i < nodesAtDepth.length; i += maxNodesPerRank) {
          chunks.push(nodesAtDepth.slice(i, i + maxNodesPerRank));
        }
        
        if (chunks.length > 1) {
          chunks.forEach((chunk, chunkIndex) => {
            const virtualNodeId = `virtual_${file}_${depth}_${virtualNodeCount++}`;
            g.setNode(virtualNodeId, {
              width: 1,
              height: 1,
              dummy: true,
            });
            g.setParent(virtualNodeId, `cluster_${file}`);
            
            const parents = new Set<string>();
            chunk.forEach(nodeId => {
              edges.forEach(edge => {
                if (edge.target === nodeId) {
                  parents.add(edge.source);
                }
              });
            });
            
            parents.forEach(parent => {
              g.setEdge(parent, virtualNodeId, {
                weight: 0.1,
              });
            });
            
            chunk.forEach(nodeId => {
              g.setEdge(virtualNodeId, nodeId, {
                weight: 10,
              });
            });
          });
        }
      }
    });
    
    nodes.forEach((n) => {
      const width = nodeWidths[n.id] || (totalNodes > 50 ? 100 : 120);
      const height = totalNodes > 50 ? 35 : 40;
      
      g.setNode(n.id, { 
        width: width,
        height: height,
      });
      g.setParent(n.id, `cluster_${file}`);
    });
  });
  
  Object.values(files).forEach(({ edges }) => {
    edges.forEach(({ source, target }) => {
      if (!g.hasEdge(source, target)) {
        g.setEdge(source, target, {
          weight: 1,
        });
      }
    });
  });
  
  dagre.layout(g);
  
  const pos: Record<string, { x: number; y: number }> = {};
  g.nodes().forEach((id: string) => {
    const n = g.node(id);
    if (n && !n.dummy && n.x != null && n.y != null) {
      pos[id] = { x: n.x, y: n.y };
    }
  });
  
  return pos;
}

// Custom Group Node Component
export function CustomGroupNode({ data, id }: NodeProps) {
  const { label, isCollapsed, onToggleCollapse } = data;

  const ChevronIcon = ({ direction = 'down' }: { direction: 'down' | 'right' }) => (
    <svg
      width={20}
      height={20}
      viewBox="0 0 24 24"
      style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#6366f1',
        transition: 'transform 0.15s',
        transform: direction === 'right' ? 'rotate(-90deg)' : 'none',
      }}
      fill="none"
      stroke="currentColor"
      strokeWidth={2.5}
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <polyline points="6 9 12 15 18 9" />
    </svg>
  );

  if (isCollapsed) {
    return (
      <>
        <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
        <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
        <div
          style={{
            width: '100%',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontWeight: 600,
            fontSize: 13,
            color: '#444',
            cursor: 'pointer',
            gap: 8,
          }}
          onClick={(e) => {
            e.stopPropagation();
            onToggleCollapse();
          }}
        >
          <ChevronIcon direction="right" />
          <span style={{ display: 'flex', alignItems: 'center' }}>{label}</span>
        </div>
      </>
    );
  }

  return (
    <>
      <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
      <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
      <div
        style={{
          position: 'absolute',
          top: -32,
          left: 0,
          width: '100%',
          fontWeight: 600,
          fontSize: 13,
          color: '#444',
          pointerEvents: 'none',
          userSelect: 'none',
          display: 'flex',
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'center',
          gap: 8,
          height: 32,
        }}
      >
        <div
          style={{
            display: 'inline-flex',
            flexDirection: 'row',
            alignItems: 'center',
            gap: 8,
            pointerEvents: 'auto',
            height: '100%',
          }}
        >
          <span
            onClick={(e) => {
              e.stopPropagation();
              onToggleCollapse();
            }}
            style={{
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              lineHeight: 1,
              height: '1em',
            }}
          >
            <ChevronIcon direction="down" />
          </span>
          <span
            style={{
              display: 'flex',
              alignItems: 'center',
              lineHeight: 1,
              height: '1em',
            }}
          >
            {label}
          </span>
        </div>
      </div>
    </>
  );
}

[DiagramViewer.tsx]
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  ReactFlow,
  Background,
  MiniMap,
  Controls,
  MarkerType,
  type Node,
  type Edge,
  type NodeMouseHandler,
  applyNodeChanges,
  NodeChange,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { nanoid } from 'nanoid';
import { useEditor } from '@/store/editor';
import { useFS, type FileNode } from '@/store/files';
import {
  RawNode,
  RawEdge,
  CFGPanel,
  snippetCache,
  getTextWidth,
  extractFunctionSnippetWithLine,
  addLineNumbersAndHighlight,
  isNodeHidden,
  findRepresentativeGroup,
  getRedirectedEdge,
  layoutWithCluster,
  CustomGroupNode,
} from './diagramUtils';

// Constants
let diagramCache: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> | null = null;
const ENDPOINT_CG = '/api/generate_call_graph';
const ENDPOINT_CFG = '/api/generate_control_flow_graph';
const ENDPOINT_INLINE_CODE_EXPLANATION = '/api/inline_code_explanation';
const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';
const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export default function DiagramViewer() {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [loading, setLoad] = useState(true);
  const [error, setErr] = useState<string>();
  const [hoverId, setHoverId] = useState<string | null>(null);
  const [snippet, setSnippet] = useState<string>('');
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [cfgMessage, setCfgMessage] = useState<string | null>(null);
  const [cfgPanels, setCfgPanels] = useState<CFGPanel[]>([]);
  const [cfgLoading, setCfgLoading] = useState(false);
  const [diagramReady, setDiagramReady] = useState(false);
  const [hoveredEdgeId, setHoveredEdgeId] = useState<string | null>(null);
  const [collapsedGroups, setCollapsedGroups] = useState<Set<string>>(new Set());
  const [cfgPanelMessage, setCfgPanelMessage] = useState<string | null>(null);

  const editorState = useEditor.getState();
  const fsState = useFS.getState();

  const activePath =
    editorState.tabs.find((t) => t.id === editorState.activeId)?.path ??
    editorState.tabs.at(-1)?.path ??
    '';

  const onToggleCollapse = useCallback((groupId: string) => {
    setCollapsedGroups((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(groupId)) {
        newSet.delete(groupId);
      } else {
        newSet.add(groupId);
      }
      return newSet;
    });
  }, []);

  const onNodeClick: NodeMouseHandler = (_, node) => {
    if (node.type === 'group') {
      const childNode = nodes.find(n => n.parentId === node.id && !isNodeHidden(n.id, collapsedGroups, nodes));
      const filePath = childNode ? (childNode.data as any)?.file : (node.data as any)?.file;
      if (!filePath) return;
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const clean = filePath.replace(regex, '');
      editorState.open({
        id: nanoid(),
        path: clean,
        name: clean.split(/[\\/]/).pop() ?? clean,
        line: 1,
      });
      const target = findByPath(fsState.tree, clean);
      if (target) fsState.setCurrent(target.id);
      return;
    }
    setSelectedNodeId(prev => prev === node.id ? null : node.id);
    const raw = (node.data as any)?.file as string | undefined;
    if (!raw) return;
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = raw.replace(regex, '');
    editorState.open({
      id: nanoid(),
      path: clean,
      name: clean.split(/[\\/]/).pop() ?? clean,
    });
    const target = findByPath(fsState.tree, clean);
    if (target) fsState.setCurrent(target.id);
  };

  const onEnter: NodeMouseHandler = async (_, node) => {
    if (node.type === 'group') return;
    
    setHoverId(node.id);
    const raw = (node.data as any)?.file as string | undefined;
    const functionName = (node.data as any)?.label as string | undefined;
    if (!raw || !functionName) {
      setSnippet('');
      return;
    }
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = raw.replace(regex, '');
    const cacheKey = `${clean}_${functionName}`;
    if (snippetCache.has(cacheKey)) {
      try {
        const txt = await fetch(`/api/file?path=${encodeURIComponent(clean)}`).then((r) => r.text());
        const result = extractFunctionSnippetWithLine(txt, functionName);
        if (result) {
          setSnippet(addLineNumbersAndHighlight(result.snippet, result.startLine));
        } else {
          setSnippet('(function not found)');
        }
      } catch {
        setSnippet('(preview unavailable)');
      }
      return;
    }
    try {
      const txt = await fetch(`/api/file?path=${encodeURIComponent(clean)}`).then((r) => r.text());
      const result = extractFunctionSnippetWithLine(txt, functionName);
      if (result) {
        snippetCache.set(cacheKey, result.snippet);
        setSnippet(addLineNumbersAndHighlight(result.snippet, result.startLine));
      } else {
        setSnippet('(function not found)');
      }
    } catch {
      setSnippet('(preview unavailable)');
    }
  };

  const onLeave: NodeMouseHandler = () => {
    setHoverId(null);
    setSnippet('');
  };

  const onEdgeMouseEnter = useCallback((event: React.MouseEvent, edge: Edge) => {
    setHoveredEdgeId(edge.id);
  }, []);
  const onEdgeMouseLeave = useCallback(() => {
    setHoveredEdgeId(null);
  }, []);

  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((nds) => applyNodeChanges(changes, nds));
    },
    [setNodes]
  );

  const handleCFGPanelUpdate = useCallback((id: string, updates: Partial<CFGPanel>) => {
    setCfgPanels(panels =>
      panels.map(p => p.id === id ? { ...p, ...updates } : p)
    );
  }, []);

  const handleCFGPanelClose = useCallback((id: string) => {
    setCfgPanels(panels => panels.filter(p => p.id !== id));
  }, []);

  const handleCFGNodeHover = useCallback(async (node: Node | null, panel: CFGPanel) => {
    if (!node) {
      setCfgPanelMessage(null);
      return;
    }

    const label = (node.data as any)?.label ?? node.id;
    const file = (node.data as any)?.file;
    const line_start = (node.data as any)?.line_start ?? undefined;
    const line_end = (node.data as any)?.line_end ?? undefined;

    // 1. Î°úÎî© Î©îÏãúÏßÄ ÌëúÏãú
    setCfgPanelMessage(
      `<div style="display:flex;align-items:flex-start;gap:8px;">
        <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
        <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
          ÏÑ§Î™ÖÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...
        </span>
      </div>`
    );

    try {
      // 2. API Ìò∏Ï∂ú
      const res = await fetch(`${apiUrl}${ENDPOINT_INLINE_CODE_EXPLANATION}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          file_path: panel.file,
          line_start,
          line_end,
        }),
      });
      const data = await res.json();
      let explain = typeof data.explanation === 'string' ? data.explanation : (data.data?.explanation ?? '');
      if (!explain) explain = 'ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';

      // 3. ÏÑ§Î™Ö Î©îÏãúÏßÄ ÌëúÏãú
      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:320px;display:inline-block;white-space;">
            ${explain}
          </span>
        </div>`
      );
    } catch (e: any) {
      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
            ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
          </span>
        </div>`
      );
    }

    // Í∏∞Ï°¥ ÏΩîÎìú: ÌååÏùº Ïó¥Í∏∞/ÌÉ≠ ÌôúÏÑ±Ìôî
    if (file) {
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const clean = file.replace(regex, '');
      const tab = editorState.tabs.find(t => t.path === clean);
      if (tab) {
        editorState.setActive(tab.id, { from: line_start, to: line_end });
      } else {
        editorState.open({
          id: nanoid(),
          path: clean,
          name: clean.split(/[\\/]/).pop() ?? clean,
          line: line_start,
          highlight: {from: line_start, to: line_end},
        });
      }
      const target = findByPath(fsState.tree, clean);
      if (target) fsState.setCurrent(target.id);
    }
  }, [apiUrl, editorState, fsState]);

  const handleGenerateCFG = async () => {
    setCfgMessage(null);
    setCfgLoading(true);
    const selectedNode = nodes.find(n => n.id === selectedNodeId && n.type !== 'group');
    if (!selectedNode) {
      setCfgMessage('ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }
    const file = (selectedNode.data as any)?.file;
    const functionName = (selectedNode.data as any)?.label;
    if (!file || !functionName) {
      setCfgMessage('ÎÖ∏Îìú Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }

    // Prevent duplicate panel for the same file/function
    const alreadyExists = cfgPanels.some(
      p => p.file === file && p.functionName === functionName
    );
    if (alreadyExists) {
      setCfgMessage('Ïù¥ÎØ∏ Ìï¥Îãπ Ìï®ÏàòÏùò CFG Ìå®ÎÑêÏù¥ Ïó¥Î†§ ÏûàÏäµÎãàÎã§.');
      setCfgLoading(false);
      return;
    }

    try {
      const res = await fetch(`${apiUrl}${ENDPOINT_CFG}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          file_path: file,
          function_name: functionName,
        }),
      });
      const data = await res.json();
      if (data.status && data.status !== 200) {
        setCfgMessage('API Ìò∏Ï∂ú Ïã§Ìå®: ' + (data.data || ''));
      } else {
        const cfgRaw = typeof data.data === 'string' ? JSON.parse(data.data) : data.data;
        let cfgNodes = (cfgRaw.nodes || []).map((n: any) => ({
          id: n.id,
          data: { 
            label: n.label || n.id,
            file: n.file || file,
            line_start: n.line_start || 1,
            line_end: n.line_end || 1,
          },
          position: { x: n.x ?? 0, y: n.y ?? 0 },
          style: {
            padding: 4,
            borderRadius: 3,
            border: '1px solid #0284c7',
            background: '#fff',
            fontSize: 12,
            minWidth: 40,
            minHeight: 24,
          },
        }));
        const cfgEdges = (cfgRaw.edges || []).map((e: any) => ({
          id: e.id || `${e.source}-${e.target}`,
          source: e.source,
          target: e.target,
          markerEnd: { type: MarkerType.ArrowClosed },
          animated: true,
          style: { stroke: '#0284c7', strokeWidth: 2 },
        }));

        if (
          cfgRaw.nodes?.length > 0 &&
          cfgRaw.nodes.every((n: any) => (!n.x && !n.y))
        ) {
          const posMap = layoutWithCluster({ [file]: { nodes: cfgRaw.nodes, edges: cfgRaw.edges } }, {});
          cfgNodes = cfgNodes.map((n: any) => ({
            ...n,
            position: posMap[n.id] ?? { x: 0, y: 0 }
          }));
        }

        const id = `${file}__${functionName}__${Date.now()}`;
        setCfgPanels(panels => [
          ...panels,
          {
            id,
            functionName,
            file,
            result: { nodes: cfgNodes, edges: cfgEdges },
            expanded: true,
            pos: { x: 24 + panels.length * 32, y: 24 + panels.length * 32 },
            dragging: false,
            dragOffset: { x: 0, y: 0 },
            width: 800,
            height: 600,
          },
        ]);
        setCfgMessage(null);
      }
    } catch (e: any) {
      setCfgMessage('API Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. error: ' + e.message);
    } finally {
      setCfgLoading(false);
    }
  };

  useEffect(() => {
    if (!diagramReady) return;
    (async () => {
      if (diagramCache) {
        hydrate(diagramCache);
        setLoad(false);
        return;
      }
      setLoad(true);
      setErr(undefined);
      try {
        const res = await fetch(`${apiUrl}${ENDPOINT_CG}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: `../../${TARGET_FOLDER}`, file_type: 'py' }),
        });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const raw = await res.json();
        const json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> =
          typeof raw?.data === 'string' ? JSON.parse(raw.data) : raw.data;
        diagramCache = json;
        hydrate(json);
      } catch (e: any) {
        setErr(String(e));
        setNodes([]);
        setEdges([]);
      } finally {
        setLoad(false);
      }
    })();
  }, [diagramReady]);

  // Process edges to handle collapsed groups
  const processedEdges = edges.map((e) => {
    const sourceRepresentative = findRepresentativeGroup(e.source, collapsedGroups, nodes);
    const targetRepresentative = findRepresentativeGroup(e.target, collapsedGroups, nodes);
    
    const isRedirected = sourceRepresentative !== e.source || targetRepresentative !== e.target;
    
    if (sourceRepresentative === targetRepresentative && collapsedGroups.has(sourceRepresentative)) {
      return {
        ...e,
        hidden: true,
      };
    }
    
    const finalEdge = isRedirected ? {
      ...e,
      id: `${e.id}_redirected_${sourceRepresentative}_${targetRepresentative}`,
      source: sourceRepresentative,
      target: targetRepresentative,
      data: {
        ...e.data,
        originalSource: e.source,
        originalTarget: e.target,
        isRedirected: true,
      },
    } : e;
    
    const isHover = hoveredEdgeId === finalEdge.id;
    
    return {
      ...finalEdge,
      hidden: false,
      style: {
        ...(finalEdge.style || {}),
        stroke: isHover ? '#f59e42' : '#34A853',
        strokeWidth: isHover ? 4 : (isRedirected ? 3 : (finalEdge.style?.strokeWidth ?? 2)),
        strokeDasharray: isRedirected ? '5 5' : undefined,
        transition: 'all 0.13s',
        cursor: 'pointer',
      },
      markerEnd: {
        ...(finalEdge.markerEnd || {}),
        color: isHover ? '#f59e42' : '#34A853',
      },
      zIndex: isRedirected ? 10001 : 10000,
    };
  });

  // Remove duplicate edges and ensure unique keys
  const seenEdges = new Map<string, Edge>();
  processedEdges.forEach((edge) => {
    const key = `${edge.source}-${edge.target}`;
    const existingEdge = seenEdges.get(key);
    
    if (!existingEdge || edge.data?.isRedirected) {
      seenEdges.set(key, edge);
    }
  });
  
  const finalEdges = Array.from(seenEdges.values());

  // Create finalNodes
  const finalNodes = nodes.map((n) => {
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = ((n.data as any)?.file || '').replace(regex, '');
    const isActive = clean === activePath;
    const isHover = hoverId === n.id;
    const isSelected = selectedNodeId === n.id;
    const isGroup = n.type === 'group';
    const isCollapsed = isGroup && collapsedGroups.has(n.id);
    const isHidden = !isGroup && isNodeHidden(n.id, collapsedGroups, nodes);

    return {
      ...n,
      type: isGroup ? 'group' : (n.type || 'default'),
      hidden: isHidden,
      style: {
        ...n.style,
        background: isGroup
          ? isCollapsed 
            ? '#f3f4f6'
            : isHover
              ? '#fef9c3'
              : isSelected
                ? '#fca5a5'
                : isActive
                  ? '#dbeafe'
                  : '#FAFAFA'
          : isHover
            ? '#fef9c3'
            : isSelected
              ? '#fca5a5'
              : isActive
                ? '#dbeafe'
                : '#ffffff',
        border: isGroup
          ? isCollapsed
            ? '2px solid #6b7280'
            : isHover
              ? '4px solid #eab308'
              : isActive
                ? '1px solid #fb923c'
                : '1px solid #b9bfc9'
          : isHover
            ? '4px solid #eab308'
            : isSelected
              ? '4px solid #b91c1c'
              : isActive
                ? '1px solid #0284c7'
                : '1px solid #4A90E2',
        transition: 'all 0.1s ease-in-out',
        minWidth: isGroup ? (isCollapsed ? 200 : undefined) : (n.style?.width as number | undefined),
        width: isGroup && isCollapsed ? 200 : n.style?.width,
        height: isGroup && isCollapsed ? 50 : n.style?.height,
        cursor: isGroup && isCollapsed ? 'pointer' : 'default',
      },
      data: isGroup
        ? {
            ...n.data,
            isCollapsed,
            onToggleCollapse: () => onToggleCollapse(n.id),
          }
        : n.data,
    };
  });

  const reLayout = useCallback(() => {
    if (diagramCache) {
      hydrate(diagramCache);
    }
  }, []);

  const hydrate = (json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>) => {
    const nodeSpecificWidths: Record<string, number> = {};
    const textHorizontalPaddingTotal = 16;
    const minNodeWidth = 60;
    const nodeFontSize = '12px';
    const nodeFontFamily = 'Arial, sans-serif';
    const nodeFont = `${nodeFontSize} ${nodeFontFamily}`;

    // Pre-calculate widths for all function nodes
    Object.values(json).forEach(data => {
      data.nodes.forEach(rawNode => {
        const label = rawNode.label || rawNode.function_name || rawNode.id;
        const estimatedTextWidth = getTextWidth(label, nodeFont);
        const calculatedWidth = Math.max(minNodeWidth, estimatedTextWidth + textHorizontalPaddingTotal);
        nodeSpecificWidths[rawNode.id] = calculatedWidth;
      });
    });

    let allFunctionNodes: Node[] = [];
    let allRawEdges: RawEdge[] = [];
    Object.entries(json).forEach(([file, data]) => {
      const { nodes: rawNodes, edges: rawEdges } = data;
      const fileFunctionNodes: Node[] = rawNodes.map((r) => {
        const label = r.label || r.function_name || r.id;
        const nodeWidth = nodeSpecificWidths[r.id];
        return {
          id: r.id,
          data: { label: label, file: r.file },
          position: { x: 0, y: 0 },
          style: {
            padding: '6px 8px',
            borderRadius: 4,
            border: '1px solid #3b82f6',
            background: '#fff',
            width: nodeWidth,
            fontSize: nodeFontSize,
            fontFamily: nodeFontFamily,
          },
          zIndex: 1,
        };
      });
      allFunctionNodes = allFunctionNodes.concat(fileFunctionNodes);
      allRawEdges = allRawEdges.concat(rawEdges);
    });
    const allNodeIds = new Set(allFunctionNodes.map((n) => n.id));
    const allEdges: Edge[] = allRawEdges
      .filter((e) => allNodeIds.has(e.source) && allNodeIds.has(e.target))
      .map((r) => ({
        id: r.id,
        source: r.source,
        target: r.target,
        markerEnd: {
          type: MarkerType.ArrowClosed,
          width: 15,
          height: 15,
          color: '#34A853',
        },
        animated: true,
        style: { stroke: '#34A853', strokeWidth: 2 },
        zIndex: 10000,
        type: 'step',
      }));

    const posMap = layoutWithCluster(json, nodeSpecificWidths);

    const laidOutFunctionNodes = allFunctionNodes.map((n) => ({
      ...n,
      position: posMap[n.id] ?? { x: 0, y: 0 },
    }));

    const groupNodes: Node[] = [];
    const groupPadding = 20;
    const defaultNodeHeight = 30;

    const fileToNodes: Record<string, Node[]> = {};
    laidOutFunctionNodes.forEach((node) => {
      const file = (node.data as any).file;
      if (!fileToNodes[file]) fileToNodes[file] = [];
      fileToNodes[file].push(node);
    });

    Object.entries(fileToNodes).forEach(([file, nodesInGroup]) => {
      if (nodesInGroup.length === 0) return;
      const xs = nodesInGroup.map((n) => n.position.x);
      const ys = nodesInGroup.map((n) => n.position.y);
      const minX = Math.min(...xs);
      const minY = Math.min(...ys);
      
      const maxX = Math.max(...nodesInGroup.map(n => n.position.x + ((n.style?.width as number) || minNodeWidth)));
      const maxY = Math.max(...nodesInGroup.map(n => n.position.y + ((n.style?.height as number) || defaultNodeHeight)));
      
      const groupId = `group-${file.replace(/[^a-zA-Z0-9]/g, '_')}`;
      groupNodes.push({
        id: groupId,
        type: 'group',
        data: { 
          label: file.split('/').pop() || file,
          file: file
        },
        position: { x: minX - groupPadding, y: minY - groupPadding },
        style: {
          width: maxX - minX + 2 * groupPadding,
          height: maxY - minY + 2 * groupPadding,
          background: 'rgba(0, 0, 0, 0.05)',
          border: '1px dashed #fb923c',
          borderRadius: 8,
        },
        zIndex: 0,
      });
      nodesInGroup.forEach((node) => {
        node.position = {
          x: node.position.x - (minX - groupPadding),
          y: node.position.y - (minY - groupPadding),
        };
        node.parentId = groupId;
        node.extent = 'parent';
      });
    });
    const allNodes = [...groupNodes, ...laidOutFunctionNodes];
    setNodes(allNodes);
    setEdges(allEdges);
  };

  if (!diagramReady) {
    return (
      <div className="flex items-center justify-center h-full w-full">
        <button
          onClick={() => setDiagramReady(true)}
          style={{
            minWidth: 180,
            padding: '12px 32px',
            borderRadius: 8,
            background: '#fff',
            color: '#3b3b4f',
            fontWeight: 600,
            fontSize: 18,
            border: '1.5px solid #d1d5db',
            boxShadow: '0 2px 8px #0001',
            outline: 'none',
            cursor: 'pointer',
            transition: 'background 0.13s, box-shadow 0.13s, border 0.13s, color 0.13s',
            letterSpacing: 0.5,
          }}
          onMouseOver={e => {
            e.currentTarget.style.background = '#f3f4f6';
            e.currentTarget.style.border = '1.5px solid #6366f1';
            e.currentTarget.style.color = '#4338ca';
          }}
          onMouseOut={e => {
            e.currentTarget.style.background = '#fff';
            e.currentTarget.style.border = '1.5px solid #d1d5db';
            e.currentTarget.style.color = '#3b3b4f';
          }}
        >
          <span style={{
            display: 'inline-block',
            marginRight: 8,
            verticalAlign: 'middle',
            fontSize: 18,
            color: '#6366f1',
            transition: 'color 0.13s',
          }}>‚ñ∂</span>
          Generate Diagram
        </button>
      </div>
    );
  }

  if (loading)
    return (
      <div className="flex items-center justify-center h-full w-full">
        <svg
          className="animate-spin h-8 w-8 text-blue-500"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
          />
        </svg>
        <span className="ml-3 text-sm text-slate-500">diagram loading‚Ä¶</span>
      </div>
    );
  if (error)
    return (
      <div className="p-4 text-sm text-red-600 whitespace-pre-wrap">{error}</div>
    );

  return (
    <div className="relative h-full w-full border-l border-slate-300">
      <ReactFlow
        nodes={finalNodes}
        edges={finalEdges}
        onNodesChange={onNodesChange}
        onNodeClick={onNodeClick}
        onNodeMouseEnter={onEnter}
        onNodeMouseLeave={onLeave}
        onEdgeMouseEnter={onEdgeMouseEnter}
        onEdgeMouseLeave={onEdgeMouseLeave}
        fitView
        minZoom={0.2}
        maxZoom={2}
        className="bg-gray-50"
        nodeTypes={{ group: CustomGroupNode }}
        onPaneClick={() => {
          setSelectedNodeId(null);
          setCfgMessage(null);
        }}
      >
        <Background variant="dots" gap={16} size={1} />
        <MiniMap
          pannable
          zoomable
          nodeColor={n =>
            n.type === 'group'
              ? collapsedGroups.has(n.id) ? '#6b7280' : '#bdbdbd'
              : n.style?.background === '#fef9c3'
                ? '#facc15'
                : n.style?.background === '#dbeafe'
                  ? '#0284c7'
                  : '#2563eb'
          }
          nodeStrokeColor={n =>
            n.type === 'group'
              ? collapsedGroups.has(n.id) ? '#374151' : '#757575'
              : n.style?.border?.includes('#eab308')
                ? '#eab308'
                : n.style?.border?.includes('#0284c7')
                  ? '#0284c7'
                  : '#1e40af'
          }
          nodeStrokeWidth={2}
          maskColor="rgba(255,255,255,0.7)"
          style={{
            background: '#f3f4f6',
            border: '1.5px solid #cbd5e1',
            borderRadius: 6,
            boxShadow: '0 2px 8px #0002',
          }}
        />
        <Controls>
          <button
            type="button"
            title="Re-layout"
            onClick={reLayout}
            style={{
              width: 20,
              height: 20,
              background: '#fff',
              padding: 0,
              margin: 4,
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 1px 2px #0001',
              transition: 'border 0.15s',
            }}
          >
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <rect x="2" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="2" y="10" width="4" height="4" rx="1" fill="#222" />
              <rect x="6" y="6" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="10" width="4" height="4" rx="1" fill="#222" />
            </svg>
          </button>
          <button
            type="button"
            title="Generate Control Flow Graph"
            onClick={handleGenerateCFG}
            disabled={cfgLoading}
            style={{
              width: 20,
              height: 20,
              background: '#fff',
              padding: 0,
              margin: 4,
              cursor: cfgLoading ? 'not-allowed' : 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 1px 2px #0001',
              transition: 'border 0.15s',
              position: 'relative',
            }}
          >
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style={{ opacity: cfgLoading ? 0.3 : 1 }}>
              <circle cx="6" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="14" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="10" cy="14" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <line x1="7.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="12.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="8.2" y1="6" x2="11.8" y2="6" stroke="#222" strokeWidth="1.2" />
              <g>
                <circle cx="16.5" cy="16.5" r="3.2" fill="#222" />
                <rect x="16" y="14.2" width="1" height="4.6" rx="0.5" fill="#fff" />
                <rect x="14.2" y="16" width="4.6" height="1" rx="0.5" fill="#fff" />
              </g>
            </svg>
            {cfgLoading && (
              <span
                style={{
                  position: 'absolute',
                  left: 0, top: 0, width: '100%', height: '100%',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  background: 'rgba(255,255,255,0.7)',
                  borderRadius: 4,
                }}
              >
                <svg className="animate-spin" width="16" height="16" viewBox="0 0 16 16">
                  <circle
                    cx="8" cy="8" r="6"
                    stroke="#0284c7"
                    strokeWidth="2"
                    fill="none"
                    strokeDasharray="28"
                    strokeDashoffset="10"
                  />
                </svg>
              </span>
            )}
          </button>
        </Controls>
      </ReactFlow>
      {cfgMessage && (
        <div
          style={{
            position: 'absolute',
            top: 60,
            right: 24,
            background: '#fee2e2',
            color: '#b91c1c',
            padding: '8px 16px',
            borderRadius: 6,
            zIndex: 100,
            fontSize: 14,
            boxShadow: '0 2px 8px #0002',
          }}
        >
          {cfgMessage}
        </div>
      )}
      {cfgPanels.map((panel, idx) => (
        <CFGPanelComponent
          key={panel.id}
          panel={panel}
          index={idx}
          onUpdate={handleCFGPanelUpdate}
          onClose={handleCFGPanelClose}
          onNodeHover={handleCFGNodeHover}
          message={cfgPanelMessage}
        />
      ))}
      {hoverId && snippet && (
        <div
          className="fixed z-50"
          style={{
            top: 16,
            right: 16,
            minWidth: 320,
            maxWidth: '40vw',
            width: 'auto',
            minHeight: 40,
            maxHeight: '80vh',
            background: '#fafafa',
            color: '#1e293b',
            fontSize: 12,
            borderRadius: 8,
            boxShadow: '0 4px 16px #0004',
            padding: 16,
            overflow: 'auto',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all',
            fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
          }}
          dangerouslySetInnerHTML={{ __html: `<pre class="hljs">${snippet}</pre>` }}
        />
      )}
    </div>
  );
}

// CFG Panel Component
function CFGPanelComponent({
  panel,
  index,
  onUpdate,
  onClose,
  onNodeHover,
  message,
}: {
  panel: CFGPanel;
  index: number;
  onUpdate: (id: string, updates: Partial<CFGPanel>) => void;
  onClose: (id: string) => void;
  onNodeHover: (node: Node | null, panel: CFGPanel) => void;
  message?: string | null;
}) {
  const [isDragging, setIsDragging] = useState(false);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (
      (e.target as HTMLElement).closest('button') ||
      (e.target as HTMLElement).tagName === 'BUTTON'
    ) {
      return;
    }

    const startX = e.clientX;
    const startY = e.clientY;
    const origX = panel.pos.x;
    const origY = panel.pos.y;
    
    setIsDragging(true);
    onUpdate(panel.id, { dragging: true });

    const onMouseMove = (moveEvent: MouseEvent) => {
      const dx = moveEvent.clientX - startX;
      const dy = moveEvent.clientY - startY;
      
      const newX = origX - dx;
      const newY = origY + dy;
      
      const panelWidth = panel.width ?? 400;
      const panelHeight = panel.expanded ? (panel.height ?? 320) : 44;
      
      const minX = 20;
      const maxX = window.innerWidth - panelWidth - 20;
      const minY = 20;
      const maxY = window.innerHeight - panelHeight - 20;
      
      const boundedX = Math.max(minX, Math.min(newX, maxX));
      const boundedY = Math.max(minY, Math.min(newY, maxY));
      
      onUpdate(panel.id, {
        pos: { x: boundedX, y: boundedY }
      });
    };

    const onMouseUp = () => {
      setIsDragging(false);
      onUpdate(panel.id, { dragging: false });
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    e.preventDefault();
  }, [panel, onUpdate]);

  const handleResize = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = panel.width ?? 400;
    const startHeight = panel.height ?? 320;

    onUpdate(panel.id, { resizing: true });

    const onMouseMove = (moveEvent: MouseEvent) => {
      const dx = moveEvent.clientX - startX;
      const dy = moveEvent.clientY - startY;
      
      const newWidth = Math.max(300, Math.min(1600, startWidth + dx));
      const newHeight = Math.max(200, Math.min(1200, startHeight + dy));
      
      onUpdate(panel.id, {
        width: newWidth,
        height: newHeight
      });
    };

    const onMouseUp = () => {
      onUpdate(panel.id, { resizing: false });
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  }, [panel, onUpdate]);

  return (
    <div
      style={{
        position: 'fixed',
        top: panel.pos.y,
        right: panel.pos.x,
        background: '#f1f5f9',
        color: '#222',
        padding: panel.expanded ? '12px 18px 18px 18px' : '8px 18px 8px 18px',
        borderRadius: 8,
        zIndex: 200 + index,
        fontSize: 13,
        minWidth: 220,
        maxWidth: 1600,
        minHeight: panel.expanded ? 0 : 0,
        maxHeight: panel.expanded ? 1200 : 44,
        boxShadow: '0 2px 8px #0002',
        whiteSpace: 'pre-wrap',
        overflow: panel.expanded ? 'auto' : 'hidden',
        transition: 'all 0.2s cubic-bezier(.4,2,.6,1)',
        display: 'flex',
        flexDirection: 'column',
        cursor: isDragging ? 'move' : 'default',
        userSelect: isDragging ? 'none' : 'auto',
        pointerEvents: isDragging ? 'none' : 'auto',
        width: panel.width ?? 400,
        height: panel.expanded ? (panel.height ?? 320) : undefined,
        resize: 'none',
      }}
    >
      {message && (
        <div
          style={{
            position: 'absolute',
            top: 8,
            right: 12,
            background: 'transparent',
            padding: 0,
            borderRadius: 5,
            zIndex: 300,
            fontSize: 13,
            fontWeight: 500,
            boxShadow: 'none',
            pointerEvents: 'none',
            maxWidth: 340,
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            whiteSpace: 'normal',
          }}
          dangerouslySetInnerHTML={{ __html: message }}
        />
      )}
      
      <div
        style={{
          width: '100%',
          minHeight: 28,
          display: 'flex',
          alignItems: 'center',
          fontWeight: 600,
          fontSize: 13,
          color: '#555',
          userSelect: 'none',
          marginBottom: panel.expanded ? 8 : 0,
          gap: 4,
          cursor: 'move',
        }}
        onMouseDown={handleMouseDown}
      >
        <span style={{ flex: 1 }}>
          CFG ({panel.functionName}
          {panel.file && (
            <> @ {panel.file.split(/[\\/]/).pop()}</>
          )}
          )
        </span>
        <button
          onClick={e => {
            e.stopPropagation();
            onUpdate(panel.id, { expanded: !panel.expanded });
          }}
          style={{
            background: 'transparent',
            border: 'none',
            fontSize: 16,
            color: '#888',
            cursor: 'pointer',
            padding: 0,
            marginRight: 4,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            transition: 'transform 0.15s',
            transform: panel.expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
          }}
          aria-label={panel.expanded ? 'Collapse' : 'Expand'}
          title={panel.expanded ? 'Collapse' : 'Expand'}
        >
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M4 6l4 4 4-4" stroke="#888" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>
        <button
          onClick={e => {
            e.stopPropagation();
            onClose(panel.id);
          }}
          style={{
            background: 'transparent',
            border: 'none',
            fontSize: 16,
            color: '#888',
            cursor: 'pointer',
            padding: 0,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
          aria-label="Close"
          title="Close"
        >
          √ó
        </button>
      </div>
      
      {panel.expanded && (
        <div style={{ width: '100%', height: panel.height ?? 320, overflow: 'auto', position: 'relative' }}>
          {panel.result && panel.result.nodes && panel.result.edges ? (
            <div style={{ width: '100%', height: '100%', background: '#f8fafc', borderRadius: 6 }}>
              <ReactFlow
                nodes={panel.result.nodes}
                edges={panel.result.edges}
                fitView
                minZoom={0.2}
                maxZoom={2}
                className="bg-gray-50"
                style={{ width: '100%', height: '100%' }}
                defaultViewport={{ x: 0, y: 0, zoom: 1.2 }}
                onNodeMouseEnter={(_, node) => onNodeHover(node, panel)}
                onNodeMouseLeave={() => onNodeHover(null, panel)}
              >
                <Background variant="dots" gap={16} size={1} />
                <Controls showInteractive={false} />
              </ReactFlow>
            </div>
          ) : (
            <pre style={{
              margin: 0,
              fontSize: 13,
              background: 'none',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              maxWidth: 560,
              maxHeight: 520,
              padding: 0,
            }}>
              {typeof panel.result === 'string' ? panel.result : JSON.stringify(panel.result, null, 2)}
            </pre>
          )}
          
          <div
            style={{
              position: 'absolute',
              right: 2,
              bottom: 2,
              width: 18,
              height: 18,
              cursor: 'nwse-resize',
              zIndex: 10,
              background: 'transparent',
              userSelect: 'none',
            }}
            onMouseDown={handleResize}
          >
            <svg width="18" height="18" style={{ pointerEvents: 'none' }}>
              <polyline points="4,18 18,4" stroke="#888" strokeWidth="2" fill="none" />
              <rect x="12" y="12" width="5" height="5" fill="#e5e7eb" stroke="#888" strokeWidth="1" />
            </svg>
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * ÌååÏùº Ìä∏Î¶¨ÏóêÏÑú Í≤ΩÎ°úÎ°ú ÎÖ∏Îìú Ï∞æÍ∏∞
 * @param nodes ÌååÏùº ÎÖ∏Îìú Î∞∞Ïó¥
 * @param p Ï∞æÏùÑ Í≤ΩÎ°ú
 * @returns Ï∞æÏùÄ ÌååÏùº ÎÖ∏Îìú
 */
function findByPath(nodes: FileNode[] = [], p: string): FileNode | undefined {
  const regex = new RegExp(`^${process.env.NEXT_PUBLIC_TARGET_FOLDER}[\\\\/]`);
  for (const n of nodes) {
    if (n.path?.replace(regex, '') === p) return n;
    if (n.children) {
      const r = findByPath(n.children, p);
      if (r) return r;
    }
  }
}



[src/app/page.tsx]
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { useFS } from '@/store/files';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';

import IconBar from '@/components/IconBar';
import FileExplorer from '@/components/FileExplorer';
import SearchPanel from '@/components/SearchPanel';

const EditorTabs = dynamic(() => import('@/components/EditorTabs'), { ssr: false });
const DiagramViewer = dynamic(() => import('@/components/DiagramViewer'), { ssr: false });
const ChatUI = dynamic(() => import('@/components/ChatUI'), { ssr: false });

const HHandle = () => (
  <PanelResizeHandle className="w-[4px] bg-slate-300 hover:bg-sky-600 cursor-col-resize transition-colors" />
);
const VHandle = () => (
  <PanelResizeHandle className="h-[4px] bg-slate-300 hover:bg-sky-600 cursor-row-resize transition-colors" />
);

export default function Home() {
  const { current } = useFS();
  const [showSidebar, setShowSidebar] = useState(true);
  const [sidebarContent, setSidebarContent] = useState<'explorer' | 'search'>('explorer');
  const [showDia, setDia] = useState(true);
  const [showChat, setChat] = useState(true);

  useEffect(() => {
    setSidebarContent('explorer');
    setShowSidebar(true);
  }, []);

  const toggleExplorer = () => {
    if (sidebarContent === 'explorer' && showSidebar) {
      setShowSidebar(false);
    } else {
      setSidebarContent('explorer');
      setShowSidebar(true);
    }
  };

  const toggleSearch = () => {
    if (sidebarContent === 'search' && showSidebar) {
      setShowSidebar(false);
    } else {
      setSidebarContent('search');
      setShowSidebar(true);
    }
  };

  const toggleDia = () => setDia(!showDia);
  const toggleChat = () => setChat(!showChat);

  return (
    <div className="flex h-full">
      <IconBar
        states={{
          explorer: sidebarContent === 'explorer' && showSidebar,
          search: !(sidebarContent === 'search' && showSidebar),
          diagram: showDia,
          chat: showChat,
        }}
        toggle={{
          explorer: toggleExplorer,
          search: toggleSearch,
          diagram: toggleDia,
          chat: toggleChat,
        }}
      />
      <PanelGroup direction="horizontal" className="flex-1">
        {showSidebar && (
          <>
            <Panel defaultSize={15} minSize={12}>
              {sidebarContent === 'explorer' ? <FileExplorer /> : <SearchPanel />}
            </Panel>
            <HHandle />
          </>
        )}
        <Panel defaultSize={55} minSize={30} className="border-x border-slate-300">
          <EditorTabs />
        </Panel>
        {(showDia || showChat) && <HHandle />}
        {(showDia || showChat) && (
          <Panel defaultSize={30} minSize={18} className="flex-1 min-w-0">
            <PanelGroup direction="vertical">
              {showDia && (
                <>
                  <Panel defaultSize={70} minSize={30}>
                    <DiagramViewer />
                  </Panel>
                  {showChat && <VHandle />}
                </>
              )}
              {showChat && (
                <Panel defaultSize={30} minSize={20}>
                  <ChatUI />
                </Panel>
              )}
            </PanelGroup>
          </Panel>
        )}
      </PanelGroup>
    </div>
  );
}

[src/app/globals.css]
/* src/app/globals.css */
@import 'tailwindcss';

/* ‚îÄ‚îÄ‚îÄ ÎùºÏù¥Ìä∏ ÌåîÎ†àÌä∏ ‚îÄ‚îÄ‚îÄ */
:root{
  --background: #ffffff;
  --foreground: #171717;
  --panel:      #f3f3f3;
  --border:     #e5e5e5;
  --side:       #eeeeee;
  --accent:     #0078d4;
}

/* ‚îÄ‚îÄ‚îÄ Îã§ÌÅ¨ ÌåîÎ†àÌä∏ ‚îÄ‚îÄ‚îÄ */
@media (prefers-color-scheme:dark){
  :root{
    --background: #1e1e1e;
    --foreground: #ededed;
    --panel:      #252526;
    --border:     #3c3c3c;
    --side:       #333337;
    --accent:     #569cd6;
  }
}

/* Í∏∞Î≥∏ Î†àÏù¥ÏïÑÏõÉ */
html, body {
  height: 100%;
}
body {
  background: var(--background);
  color: var(--foreground);
  font-family: system-ui, Arial, Helvetica, sans-serif;
  font-size: 14px;
  margin: 0;
  padding: 0;
  overscroll-behavior: none;
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background-color: var(--border);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background-color: var(--accent);
}

/* ÏÑ†ÌÉù Ìñâ ÌïòÏù¥ÎùºÏù¥Ìä∏ */
.vscode-tree-active{
  background: var(--side);
  color: var(--accent);
}

/* Transition classes for smoother toggles, hovers, etc. */
.transition-colors {
  transition: color 0.15s ease, background-color 0.15s ease;
}

.highlight-line {
  background-color: rgba(255, 255, 0, 0.2);
}
.highlight-text {
  background-color: rgba(255, 255, 0, 0.5);
}

/* ÎìúÎûòÍ∑∏ Ï§ë ÎÖ∏ÎìúÏùò zIndex Ï†úÌïú */
.react-flow__node.dragging {
  z-index: 10 !important; /* Ïó£ÏßÄÏùò zIndex(10000)Î≥¥Îã§ ÎÇÆÍ≤å ÏÑ§Ï†ï */
}

[src/store/editor.ts]
"use client";

import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { useFS } from "@/store/files";

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export interface TabMeta {
  id: string;
  path: string;
  name: string;
}

interface State {
  tabs: TabMeta[];
  activeId?: string;
  activePath?: string;
  searchHighlights?: { line: number; query: string };
  highlight?: { from: number; to: number }; // Ï∂îÍ∞Ä: highlight Î≤îÏúÑ
  open: (file: TabMeta & { line?: number; highlight?: { from: number; to: number } }) => void;
  close: (id: string) => void;
  setActive: (id: string, highlight?: { from: number; to: number }) => void; // highlight Ïù∏Ïûê Ï∂îÍ∞Ä
  setSearchHighlights: (line: number, query: string) => void;
}

export const useEditor = create<State>()(
  immer((set) => ({
    tabs: [],
    activeId: undefined,
    activePath: undefined,
    searchHighlights: undefined,
    highlight: undefined,
    open: (file) =>
      set((s) => {
        if (!s.tabs.find((t) => t.path === file.path)) s.tabs.push(file);
        s.activeId = s.tabs.find((t) => t.path === file.path)?.id ?? file.id;
        s.activePath = file.path;
        s.searchHighlights = undefined;
        if (file.highlight) {
          s.highlight = file.highlight;
        } else {
          s.highlight = undefined;
        }
      }),
    close: (id) =>
      set((s) => {
        s.tabs = s.tabs.filter((t) => t.id !== id);
        if (s.activeId === id) {
          const lastTab = s.tabs.at(-1);
          s.activeId = lastTab?.id;
          s.activePath = lastTab?.path;
        }
        s.searchHighlights = undefined;
        s.highlight = undefined;
      }),
    setActive: (id, highlight) =>
      set((s) => {
        s.activeId = id;
        s.activePath = s.tabs.find((t) => t.id === id)?.path;
        if (s.activePath) {
          const node = findByPath(useFS.getState().tree, s.activePath);
          if (node) useFS.getState().setCurrent(node.id);
        }
        s.searchHighlights = undefined;
        if (highlight) {
          s.highlight = highlight;
        } else {
          s.highlight = undefined;
        }
      }),
    setSearchHighlights: (line, query) =>
      set((s) => {
        s.searchHighlights = { line, query };
      }),
  }))
);

function findByPath(nodes: FileNode[], path: string): FileNode | undefined {
  const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

  for (const n of nodes) {
    if (n.path?.replace(regex, "") === path) return n;

    if (n.children) {
      const r = findByPath(n.children, path);
      if (r) return r;
    }
  }
}


[src/store/files.ts]
import { create } from "zustand";

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export type FileNode = {
  id: string;
  name: string;
  path: string;
  children?: FileNode[];
};

interface FSState {
  tree: FileNode[];
  current?: FileNode;
  fileContents: Record<string, string>;
  setCurrent: (id: string) => void;
  load: (t: FileNode[]) => void;
  loadContents: () => Promise<void>;
}

export const useFS = create<FSState>((set, get) => ({
  tree: [],
  current: undefined,
  fileContents: {},
  setCurrent: (id) => set((state) => ({ current: find(state.tree, id) })),
  load: (tree) => set({ tree }),
  loadContents: async () => {
    const paths = getAllFilePaths(get().tree, false); // ÌååÏùºÎßå Í∞ÄÏ†∏Ïò§Í∏∞
    for (const path of paths) {
      try {
        const response = await fetch(
          `/api/file?path=${encodeURIComponent(path)}`
        );
        if (response.ok) {
          const content = await response.text();
          set((state) => ({
            fileContents: { ...state.fileContents, [path]: content },
          }));
        } else {
          console.error(
            `Failed to fetch content for ${path}: ${response.status}`
          );
        }
      } catch (err) {
        console.error(`Error loading content for ${path}:`, err);
      }
    }
  },
}));

function find(nodes: FileNode[], id: string): FileNode | undefined {
  for (const n of nodes) {
    if (n.id === id) return n;
    if (n.children) {
      const r = find(n.children, id);
      if (r) return r;
    }
  }
}

export function getAllFilePaths(
  tree: FileNode[],
  includeFolders = false
): string[] {
  const paths: string[] = [];
  const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

  const traverse = (nodes: FileNode[]) => {
    for (const node of nodes) {
      if (!node.children || includeFolders) {
        const cleanPath = node.path.replace(regex, "");

        paths.push(cleanPath);
      }
      if (node.children) traverse(node.children);
    }
  };
  traverse(tree);
  return paths;
}


[backend/app/main.py]
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
from pathlib import Path
from schemas.common import *
from llm.diagram_generator import generate_call_graph, generate_control_flow_graph
from llm.chatbot import create_session, remove_session, generate_chatbot_answer_with_session, get_session_history
from llm.utils import get_source_file_with_line_number
from llm.inline_explanation import generate_inline_code_explanation
from fastapi.responses import JSONResponse
from llm.constants import SAMPLE_CFG_JSON

import json

# .env file loading
load_dotenv()

# FastAPI app initialization
app = FastAPI(title="Code-Diagram API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ÌîÑÎ°†Ìä∏ÏóîÎìú ÎèÑÎ©îÏù∏ÏúºÎ°ú Ï†úÌïú Í∞ÄÎä•
    allow_credentials=True,
    allow_methods=["*"],  # Î™®Îì† HTTP Î©îÏÑúÎìú ÌóàÏö©
    allow_headers=["*"],  # Î™®Îì† Ìó§Îçî ÌóàÏö©
)

# Define the path to the HTML template
HTML_PATH = Path(__file__).parent / "html" / "root.html"

# API Endpoint
@app.get("/", response_class=HTMLResponse)
async def root():
    try:
        # Read the HTML content from the file
        html_content = HTML_PATH.read_text(encoding="utf-8")
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(content="<h1>Template not found</h1>", status_code=404)

@app.post("/api/generate_call_graph", response_model=CGDiagramResponse)
async def api_generate_call_graph(request: CGDiagramRequest):
    """
    Generate a call graph for the given code.
    """
    try:

        json_data = await generate_call_graph(request.path, request.file_type)
        result = {
            "data": json_data
        }
        print(f'result in main.py: \\{result}')
        return CGDiagramResponse(**result)
    except Exception as e:
        return CGDiagramResponse(status=500, data=str(e))

@app.post("/api/generate_control_flow_graph", response_model=CFGDiagramResponse)
async def api_generate_control_flow_graph(request: CFGDiagramRequest):
    """
    Generate a control flow graph for the given code.
    """
    try:
        json_data = await generate_control_flow_graph(request.file_path, request.function_name)
        result = {
            "data": json_data
        }
        print(f'result in main.py: \\{result}')
        return CFGDiagramResponse(**result)
    except Exception as e:
        return CFGDiagramResponse(status=500, data=str(e))

@app.get("/api/chatbot/session/open")
async def api_open_session():
    try:
        session_id = create_session()
        return SessionResponse(session_id=session_id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chatbot/session/close")
async def api_close_session(req: SessionRequest):
    try:
        if not req.session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        remove_session(req.session_id)
        return {"status": "closed"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chatbot/session/chat", response_model=ChatbotQueryResponse)
async def api_session_chat(req: ChatbotQueryRequest):
    try:
        if not req.session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        if not req.query:
            raise HTTPException(status_code=400, detail="Query is required")
        
        # Handle Context Files
        context = ""
        if hasattr(req, 'context_files') and req.context_files:
            context += "Below is the context from the provided files:\n"
            for file_path in req.context_files:
                context += get_source_file_with_line_number(file_path)
            context += "Please answer the question based on the above context.\n"


        print(f"Session ID: {req.session_id}")
        print(f"Query: {req.query}")
        print(f"Code: {req.code}")
        print(f"Diagram: {req.diagram}")
        print(f"Context Files: {req.context_files}")
        print(f"Context: {context}")
        answer, highlight = await generate_chatbot_answer_with_session(
            req.session_id, req.query + context, req.code, req.diagram
        )
        print(f"Answer: {answer}")
        print(f"Highlight: {highlight}")
        return ChatbotQueryResponse(answer=answer, highlight=highlight)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
@app.get("/api/chatbot/session/get_history")
async def api_get_session_history(session_id: str):
    try:
        if not session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        history = get_session_history(session_id)
        return {"session_id": session_id, "history": history}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
@app.post("/api/inline_code_explanation")
async def api_inline_code_explanation(req: InlineCodeExplanationRequest):
    """
    Generate an inline explanation for the given code.
    """
    try:
        print(f"Inline Code: {req.file_path}, {req.line_start}, {req.line_end}, {req.context}")
        if not req.file_path:
            raise HTTPException(status_code=400, detail="File path is required")
        if not req.line_start or not req.line_end:
            raise HTTPException(status_code=400, detail="Line start and end are required")
        explanation = await generate_inline_code_explanation(req.file_path, req.line_start, req.line_end, req.context)
        print(f"Explanation: {explanation}")
        return {"explanation": explanation}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

[src/app/api/files/route.ts]
/** Next 15 Ïù¥ÏÉÅ: Edge ‚Üí Node Îü∞ÌÉÄÏûÑÏúºÎ°ú Ï†ÑÌôò (fs ÏÇ¨Ïö©) */
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';     // dev ¬∑ hot-reload Ìé∏ÌïòÍ≤å

import fs from 'node:fs';
import path from 'node:path';
import { NextResponse } from 'next/server';

type FileNode = { id: string; name: string; path: string; children?: FileNode[] };

// ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÌÉÄÍ≤ü Ìè¥Îçî ÏùΩÍ∏∞
const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER!;
const TARGET_DIR = path.join(process.cwd(), '..', TARGET_FOLDER);

/* ‚îÄ‚îÄ Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú ÌååÏùº/Ìè¥Îçî ÌÉêÏÉâÌï¥ FileNode Ìä∏Î¶¨ ÏÉùÏÑ± ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function walk(dir: string): FileNode[] {
  return fs.readdirSync(dir).map((name): FileNode => {
    const full = path.join(dir, name);                   
    const rel  = path.relative(path.join(process.cwd(), '..'), full); // Ï†ÑÏ≤¥ ÏÉÅÎåÄÍ≤ΩÎ°ú
    const id   = rel.replace(/[^\w]/g, '_');             // Í≥†Ïú† ID

    if (fs.statSync(full).isDirectory()) {
      return { id, name, path: rel, children: walk(full) };
    }
    return { id, name, path: rel };
  });
}

/* ‚îÄ‚îÄ GET /api/files ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
export async function GET() {
  try {
    const tree: FileNode = {
      id: TARGET_FOLDER.replace(/[^\w]/g, '_'),
      name: TARGET_FOLDER,
      path: TARGET_FOLDER,               
      children: walk(TARGET_DIR),
    };
    return NextResponse.json([tree]);  // Î∞∞Ïó¥Î°ú Í∞êÏã∏ÏÑú FileExplorerÏóê Í∑∏ÎåÄÎ°ú Ï†ÑÎã¨
  } catch (error) {
    console.error('Error reading directory:', error);
    return NextResponse.json({ error: 'Directory not found' }, { status: 404 });
  }
}

[src/app/api/file/route.ts]
// frontend/src/app/api/file/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import { promises as fs } from 'node:fs';
import path from 'node:path';

// ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÌÉÄÍ≤ü Ìè¥Îçî ÏùΩÍ∏∞
const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER!;
const TARGET_DIR = path.join(process.cwd(), '..', TARGET_FOLDER);

export async function GET(req: Request) {
  const raw = new URL(req.url).searchParams.get('path') ?? '';

  /* ‚îÄ‚îÄ Í≤ΩÎ°ú Ï†ïÍ∑úÌôî & Î≥¥Ïïà ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const parts = raw.split(/[\\/]/).filter(p => p && p !== '..');
  
  // TARGET_FOLDER Ï†ëÎëêÏÇ¨ Ï†úÍ±∞ (Ïòà: "study1/face_classification/main.py" ‚Üí "main.py")
  const targetParts = TARGET_FOLDER.split(/[\\/]/);
  for (let i = 0; i < targetParts.length && i < parts.length; i++) {
    if (parts[0] === targetParts[i]) {
      parts.shift();
    }
  }

  const rel = parts.join('/');             // ex) "main.py", "utils/helper.py"
  const abs = path.join(TARGET_DIR, rel);  // <root>/study1/face_classification/main.py

  try {
    // Î≥¥Ïïà Ï≤¥ÌÅ¨: TARGET_DIR Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎäî Í≤É Î∞©ÏßÄ
    const resolvedPath = path.resolve(abs);
    const resolvedTargetDir = path.resolve(TARGET_DIR);
    
    if (!resolvedPath.startsWith(resolvedTargetDir)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    const text = await fs.readFile(abs, 'utf8');
    /* Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ ÏùëÎãµ */
    return new NextResponse(text);
  } catch (error) {
    console.error('Error reading file:', error);
    /* ÌååÏùº Î™ª Ï∞æÏúºÎ©¥ 404 JSON */
    return NextResponse.json({ error: 'File not found' }, { status: 404 });
  }
}

