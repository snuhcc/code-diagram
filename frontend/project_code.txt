[src/components/ChatUI.tsx]
import { useState, useEffect, useRef, FormEvent } from 'react';
import { XMarkIcon, PlusIcon } from '@heroicons/react/24/outline';
import { useFS, getAllFilePaths } from '@/store/files';
import { marked } from 'marked'; // 마크다운 파서 추가

interface Message {
  role: 'user' | 'bot';
  t: string;
}

interface Session {
  id: string;
  log: Message[];
}

const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';

export default function ChatUI() {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [input, setInput] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownItems, setDropdownItems] = useState<string[]>([]);
  const [isBotTyping, setIsBotTyping] = useState(false);
  const { tree } = useFS();
  const allFiles = getAllFilePaths(tree);
  const chatContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    async function init() {
      const newSessionId = await openNewSession();
      if (newSessionId) setCurrentSessionId(newSessionId);
    }
    init();

    return () => {
      sessions.forEach((session) => {
        fetch(`${apiUrl}/api/chatbot/session/close`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: session.id }),
        });
      });
    };
  }, []);

  const openNewSession = async () => {
    try {
      const res = await fetch(`${apiUrl}/api/chatbot/session/open`, { method: 'GET' });
      if (!res.ok) throw new Error(`Failed to open session: ${res.status}`);
      const data = await res.json();
      const newSessionId = data.session_id;
      setSessions((prev) => [...prev, { id: newSessionId, log: [] }]);
      setCurrentSessionId(newSessionId);
      return newSessionId;
    } catch (err) {
      console.error('Failed to open session:', err);
      setError('Failed to open session. Please try again.');
      return null;
    }
  };

  const closeSession = async (sessionId: string) => {
    try {
      await fetch(`${apiUrl}/api/chatbot/session/close`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId }),
      });
      setSessions((prevSessions) => {
        const newSessions = prevSessions.filter((s) => s.id !== sessionId);
        if (currentSessionId === sessionId) {
          setCurrentSessionId(newSessions.length > 0 ? newSessions[0].id : null);
        }
        return newSessions;
      });
    } catch (err) {
      console.error('Failed to close session:', err);
      setError('Failed to close session. Please try again.');
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInput(value);

    const atIndex = value.lastIndexOf('@');
    if (atIndex >= 0) {
      const afterAt = value.slice(atIndex + 1);
      const spaceIndex = afterAt.indexOf(' ');
      const word = spaceIndex >= 0 ? afterAt.slice(0, spaceIndex) : afterAt;
      if (word) {
        const filtered = allFiles.filter((path) =>
          path.toLowerCase().includes(word.toLowerCase())
        );
        setDropdownItems(filtered);
        setShowDropdown(true);
      } else {
        setDropdownItems(allFiles); // Show all files when just "@" is typed
        setShowDropdown(true);
      }
    } else {
      setShowDropdown(false); // Hide dropdown if no "@" present
    }
  };

  const handleSelectItem = (selected: string) => {
    const atIndex = input.lastIndexOf('@');
    if (atIndex >= 0) {
      const beforeAt = input.slice(0, atIndex + 1);
      const afterAt = input.slice(atIndex + 1);
      const spaceIndex = afterAt.indexOf(' ');
      const endIndex = spaceIndex >= 0 ? atIndex + 1 + spaceIndex : input.length;
      const newInput = beforeAt + selected + input.slice(endIndex);
      setInput(newInput); // Update input with selected file
    }
    setShowDropdown(false); // Hide dropdown after selection
  };

  const send = async (e: FormEvent) => {
    e.preventDefault();
    if (!input.trim() || !currentSessionId) return;

    setSessions((prev) =>
      prev.map((s) =>
        s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'user', t: input }] } : s
      )
    );
    setInput('');
    setIsBotTyping(true); // 답변 대기 시작

    try {
      const res = await fetch(`${apiUrl}/api/chatbot/session/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: currentSessionId,
          query: input,
          code: '',
          diagram: '',
          context_files: input.match(/@(\S+)/g)?.map((m) => m.slice(1)) || [],
        }),
      });
      if (!res.ok) throw new Error(`Failed to send message: ${res.status}`);
      const data = await res.json();
      const text = data.answer;
      setSessions((prev) =>
        prev.map((s) =>
          s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'bot', t: text }] } : s
        )
      );
      setIsBotTyping(false); // 답변 도착
    } catch (err) {
      console.error('Failed to send message:', err);
      setSessions((prev) =>
        prev.map((s) =>
          s.id === currentSessionId
            ? { ...s, log: [...s.log, { role: 'bot', t: 'Error: Failed to send message.' }] }
            : s
        )
      );
      setIsBotTyping(false); // 에러 발생 시도 답변 대기 종료
    }
  };

  const currentLog = sessions.find((s) => s.id === currentSessionId)?.log || [];

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [currentLog, currentSessionId]);

  return (
    <div className="flex flex-col h-full">
      <div className="flex items-center space-x-2 bg-slate-200 border-b border-slate-300 p-2 overflow-x-auto">
        {sessions.map((session, index) => (
          <div
            key={session.id}
            onClick={() => setCurrentSessionId(session.id)}
            className={`flex items-center px-3 py-1 cursor-pointer rounded-t-md ${
              session.id === currentSessionId ? 'bg-white border-t border-x border-slate-300' : ''
            }`}
          >
            <span>Session {index + 1}</span>
            <button
              onClick={(e) => {
                e.stopPropagation();
                closeSession(session.id);
              }}
              className="ml-2"
            >
              <XMarkIcon className="w-4 h-4" />
            </button>
          </div>
        ))}
        <button onClick={openNewSession} className="px-2 py-1">
          <PlusIcon className="w-5 h-5" />
        </button>
      </div>

      <div
        ref={chatContainerRef}
        className="flex-1 p-4 overflow-y-auto"
      >
        {sessions.length === 0 ? (
          <p className="text-center text-gray-500">
            No active sessions. Click '+' to start a new session.
          </p>
        ) : (
          currentLog.map((msg, i) => (
            <div key={i} className={`mb-2 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}>
              <span
                className={`inline-block p-2 rounded ${
                  msg.role === 'user' ? 'bg-blue-100' : 'bg-gray-100'
                }`}
                // 마크다운 렌더링
                dangerouslySetInnerHTML={{ __html: marked.parse(msg.t) }}
              />
            </div>
          ))
        )}
        {isBotTyping && (
          <div className="mb-2 text-left">
            <span className="inline-block p-2 rounded bg-gray-100 text-gray-500 animate-pulse">
              <TypingIndicator />
            </span>
          </div>
        )}
        {error && <p className="text-red-500">{error}</p>}
      </div>

      {currentSessionId && (
        <div className="relative p-4 border-t border-slate-300">
          <form onSubmit={send}>
            <input
              type="text"
              value={input}
              onChange={handleInputChange}
              className="w-full p-2 border rounded"
              placeholder="Type your message..."
            />
            <button type="submit" className="hidden">
              Send
            </button>
          </form>
          {showDropdown && (
            <div
              className="absolute z-10 bg-white border border-slate-300 rounded shadow-md max-h-60 overflow-y-auto"
              style={{ bottom: '100%', left: 0 }}
            >
              {dropdownItems.map((item, i) => (
                <div
                  key={i}
                  onClick={() => handleSelectItem(item)}
                  className="px-3 py-1 hover:bg-slate-100 cursor-pointer"
                >
                  {item}
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// 채팅 타이핑 인디케이터 컴포넌트
function TypingIndicator() {
  return (
    <span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0s' }}></span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0.2s' }}></span>
      <span className="inline-block w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></span>
    </span>
  );
}

[src/components/CodeViewer.tsx]
'use client';

import { useEffect, useState } from 'react';
import Editor from '@monaco-editor/react';

export default function CodeViewer({ filePath }: { filePath: string }) {
  const [code, setCode] = useState('// loading…');

  /* ① 실제 파일 내용 가져오기 -------------------------------------- */
  useEffect(() => {
    (async () => {
      const c = await fetch(`/api/file?path=${encodeURIComponent(filePath)}`).then((r) =>
        r.text()
      );
      setCode(c);
    })();
  }, [filePath]);

  /* ② 확장자로 언어 결정 ----------------------------------------- */
  const lang = (() => {
    if (filePath.endsWith('.tsx') || filePath.endsWith('.ts')) return 'typescript';
    if (filePath.endsWith('.py')) return 'python';
    if (filePath.endsWith('.md')) return 'markdown';
    return 'plaintext';
  })();

  /* ③ 에디터 + 제목 바 ------------------------------------------- */
  return (
    <div className="h-full bg-slate-100 rounded-md shadow-sm overflow-hidden">
      <div className="h-8 flex items-center px-3 bg-slate-200 border-b border-slate-300 text-xs">
        {filePath.split('/').pop()}
      </div>
      <Editor
        height="calc(100% - 2rem)"
        defaultLanguage={lang}
        value={code}
        theme="vs-dark"
        options={{
          minimap: { enabled: true },
          fontSize: 14,
          automaticLayout: true,
          readOnly: true,
        }}
      />
    </div>
  );
}


[src/components/DiagramViewer.tsx]
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  ReactFlow,
  Background,
  MiniMap,
  Controls,
  MarkerType,
  type Node,
  type Edge,
  type NodeMouseHandler,
  applyNodeChanges,
  NodeChange,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import dagre from 'dagre';
import { nanoid } from 'nanoid';
import { useEditor } from '@/store/editor';
import { useFS, type FileNode } from '@/store/files';
import { NodeProps } from '@xyflow/react';
import hljs from 'highlight.js/lib/core';
import python from 'highlight.js/lib/languages/python';
import 'highlight.js/styles/atom-one-light.css'; // 원하는 스타일로 변경 가능

hljs.registerLanguage('python', python);

// Global cache for diagram data and snippets
let diagramCache: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> | null = null;
const snippetCache = new Map<string, string>(); // <cleanPath_functionName, preview>

// Dagre layout utility
function layout(nodes: Node[] = [], edges: Edge[] = []): Node[] {
  const g = new dagre.graphlib.Graph().setGraph({
    rankdir: 'TB',
    nodesep: 40, // 기존 100 → 40 (수평 간격 감소)
    ranksep: 40, // 기존 100 → 40 (수직 간격 감소)
  });
  g.setDefaultEdgeLabel(() => ({}));

  nodes.forEach((n) => g.setNode(n.id, { width: 160, height: 40 }));
  edges.forEach((e) => g.setEdge(e.source, e.target));
  dagre.layout(g);

  return nodes.map((n) => {
    const { x, y } = g.node(n.id);
    return { ...n, position: { x, y } };
  });
}

function layoutWithCluster(
  files: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>
): Record<string, { x: number; y: number }> {
  const g = new dagre.graphlib.Graph({ compound: true, multigraph: true })
    .setGraph({ rankdir: 'TB', nodesep: 40, ranksep: 56 })  // 기존 100, 140 → 40, 56
    .setDefaultEdgeLabel(() => ({}));

  /* 1️⃣ 파일을 클러스터로 */
  Object.keys(files).forEach((file) => {
    g.setNode(`cluster_${file}`, {});  // 크기는 Dagre가 계산
  });

  /* 2️⃣ 함수 노드 + 부모 설정 */
  Object.entries(files).forEach(([file, { nodes }]) => {
    nodes.forEach((n) => {
      g.setNode(n.id, { width: 160, height: 40 });
      g.setParent(n.id, `cluster_${file}`);
    });
  });

  /* 3️⃣ 엣지 추가 */
  Object.values(files).forEach(({ edges }) => {
    edges.forEach(({ source, target }) => g.setEdge(source, target));
  });

  dagre.layout(g);

  /* 4️⃣ 좌표 맵 추출 */
  const pos: Record<string, { x: number; y: number }> = {};
  g.nodes().forEach((id: string) => {
    const n = g.node(id);
    if (n?.x != null && n?.y != null) pos[id] = { x: n.x, y: n.y };
  });
  return pos;
}


// Common types
interface RawNode {
  id: string;
  label?: string;
  function_name?: string;
  file: string;
}
interface RawEdge {
  id: string;
  source: string;
  target: string;
  type?: string;
}

// API endpoint
const ENDPOINT_CG = '/api/generate_call_graph';
const ENDPOINT_CFG = '/api/generate_control_flow_graph';
const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';

// target folder
const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;
console.log(`TARGET_FOLDER: ${TARGET_FOLDER}`);


// Custom group node component
function CustomGroupNode({ data, style }: NodeProps) {
  return (
    <div style={{ position: 'relative', width: style?.width, height: style?.height }}>
      {/* Label above the group box */}
      <div
        style={{
          position: 'absolute',
          top: -32, // 기존 -22에서 -32로 더 위로 올림
          left: 0,
          width: '100%',
          textAlign: 'center',
          fontWeight: 600,
          fontSize: 13,
          color: '#444',
          pointerEvents: 'none',
          userSelect: 'none',
        }}
      >
        {data?.label}
      </div>
      {/* Group box */}
      <div
        style={{
          width: '100%',
          height: '100%',
          background: style?.background,
          border: style?.border,
          borderRadius: style?.borderRadius,
          boxSizing: 'border-box',
        }}
      />
    </div>
  );
}

export default function DiagramViewer() {
  // State
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [loading, setLoad] = useState(true);
  const [error, setErr] = useState<string>();
  const [hoverId, setHoverId] = useState<string | null>(null);
  const [snippet, setSnippet] = useState<string>('');
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null); // ⭐️ 추가
  const [cfgMessage, setCfgMessage] = useState<string | null>(null); // ⭐️ 메시지 상태 추가
  const [cfgPanels, setCfgPanels] = useState<
    { id: string; functionName: string; file: string; result: any; expanded: boolean; pos: { x: number; y: number }; dragging: boolean; dragOffset: { x: number; y: number } }[]
  >([]);
  // ⭐️ CFG 버튼 로딩 상태
  const [cfgLoading, setCfgLoading] = useState(false);
  const [diagramReady, setDiagramReady] = useState(false); // ⭐️ 다이어그램 생성 버튼 상태
  const [hoveredEdgeId, setHoveredEdgeId] = useState<string | null>(null); // ⭐️ edge hover state 추가

  // Zustand stores
  const editorState = useEditor.getState();
  const fsState = useFS.getState();

  // Current active file path
  const activePath =
    editorState.tabs.find((t) => t.id === editorState.activeId)?.path ??
    editorState.tabs.at(-1)?.path ??
    '';

  // Utility to extract function snippet and its starting line number from code
  function extractFunctionSnippetWithLine(code: string, functionName: string): { snippet: string, startLine: number } | null {
    const lines = code.split('\n');
    let startLine = -1;

    // Find the start of the function definition at indentation level 0
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.trim().startsWith(`def ${functionName}(`)) {
        if (line === line.trim()) { // No leading spaces
          startLine = i;
          break;
        }
      }
    }

    if (startLine === -1) {
      return null;
    }

    // Find the end of the function (next line with indentation 0)
    for (let i = startLine + 1; i < lines.length; i++) {
      if (lines[i].trim() === '') {
        continue;
      }
      if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
        return {
          snippet: lines.slice(startLine, i).join('\n'),
          startLine: startLine + 1, // 1-based line number
        };
      }
    }
    return {
      snippet: lines.slice(startLine).join('\n'),
      startLine: startLine + 1,
    };
  }

  // Utility to add line numbers and syntax highlight to code snippet
  function addLineNumbersAndHighlight(snippet: string, start: number = 1): string {
    // highlight.js로 syntax highlight 적용
    const highlighted = hljs.highlight(snippet, { language: 'python' }).value;
    // 줄 단위로 쪼개서 라인넘버 span 추가
    const lines = highlighted.split('\n');
    const pad = String(start + lines.length - 1).length;
    return lines
      .map((line, idx) => {
        const num = String(start + idx).padStart(pad, ' ');
        return `<span style="color:#64748b">${num}</span>  ${line}`;
      })
      .join('\n');
  }

  // Node click handler: open file in editor and highlight in explorer
  const onNodeClick: NodeMouseHandler = (_, node) => {
    // 그룹 노드 클릭 시: 선택 상태 변경하지 않음
    if (node.type === 'group') {
      // 그룹 노드는 선택 상태를 변경하지 않음
      // 파일 경로를 찾기 위해 nodes에서 해당 그룹의 파일 경로를 역추적
      // 그룹 노드 id: group-<file_path_escaped>
      // nodes 중 parentId가 node.id인 첫번째 노드의 file을 사용
      const childNode = nodes.find(n => n.parentId === node.id);
      const filePath = childNode ? (childNode.data as any)?.file : undefined;
      if (!filePath) return;

      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const clean = filePath.replace(regex, '');
      editorState.open({
        id: nanoid(),
        path: clean,
        name: clean.split(/[\\/]/).pop() ?? clean,
        // 첫번째 라인으로 이동 (예시: line: 1)
        line: 1,
      });

      const target = findByPath(fsState.tree, clean);
      if (target) fsState.setCurrent(target.id);
      return;
    }

    // 함수 노드만 선택 상태 토글
    setSelectedNodeId(prev => prev === node.id ? null : node.id);

    // 기존 함수 노드 클릭 동작
    const raw = (node.data as any)?.file as string | undefined;
    if (!raw) return;

    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = raw.replace(regex, '');
    editorState.open({
      id: nanoid(),
      path: clean,
      name: clean.split(/[\\/]/).pop() ?? clean,
    });

    const target = findByPath(fsState.tree, clean);
    if (target) fsState.setCurrent(target.id);
  };

  // Hover handlers
  const onEnter: NodeMouseHandler = async (_, node) => {
    setHoverId(node.id);

    const raw = (node.data as any)?.file as string | undefined;
    const functionName = (node.data as any)?.label as string | undefined;

    if (!raw || !functionName) {
      setSnippet('');
      return;
    }

    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = raw.replace(regex, '');
    const cacheKey = `${clean}_${functionName}`;

    if (snippetCache.has(cacheKey)) {
      try {
        const txt = await fetch(
          `/api/file?path=${encodeURIComponent(clean)}`
        ).then((r) => r.text());
        const result = extractFunctionSnippetWithLine(txt, functionName);
        if (result) {
          setSnippet(addLineNumbersAndHighlight(result.snippet, result.startLine));
        } else {
          setSnippet('(function not found)');
        }
      } catch {
        setSnippet('(preview unavailable)');
      }
      return;
    }

    try {
      const txt = await fetch(
        `/api/file?path=${encodeURIComponent(clean)}`
      ).then((r) => r.text());

      const result = extractFunctionSnippetWithLine(txt, functionName);
      if (result) {
        snippetCache.set(cacheKey, result.snippet);
        setSnippet(addLineNumbersAndHighlight(result.snippet, result.startLine));
      } else {
        setSnippet('(function not found)');
      }
    } catch {
      setSnippet('(preview unavailable)');
    }
  };

  const onLeave: NodeMouseHandler = () => {
    setHoverId(null);
    setSnippet('');
  };

  // Edge hover handlers
  const onEdgeMouseEnter = useCallback((event: React.MouseEvent, edge: Edge) => {
    setHoveredEdgeId(edge.id);
  }, []);
  const onEdgeMouseLeave = useCallback(() => {
    setHoveredEdgeId(null);
  }, []);

  // Handle node changes (dragging, etc.)
  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((nds) => applyNodeChanges(changes, nds));
    },
    [setNodes]
  );

  // Load diagram data and cache it
  useEffect(() => {
    if (!diagramReady) return; // ⭐️ 버튼 누르기 전에는 아무것도 안함
    (async () => {
      if (diagramCache) {
        hydrate(diagramCache);
        setLoad(false);
        return;
      }

      setLoad(true);
      setErr(undefined);

      try {
        const res = await fetch(`${apiUrl}${ENDPOINT_CG}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: `../../${TARGET_FOLDER}`, file_type: 'py' }),
        });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

        const raw = await res.json();
        const json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> =
          typeof raw?.data === 'string' ? JSON.parse(raw.data) : raw.data;

        diagramCache = json;
        hydrate(json);
      } catch (e: any) {
        setErr(String(e));
        setNodes([]);
        setEdges([]);
      } finally {
        setLoad(false);
      }
    })();
  }, [diagramReady]); // ⭐️ diagramReady가 true일 때만 동작

  // Compute node styles
  const finalNodes = nodes.map((n) => {
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
    const clean = ((n.data as any)?.file || '').replace(regex, '');
    const isActive = clean === activePath;
    const isHover = hoverId === n.id;
    const isSelected = selectedNodeId === n.id;
    if (n.type === 'group') {
      return {
        ...n,
        style: {
          ...n.style,
          background: isHover
            ? '#fef9c3'
            : isSelected
              ? '#fca5a5'
              : isActive
                ? '#dbeafe'
                : '#FAFAFA',
          border: isHover
            ? '4px solid #eab308'
            : isActive
              ? '1px solid #fb923c'
              : '1px solid #b9bfc9',
        },
      };
    }
    // 일반 노드
    return {
      ...n,
      style: {
        ...n.style,
        background: isHover
          ? '#fef9c3'
          : isSelected
            ? '#fca5a5'
            : isActive
              ? '#dbeafe'
              : '#ffffff',
        border: isHover
          ? '4px solid #eab308'
          : isSelected
            ? '4px solid #b91c1c'
            : isActive
              ? '1px solid #0284c7'
              : '1px solid #4A90E2',
        transition: 'all 0.1s ease-in-out',
      },
    };
  });

  // ⭐️ Compute edge styles (hover effect)
  const finalEdges = edges.map((e) => {
    const isHover = hoveredEdgeId === e.id;
    return {
      ...e,
      style: {
        ...(e.style || {}),
        stroke: isHover ? '#f59e42' : (e.style?.stroke ?? '#34A853'), // hover시 주황색
        strokeWidth: isHover ? 4 : (e.style?.strokeWidth ?? 2),
        transition: 'all 0.13s',
        cursor: 'pointer',
      },
      markerEnd: {
        ...(e.markerEnd || {}),
        color: isHover ? '#f59e42' : (e.markerEnd?.color ?? '#34A853'), // hover시 주황색
      },
      zIndex: 10000,
    };
  });

  // 레이아웃 재적용 함수
  const reLayout = useCallback(() => {
    if (diagramCache) {
      // 기존에 받아온 JSON 캐시를 다시 hydrate하여 layoutWithCluster 로직 전체 재실행
      hydrate(diagramCache);
    }
  }, []);

  // ⭐️ Control Flow Graph 버튼 핸들러 구현 (복수 패널 지원)
  const handleGenerateCFG = async () => {
    setCfgMessage(null);
    setCfgLoading(true);

    // 선택된 노드 찾기 (group 타입이 아닌 함수 노드만)
    const selectedNode = nodes.find(n => n.id === selectedNodeId && n.type !== 'group');
    if (!selectedNode) {
      setCfgMessage('선택된 노드가 없습니다.');
      setCfgLoading(false);
      return;
    }
    const file = (selectedNode.data as any)?.file;
    const functionName = (selectedNode.data as any)?.label;
    if (!file || !functionName) {
      setCfgMessage('노드 정보가 올바르지 않습니다.');
      setCfgLoading(false);
      return;
    }
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

    try {
      const res = await fetch(`${apiUrl}${ENDPOINT_CFG}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          file_path: file.replace(regex, ''),
          function_name: functionName,
        }),
      });
      const data = await res.json();
      if (data.status && data.status !== 200) {
        setCfgMessage('API 호출 실패: ' + (data.data || ''));
      } else {
        // CFG JSON을 React Flow 노드/엣지로 변환
        const cfgRaw = typeof data.data === 'string' ? JSON.parse(data.data) : data.data;
        // 예시: { nodes: [{id, label}], edges: [{id, source, target}] }
        let cfgNodes = (cfgRaw.nodes || []).map((n: any) => ({
          id: n.id,
          data: { label: n.label || n.id },
          position: { x: n.x ?? 0, y: n.y ?? 0 },
          style: {
            padding: 4,
            borderRadius: 3,
            border: '1px solid #0284c7',
            background: '#fff',
            fontSize: 12,
            minWidth: 40,
            minHeight: 24,
          },
        }));
        const cfgEdges = (cfgRaw.edges || []).map((e: any) => ({
          id: e.id || `${e.source}-${e.target}`,
          source: e.source,
          target: e.target,
          markerEnd: { type: MarkerType.ArrowClosed },
          animated: true,
          style: { stroke: '#0284c7', strokeWidth: 2 },
        }));

        // layout 적용 (x/y 모두 0이거나 누락된 경우만)
        if (
          cfgNodes.length > 0 &&
          cfgNodes.every(n => (!n.position.x && !n.position.y))
        ) {
          cfgNodes = layout(cfgNodes, cfgEdges);
        }

        // 패널 id는 file+functionName+timestamp로 유니크하게
        const id = `${file}__${functionName}__${Date.now()}`;
        setCfgPanels(panels => [
          ...panels,
          {
            id,
            functionName,
            file,
            result: { nodes: cfgNodes, edges: cfgEdges },
            expanded: true,
            pos: { x: 24 + panels.length * 32, y: 24 + panels.length * 32 },
            dragging: false,
            dragOffset: { x: 0, y: 0 },
          },
        ]);
        setCfgMessage(null);
      }
    } catch (e: any) {
      setCfgMessage('API 호출 중 오류가 발생했습니다.');
    } finally {
      setCfgLoading(false);
    }
  };

  // Loading and error states
  if (!diagramReady) {
    // 미니멀하고 깔끔한 버튼 디자인, 배경은 그대로
    return (
      <div className="flex items-center justify-center h-full w-full">
        <button
          onClick={() => setDiagramReady(true)}
          style={{
            minWidth: 180,
            padding: '12px 32px',
            borderRadius: 8,
            background: '#fff',
            color: '#3b3b4f',
            fontWeight: 600,
            fontSize: 18,
            border: '1.5px solid #d1d5db',
            boxShadow: '0 2px 8px #0001',
            outline: 'none',
            cursor: 'pointer',
            transition: 'background 0.13s, box-shadow 0.13s, border 0.13s, color 0.13s',
            letterSpacing: 0.5,
          }}
          onMouseOver={e => {
            e.currentTarget.style.background = '#f3f4f6';
            e.currentTarget.style.border = '1.5px solid #6366f1';
            e.currentTarget.style.color = '#4338ca';
          }}
          onMouseOut={e => {
            e.currentTarget.style.background = '#fff';
            e.currentTarget.style.border = '1.5px solid #d1d5db';
            e.currentTarget.style.color = '#3b3b4f';
          }}
        >
          <span style={{
            display: 'inline-block',
            marginRight: 8,
            verticalAlign: 'middle',
            fontSize: 18,
            color: '#6366f1',
            transition: 'color 0.13s',
          }}>▶</span>
          Generate Diagram
        </button>
      </div>
    );
  }

  if (loading)
    return (
      <div className="flex items-center justify-center h-full w-full">
        <svg
          className="animate-spin h-8 w-8 text-blue-500"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
          />
        </svg>
        <span className="ml-3 text-sm text-slate-500">diagram loading…</span>
      </div>
    );
  if (error)
    return (
      <div className="p-4 text-sm text-red-600 whitespace-pre-wrap">{error}</div>
    );

  // Render
  return (
    <div className="relative h-full w-full border-l border-slate-300">
      <ReactFlow
        nodes={finalNodes}
        edges={finalEdges}
        onNodesChange={onNodesChange}
        onNodeClick={onNodeClick}
        onNodeMouseEnter={onEnter}
        onNodeMouseLeave={onLeave}
        onEdgeMouseEnter={onEdgeMouseEnter} // ⭐️
        onEdgeMouseLeave={onEdgeMouseLeave} // ⭐️
        fitView
        minZoom={0.2}
        maxZoom={2}
        className="bg-gray-50"
        nodeTypes={{
          group: CustomGroupNode, // Register custom group node
        }}
        onPaneClick={() => setSelectedNodeId(null)} // 빈 공간 클릭 시 선택 해제
      >
        <Background variant="dots" gap={16} size={1} />
        <MiniMap
          pannable
          zoomable
          nodeColor={n =>
            n.type === 'group'
              ? '#bdbdbd'
              : n.style?.background === '#fef9c3'
                ? '#facc15'
                : n.style?.background === '#dbeafe'
                  ? '#0284c7'
                  : '#2563eb'
          }
          nodeStrokeColor={n =>
            n.type === 'group'
              ? '#757575'
              : n.style?.border?.includes('#eab308')
                ? '#eab308'
                : n.style?.border?.includes('#0284c7')
                  ? '#0284c7'
                  : '#1e40af'
          }
          nodeStrokeWidth={2}
          maskColor="rgba(255,255,255,0.7)"
          style={{
            background: '#f3f4f6', // 밝은 회색 배경 (tailwind gray-100)
            border: '1.5px solid #cbd5e1', // 테두리 (tailwind slate-300)
            borderRadius: 6,
            boxShadow: '0 2px 8px #0002',
          }}
        />
        <Controls>
          {/* ...기존 +, -, 잠금 버튼 등... */}
          <button
            type="button"
            title="Re-layout"
            onClick={reLayout}
            style={{
              width: 20,
              height: 20,
              background: '#fff',
              padding: 0,
              margin: 4,
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 1px 2px #0001',
              transition: 'border 0.15s',
            }}
          >
            {/* 흑백 단색 레이아웃(정렬) 아이콘 */}
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <rect x="2" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="2" width="4" height="4" rx="1" fill="#222" />
              <rect x="2" y="10" width="4" height="4" rx="1" fill="#222" />
              <rect x="6" y="6" width="4" height="4" rx="1" fill="#222" />
              <rect x="10" y="10" width="4" height="4" rx="1" fill="#222" />
            </svg>
          </button>
          <button
            type="button"
            title="Generate Control Flow Graph"
            onClick={handleGenerateCFG}
            disabled={cfgLoading}
            style={{
              width: 20,
              height: 20,
              background: '#fff',
              padding: 0,
              margin: 4,
              cursor: cfgLoading ? 'not-allowed' : 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 1px 2px #0001',
              transition: 'border 0.15s',
              position: 'relative',
            }}
          >
            {/* 그래프 생성 느낌의 아이콘 (노드+엣지+플러스) - 검은색 */}
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style={{ opacity: cfgLoading ? 0.3 : 1 }}>
              <circle cx="6" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="14" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <circle cx="10" cy="14" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
              <line x1="7.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="12.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
              <line x1="8.2" y1="6" x2="11.8" y2="6" stroke="#222" strokeWidth="1.2" />
              <g>
                <circle cx="16.5" cy="16.5" r="3.2" fill="#222" />
                <rect x="16" y="14.2" width="1" height="4.6" rx="0.5" fill="#fff" />
                <rect x="14.2" y="16" width="4.6" height="1" rx="0.5" fill="#fff" />
              </g>
            </svg>
            {/* 로딩 스피너 */}
            {cfgLoading && (
              <span
                style={{
                  position: 'absolute',
                  left: 0, top: 0, width: '100%', height: '100%',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  background: 'rgba(255,255,255,0.7)',
                  borderRadius: 4,
                }}
              >
                <svg className="animate-spin" width="16" height="16" viewBox="0 0 16 16">
                  <circle
                    cx="8" cy="8" r="6"
                    stroke="#0284c7"
                    strokeWidth="2"
                    fill="none"
                    strokeDasharray="28"
                    strokeDashoffset="10"
                  />
                </svg>
              </span>
            )}
          </button>
        </Controls>
      </ReactFlow>

      {/* ⭐️ Control Flow Graph 메시지/결과 표시 */}
      {cfgMessage && (
        <div
          style={{
            position: 'absolute',
            top: 60,
            right: 24,
            background: '#fee2e2',
            color: '#b91c1c',
            padding: '8px 16px',
            borderRadius: 6,
            zIndex: 100,
            fontSize: 14,
            boxShadow: '0 2px 8px #0002',
          }}
        >
          {cfgMessage}
        </div>
      )}

      {/* ⭐️ 복수 패널 지원 */}
      {cfgPanels.map((panel, idx) => (
        <div
          key={panel.id}
          style={{
            position: 'fixed',
            top: panel.pos.y,
            right: panel.pos.x,
            background: '#f1f5f9',
            color: '#222',
            padding: panel.expanded ? '12px 18px 18px 18px' : '8px 18px 8px 18px',
            borderRadius: 8,
            zIndex: 200 + idx,
            fontSize: 13,
            minWidth: 220,
            maxWidth: 600,
            minHeight: panel.expanded ? 0 : 0,
            maxHeight: panel.expanded ? 600 : 44,
            boxShadow: '0 2px 8px #0002',
            whiteSpace: 'pre-wrap',
            overflow: panel.expanded ? 'auto' : 'hidden',
            transition: 'all 0.2s cubic-bezier(.4,2,.6,1)',
            display: 'flex',
            flexDirection: 'column',
            cursor: panel.dragging ? 'move' : 'default',
            userSelect: panel.dragging ? 'none' : 'auto',
          }}
          onMouseMove={e => {
            if (panel.dragging) {
              setCfgPanels(panels =>
                panels.map(p =>
                  p.id === panel.id
                    ? {
                      ...p,
                      pos: {
                        x: window.innerWidth - e.clientX - p.dragOffset.x,
                        y: e.clientY - p.dragOffset.y,
                      },
                    }
                    : p
                )
              );
            }
          }}
          onMouseUp={() => {
            if (panel.dragging) {
              setCfgPanels(panels =>
                panels.map(p =>
                  p.id === panel.id ? { ...p, dragging: false } : p
                )
              );
            }
          }}
        >
          {/* 헤더: 드래그 핸들 + expand/collapse/close */}
          <div
            style={{
              width: '100%',
              minHeight: 28,
              display: 'flex',
              alignItems: 'center',
              fontWeight: 600,
              fontSize: 13,
              color: '#555',
              userSelect: 'none',
              marginBottom: panel.expanded ? 8 : 0,
              gap: 4,
              cursor: 'move',
            }}
            onMouseDown={e => {
              setCfgPanels(panels =>
                panels.map(p =>
                  p.id === panel.id
                    ? {
                      ...p,
                      dragging: true,
                      dragOffset: {
                        x: window.innerWidth - e.clientX - (p.pos.x || 24),
                        y: e.clientY - (p.pos.y || 24),
                      },
                    }
                    : p
                )
              );
              e.preventDefault();
            }}
          >
            <span style={{ flex: 1 }}>
              CFG ({panel.functionName})
            </span>
            <button
              onClick={e => {
                e.stopPropagation();
                setCfgPanels(panels =>
                  panels.map(p =>
                    p.id === panel.id ? { ...p, expanded: !p.expanded } : p
                  )
                );
              }}
              style={{
                background: 'transparent',
                border: 'none',
                fontSize: 16,
                color: '#888',
                cursor: 'pointer',
                padding: 0,
                marginRight: 4,
                lineHeight: 1,
                width: 24,
                height: 24,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                transition: 'transform 0.15s',
                transform: panel.expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
              }}
              aria-label={panel.expanded ? 'Collapse' : 'Expand'}
              title={panel.expanded ? 'Collapse' : 'Expand'}
            >
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                <path d="M4 6l4 4 4-4" stroke="#888" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round" />
              </svg>
            </button>
            <button
              onClick={e => {
                e.stopPropagation();
                setCfgPanels(panels => panels.filter(p => p.id !== panel.id));
              }}
              style={{
                background: 'transparent',
                border: 'none',
                fontSize: 16,
                color: '#888',
                cursor: 'pointer',
                padding: 0,
                lineHeight: 1,
                width: 24,
                height: 24,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
              aria-label="Close"
              title="Close"
            >
              ×
            </button>
          </div>
          {panel.expanded && (
            <div style={{ width: '100%', overflow: 'auto' }}>
              {panel.result && panel.result.nodes && panel.result.edges ? (
                <div style={{ width: 400, height: 320, background: '#f8fafc', borderRadius: 6 }}>
                  <ReactFlow
                    nodes={panel.result.nodes}
                    edges={panel.result.edges}
                    fitView
                    minZoom={0.2}
                    maxZoom={2}
                    className="bg-gray-50"
                    style={{ width: '100%', height: '100%' }}
                  >
                    <Background variant="dots" gap={16} size={1} />
                    <Controls showInteractive={false} />
                  </ReactFlow>
                </div>
              ) : (
                <pre style={{
                  margin: 0,
                  fontSize: 13,
                  background: 'none',
                  whiteSpace: 'pre-wrap',
                  wordBreak: 'break-word',
                  maxWidth: 560,
                  maxHeight: 520,
                  padding: 0,
                }}>
                  {typeof panel.result === 'string' ? panel.result : JSON.stringify(panel.result, null, 2)}
                </pre>
              )}
            </div>
          )}
        </div>
      ))}
      {/* Code snippet panel */}
      {hoverId && snippet && (
        <div
          className="fixed z-50"
          style={{
            top: 16,
            right: 16,
            minWidth: 320,
            maxWidth: '40vw',
            width: 'auto',
            minHeight: 40,
            maxHeight: '80vh',
            background: '#fafafa', // atom-one-light에 어울리는 밝은 배경
            color: '#1e293b',
            fontSize: 12,
            borderRadius: 8,
            boxShadow: '0 4px 16px #0004',
            padding: 16,
            overflow: 'auto',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all',
            fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
          }}
          // highlight.js 스타일 적용을 위해 hljs 클래스 추가
          dangerouslySetInnerHTML={{ __html: `<pre class="hljs">${snippet}</pre>` }}
        />
      )}
    </div>
  );

  function hydrate(json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>) {
    let allFunctionNodes: Node[] = [];
    let allRawEdges: RawEdge[] = [];

    // Step 1: Collect all function nodes and all edges from JSON
    Object.entries(json).forEach(([file, data]) => {
      const { nodes: rawNodes, edges: rawEdges } = data;

      const fileFunctionNodes: Node[] = rawNodes.map((r) => ({
        id: r.id,
        data: { label: r.label || r.function_name || r.id, file: r.file },
        position: { x: 0, y: 0 },
        style: {
          padding: 6,
          borderRadius: 4,
          border: '1px solid #3b82f6',
          background: '#fff',
        },
        zIndex: 1, // Function nodes above group nodes
      }));

      allFunctionNodes = allFunctionNodes.concat(fileFunctionNodes);
      allRawEdges = allRawEdges.concat(rawEdges);
    });

    // Step 2: 전체 노드 id 집합 생성
    const allNodeIds = new Set(allFunctionNodes.map((n) => n.id));

    // Step 3: edge의 source/target이 전체 노드에 있으면 추가 (cross-file edge 지원)
    const allEdges: Edge[] = allRawEdges
      .filter((e) => allNodeIds.has(e.source) && allNodeIds.has(e.target))
      .map((r) => ({
        id: r.id,
        source: r.source,
        target: r.target,
        markerEnd: {
          type: MarkerType.ArrowClosed,
          width: 15, // 화살표 크기 증가
          height: 15, // 화살표 크기 증가
          color: '#34A853', // 더 진한 초록색
        },
        animated: true,
        style: { stroke: '#34A853', strokeWidth: 2 }, // 초록색, 두께 증가
        zIndex: 10000, // Edges above all nodes, including during drag
        // type: 'smoothstep', // Smooth step edges for better appearance
      }));

    // Step 2: Dagre를 사용해 모든 함수 노드 배치
    const posMap = layoutWithCluster(json);       // ← 새 클러스터 레이아웃
    const laidOutFunctionNodes = allFunctionNodes.map((n) => ({
      ...n,
      position: posMap[n.id] ?? { x: 0, y: 0 },
    }));

    // Step 3: 파일별 그룹 노드 생성
    const groupNodes: Node[] = [];
    const padding = 20;
    const fileToNodes: Record<string, Node[]> = {};

    // 파일별로 함수 노드 그룹화
    laidOutFunctionNodes.forEach((node) => {
      const file = (node.data as any).file;
      if (!fileToNodes[file]) {
        fileToNodes[file] = [];
      }
      fileToNodes[file].push(node);
    });

    // Step 4: 그룹 노드 생성 및 자식 노드 위치 조정
    Object.entries(fileToNodes).forEach(([file, nodes]) => {
      if (nodes.length === 0) return;

      // 그룹의 경계 상자 계산
      const xs = nodes.map((n) => n.position.x);
      const ys = nodes.map((n) => n.position.y);
      const minX = Math.min(...xs);
      const minY = Math.min(...ys);
      const maxX = Math.max(...xs) + 160; // 대략적인 노드 너비
      const maxY = Math.max(...ys) + 40;  // 대략적인 노드 높이

      const groupId = `group-${file.replace(/[^a-zA-Z0-9]/g, '_')}`;
      groupNodes.push({
        id: groupId,
        type: 'group', // This will use CustomGroupNode
        data: { label: file.split('/').pop() || file },
        position: { x: minX - padding, y: minY - padding },
        style: {
          width: maxX - minX + 2 * padding,
          height: maxY - minY + 2 * padding,
          background: 'rgba(0, 0, 0, 0.05)',
          border: '1px dashed #fb923c',
          borderRadius: 8,
        },
        zIndex: 0, // Group nodes below function nodes and edges
      });

      // 함수 노드 위치를 그룹 기준으로 조정
      nodes.forEach((node) => {
        node.position = {
          x: node.position.x - (minX - padding),
          y: node.position.y - (minY - padding),
        };
        node.parentId = groupId;
        node.extent = 'parent';
      });
    });

    // Step 5: 그룹 노드와 함수 노드 결합 후 상태 설정
    const allNodes = [...groupNodes, ...laidOutFunctionNodes];
    setNodes(allNodes);
    setEdges(allEdges);
  }
}

// Utility to find FileNode by path
function findByPath(nodes: FileNode[] = [], p: string): FileNode | undefined {
  const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

  for (const n of nodes) {
    if (n.path?.replace(regex, '') === p) return n;
    if (n.children) {
      const r = findByPath(n.children, p);
      if (r) return r;
    }
  }
}

[src/components/EditorTabs.tsx]
'use client';

import { useEffect, useState } from 'react';
import Editor from '@monaco-editor/react';
import { useEditor } from '@/store/editor';

function CodePane({ path, highlights }: { path: string; highlights?: { line: number; query: string } }) {
  const [code, setCode] = useState('// loading…');
  const [err, setErr] = useState<string>();
  const [editor, setEditor] = useState<any>(null);

  useEffect(() => {
    let active = true;
    (async () => {
      const res = await fetch(`/api/file?path=${encodeURIComponent(path)}`);
      if (!active) return;

      if (res.ok) {
        setCode(await res.text());
      } else {
        const { error } = await res.json().catch(() => ({ error: res.statusText }));
        setErr(`${res.status}: ${error}`);
      }
    })();
    return () => {
      active = false;
    };
  }, [path]);

  useEffect(() => {
    if (editor && highlights) {
      const { line, query } = highlights;
      editor.revealLineInCenter(line);
      editor.deltaDecorations([], [
        {
          range: new monaco.Range(line, 1, line, 1),
          options: { isWholeLine: true, className: 'highlight-line' },
        },
      ]);
      const matches = editor.getModel().findMatches(query, true, false, true, null, true);
      const decorations = matches.map((match) => ({
        range: match.range,
        options: { inlineClassName: 'highlight-text' },
      }));
      editor.deltaDecorations([], decorations);
    }
  }, [editor, highlights]);

  const lang = (() => {
    if (path.endsWith('.py')) return 'python';
    if (path.endsWith('.tsx') || path.endsWith('.ts')) return 'typescript';
    if (path.endsWith('.md')) return 'markdown';
    return 'plaintext';
  })();

  if (err) {
    return (
      <pre className="p-4 text-sm text-red-600 whitespace-pre-wrap">{err}</pre>
    );
  }

  return (
    <Editor
      height="calc(100% - 2rem)"
      defaultLanguage={lang}
      value={code}
      theme="vs"
      onMount={(editor) => setEditor(editor)}
      options={{
        readOnly: true,
        fontSize: 14,
        minimap: { enabled: true },
        automaticLayout: true,
        wordWrap: 'on',
      }}
    />
  );
}

export default function EditorTabs() {
  const { tabs, activeId, setActive, close, searchHighlights } = useEditor();

  if (!tabs.length) {
    return (
      <div className="h-full flex items-center justify-center text-sm text-slate-500">
        Open a file to begin
      </div>
    );
  }

  const active = tabs.find((t) => t.id === activeId) ?? tabs[0];

  return (
    <div className="flex flex-col h-full">
      <div className="h-8 flex items-center bg-slate-200 border-b border-slate-300 select-none">
        {tabs.map((t) => {
          const on = t.id === active.id;
          return (
            <div
              key={t.id}
              onClick={() => setActive(t.id)}
              className={
                'h-full flex items-center px-3 text-xs cursor-pointer border-r border-slate-300 transition-colors ' +
                (on
                  ? 'bg-white text-sky-700 font-semibold border-b-2 border-b-sky-600'
                  : 'text-slate-600 hover:bg-slate-100 border-b-2 border-b-transparent')
              }
            >
              {t.name}
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  close(t.id);
                }}
                className="ml-2 text-slate-400 hover:text-slate-600 transition-colors"
              >
                ×
              </button>
            </div>
          );
        })}
      </div>
      <div className="flex-1">
        <CodePane path={active.path} highlights={searchHighlights} />
      </div>
    </div>
  );
}

[src/components/FileExplorer.tsx]
'use client';

import { useEffect, useState } from 'react';
import clsx from 'clsx';
import { useFS, FileNode } from '@/store/files';
import { useEditor } from '@/store/editor';
import { nanoid } from 'nanoid';

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER ?? 'study1/face_classification';

function filterTree(nodes: FileNode[] = []): FileNode[] {
  return nodes
    .filter((n) => n.name !== '__pycache__' && n.name !== '.DS_Store')
    .map((n) =>
      Array.isArray(n.children)
        ? { ...n, children: filterTree(n.children) }
        : n
    );
}

const arr = (x: FileNode[] | FileNode | undefined): FileNode[] =>
  Array.isArray(x) ? x : x ? [x] : [];

function getIcon(n: FileNode, isDir: boolean, isOpen: boolean) {
  if (isDir) {
    // VSCode 스타일 폴더 아이콘 (열림/닫힘)
    return isOpen ? (
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <path
          d="M2 4.5A1.5 1.5 0 0 1 3.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H13a1 1 0 0 1 1 1v6.5A1.5 1.5 0 0 1 12.5 14h-9A1.5 1.5 0 0 1 2 12.5v-8Z"
          fill="#eab308"
          stroke="#b45309"
          strokeWidth="0.7"
        />
      </svg>
    ) : (
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <rect
          x="2"
          y="4"
          width="12"
          height="8"
          rx="1.5"
          fill="#fde68a"
          stroke="#b45309"
          strokeWidth="0.7"
        />
        <path
          d="M5.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H2V4.5A1.5 1.5 0 0 1 3.5 3h2Z"
          fill="#fbbf24"
          stroke="#b45309"
          strokeWidth="0.7"
        />
      </svg>
    );
  }
  if (n.name.endsWith('.py')) {
    // Python 아이콘 (심플)
    return (
      <svg
        width="16"
        height="16"
        viewBox="0 0 32 32"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <rect x="4" y="7" width="24" height="18" rx="6" fill="#3776AB" />
        <rect x="4" y="7" width="24" height="9" rx="4.5" fill="#FFD43B" />
        <circle cx="10" cy="12" r="1.5" fill="#222" />
        <circle cx="22" cy="20" r="1.5" fill="#fff" />
      </svg>
    );
  }
  // 기본 파일 아이콘
  return (
    <svg
      width="16"
      height="16"
      viewBox="0 0 16 16"
      style={{ marginRight: 4, display: 'inline' }}
      fill="none"
    >
      <rect
        x="3"
        y="2"
        width="10"
        height="12"
        rx="2"
        fill="#e5e7eb"
        stroke="#94a3b8"
        strokeWidth="0.7"
      />
      <rect x="5" y="5" width="6" height="1" rx="0.5" fill="#94a3b8" />
      <rect x="5" y="8" width="6" height="1" rx="0.5" fill="#94a3b8" />
    </svg>
  );
}

function Row({
  n,
  depth,
  isDir,
  isOpen,
  isActive,
  onClick,
}: {
  n: FileNode;
  depth: number;
  isDir: boolean;
  isOpen: boolean;
  isActive: boolean;
  onClick: () => void;
}) {
  return (
    <div
      style={{ paddingLeft: depth * 12 }}
      className={clsx(
        'cursor-pointer select-none text-xs py-[2px] px-1',
        'hover:bg-slate-100 transition-colors',
        isActive && 'bg-sky-100 text-sky-700'
      )}
      onClick={onClick}
    >
      {getIcon(n, isDir, isOpen)}
      {n.name}
    </div>
  );
}

export default function FileExplorer() {
  const { tree, current, setCurrent, load } = useFS();
  const [open, setOpen] = useState<Record<string, boolean>>({ [TARGET_FOLDER]: true });
  const { activePath } = useEditor();

  useEffect(() => {
    (async () => {
      const data: FileNode[] = await fetch('/api/files').then((r) => r.json());
      const filteredTree = filterTree(data);
      load(filteredTree);
      useFS.getState().loadContents(); // 파일 내용 로드
    })();
  }, [load]);

  const click = (n: FileNode) => {
    if (Array.isArray(n.children)) {
      setOpen((o) => ({ ...o, [n.path ?? '']: !o[n.path ?? ''] }));
    } else if (n.path) {
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const clean = n.path.replace(regex, '');
      setCurrent(n.id);
      useEditor.getState().open({
        id: nanoid(),
        path: clean,
        name: n.name,
      });
    }
  };

  const render = (nodes: FileNode[] | FileNode | undefined, depth = 0): JSX.Element[] =>
    arr(nodes).map((n) => {
      const isDir = Array.isArray(n.children);
      const isOpen = !!open[n.path ?? ''];
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
      const isActive = n.path?.replace(regex, '') === activePath;

      return (
        <div key={n.id}>
          <Row
            n={n}
            depth={depth}
            isDir={isDir}
            isOpen={isOpen}
            isActive={isActive}
            onClick={() => click(n)}
          />
          {isDir && isOpen && render(n.children, depth + 1)}
        </div>
      );
    });

  return (
    <aside className="w-full pl-2 h-full overflow-y-auto border-r border-slate-300 bg-slate-50">
      {render(tree)}
    </aside>
  );
}

[src/components/IconBar.tsx]
import {
  FolderIcon,
  MagnifyingGlassIcon,
  Squares2X2Icon,
  ChatBubbleLeftRightIcon,
} from '@heroicons/react/24/outline';
import type { ComponentType, SVGProps } from 'react';

type IconType = ComponentType<SVGProps<SVGSVGElement>>;
interface Props {
  states?: {
    explorer?: boolean;
    search?: boolean;
    diagram?: boolean;
    chat?: boolean;
  };
  toggle?: {
    explorer?: () => void;
    search?: () => void;
    diagram?: () => void;
    chat?: () => void;
  };
}

export default function IconBar({ states = {}, toggle = {} }: Props) {
  const Btn = ({
    on = false,
    click = () => {},
    Icon,
  }: {
    on?: boolean;
    click?: () => void;
    Icon: IconType;
  }) => (
    <button
      onClick={click}
      className={
        'w-10 h-10 flex items-center justify-center transition-colors ' +
        (on ? 'bg-white' : 'hover:bg-slate-100')
      }
    >
      <Icon className={'w-6 ' + (on ? 'stroke-sky-600' : 'stroke-slate-600')} />
    </button>
  );

  return (
    <div className="flex flex-col border-r border-slate-300 bg-slate-200">
      <Btn on={states.explorer} click={toggle.explorer} Icon={FolderIcon} />
      <Btn on={states.search} click={toggle.search} Icon={MagnifyingGlassIcon} />
      <Btn on={states.diagram} click={toggle.diagram} Icon={Squares2X2Icon} />
      <Btn on={states.chat} click={toggle.chat} Icon={ChatBubbleLeftRightIcon} />
    </div>
  );
}

[src/components/SearchPanel.tsx]
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useEditor } from '@/store/editor';
import { nanoid } from 'nanoid';
import { useFS, getAllFilePaths } from '@/store/files';

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

// 타입 정의: 검색 결과는 파일, 라인, 라인 텍스트
type SearchResult = {
  file: string;
  line: number;
  text: string;
};

export default function SearchPanel() {
  const [query, setQuery] = useState('');
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [expandedFiles, setExpandedFiles] = useState<{ [file: string]: boolean }>({});
  const { tree, fileContents } = useFS();

  const allFiles = useMemo(() => getAllFilePaths(tree, false), [tree]); // 폴더 제외, 파일만

  useEffect(() => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }
    const results: SearchResult[] = [];
    for (const file of allFiles) {
      const content = fileContents[file];
      if (!content) continue;
      const lines = content.split('\n');
      lines.forEach((lineText, idx) => {
        if (lineText.toLowerCase().includes(query.toLowerCase())) {
          results.push({
            file,
            line: idx + 1,
            text: lineText.trim(),
          });
        }
      });
    }
    setSearchResults(results);
  }, [query, allFiles, fileContents]);

  // 파일별로 결과를 그룹화
  const groupedResults = useMemo(() => {
    const groups: { [file: string]: SearchResult[] } = {};
    for (const result of searchResults) {
      if (!groups[result.file]) groups[result.file] = [];
      groups[result.file].push(result);
    }
    return groups;
  }, [searchResults]);

  // 검색 결과가 바뀌면 모든 파일을 expand
  useEffect(() => {
    const initial: { [file: string]: boolean } = {};
    Object.keys(groupedResults).forEach((file) => {
      initial[file] = true;
    });
    setExpandedFiles(initial);
  }, [groupedResults]);

  const handleToggleFile = (file: string) => {
    setExpandedFiles((prev) => ({
      ...prev,
      [file]: !prev[file],
    }));
  };

  const handleResultClick = (result: SearchResult) => {
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

    const cleanPath = result.file.replace(regex, '');
    const name = cleanPath.split('/').pop() || cleanPath;
    const editorState = useEditor.getState();
    editorState.open({
      id: nanoid(),
      path: cleanPath,
      name,
    });
    // 검색어가 있으면 하이라이트를 위해 저장
    if (query.trim()) {
      editorState.setSearchHighlights(result.line, query);
    }
  };

  return (
    <div className="w-full h-full p-2 bg-slate-50 border-r border-slate-300">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search in all files..."
        className="w-full p-2 mb-2 border rounded"
      />
      <div className="overflow-y-auto max-h-[calc(100%-2rem)]">
        {query.trim() === '' ? (
          <p className="text-xs text-gray-500">Enter a keyword</p>
        ) : searchResults.length > 0 ? (
          Object.entries(groupedResults).map(([file, results]) => (
            <div key={file} className="mb-2">
              <div
                className="font-mono text-xs font-semibold text-slate-700 mb-1 flex items-center cursor-pointer select-none"
                onClick={() => handleToggleFile(file)}
              >
                <span className="mr-1">
                  {expandedFiles[file] ? '▼' : '▶'}
                </span>
                {file}
                <span className="ml-2 text-slate-400">({results.length})</span>
              </div>
              {expandedFiles[file] && results.map((result, i) => (
                <div
                  key={i}
                  onClick={() => handleResultClick(result)}
                  className="text-xs py-1 px-2 hover:bg-slate-100 cursor-pointer flex"
                >
                  <span className="text-slate-400 mr-2">:{result.line}</span>
                  <span className="truncate text-slate-600">{result.text}</span>
                </div>
              ))}
            </div>
          ))
        ) : (
          <p className="text-xs text-gray-500">No search results found</p>
        )}
      </div>
    </div>
  );
}

[src/app/page.tsx]
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { useFS } from '@/store/files';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';

import IconBar from '@/components/IconBar';
import FileExplorer from '@/components/FileExplorer';
import SearchPanel from '@/components/SearchPanel';

const EditorTabs = dynamic(() => import('@/components/EditorTabs'), { ssr: false });
const DiagramViewer = dynamic(() => import('@/components/DiagramViewer'), { ssr: false });
const ChatUI = dynamic(() => import('@/components/ChatUI'), { ssr: false });

const HHandle = () => (
  <PanelResizeHandle className="w-[4px] bg-slate-300 hover:bg-sky-600 cursor-col-resize transition-colors" />
);
const VHandle = () => (
  <PanelResizeHandle className="h-[4px] bg-slate-300 hover:bg-sky-600 cursor-row-resize transition-colors" />
);

export default function Home() {
  const { current } = useFS();
  const [showSidebar, setShowSidebar] = useState(true);
  const [sidebarContent, setSidebarContent] = useState<'explorer' | 'search'>('explorer');
  const [showDia, setDia] = useState(true);
  const [showChat, setChat] = useState(true);

  useEffect(() => {
    setSidebarContent('explorer');
    setShowSidebar(true);
  }, []);

  const toggleExplorer = () => {
    if (sidebarContent === 'explorer' && showSidebar) {
      setShowSidebar(false);
    } else {
      setSidebarContent('explorer');
      setShowSidebar(true);
    }
  };

  const toggleSearch = () => {
    if (sidebarContent === 'search' && showSidebar) {
      setShowSidebar(false);
    } else {
      setSidebarContent('search');
      setShowSidebar(true);
    }
  };

  const toggleDia = () => setDia(!showDia);
  const toggleChat = () => setChat(!showChat);

  return (
    <div className="flex h-full">
      <IconBar
        states={{
          explorer: sidebarContent === 'explorer' && showSidebar,
          search: !(sidebarContent === 'search' && showSidebar),
          diagram: showDia,
          chat: showChat,
        }}
        toggle={{
          explorer: toggleExplorer,
          search: toggleSearch,
          diagram: toggleDia,
          chat: toggleChat,
        }}
      />
      <PanelGroup direction="horizontal" className="flex-1">
        {showSidebar && (
          <>
            <Panel defaultSize={15} minSize={12}>
              {sidebarContent === 'explorer' ? <FileExplorer /> : <SearchPanel />}
            </Panel>
            <HHandle />
          </>
        )}
        <Panel defaultSize={55} minSize={30} className="border-x border-slate-300">
          <EditorTabs />
        </Panel>
        {(showDia || showChat) && <HHandle />}
        {(showDia || showChat) && (
          <Panel defaultSize={30} minSize={18} className="flex-1 min-w-0">
            <PanelGroup direction="vertical">
              {showDia && (
                <>
                  <Panel defaultSize={70} minSize={30}>
                    <DiagramViewer />
                  </Panel>
                  {showChat && <VHandle />}
                </>
              )}
              {showChat && (
                <Panel defaultSize={30} minSize={20}>
                  <ChatUI />
                </Panel>
              )}
            </PanelGroup>
          </Panel>
        )}
      </PanelGroup>
    </div>
  );
}

[src/app/globals.css]
/* src/app/globals.css */
@import 'tailwindcss';

/* ─── 라이트 팔레트 ─── */
:root{
  --background: #ffffff;
  --foreground: #171717;
  --panel:      #f3f3f3;
  --border:     #e5e5e5;
  --side:       #eeeeee;
  --accent:     #0078d4;
}

/* ─── 다크 팔레트 ─── */
@media (prefers-color-scheme:dark){
  :root{
    --background: #1e1e1e;
    --foreground: #ededed;
    --panel:      #252526;
    --border:     #3c3c3c;
    --side:       #333337;
    --accent:     #569cd6;
  }
}

/* 기본 레이아웃 */
html, body {
  height: 100%;
}
body {
  background: var(--background);
  color: var(--foreground);
  font-family: system-ui, Arial, Helvetica, sans-serif;
  font-size: 14px;
  margin: 0;
  padding: 0;
  overscroll-behavior: none;
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background-color: var(--border);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background-color: var(--accent);
}

/* 선택 행 하이라이트 */
.vscode-tree-active{
  background: var(--side);
  color: var(--accent);
}

/* Transition classes for smoother toggles, hovers, etc. */
.transition-colors {
  transition: color 0.15s ease, background-color 0.15s ease;
}

.highlight-line {
  background-color: rgba(255, 255, 0, 0.2);
}
.highlight-text {
  background-color: rgba(255, 255, 0, 0.5);
}

/* 드래그 중 노드의 zIndex 제한 */
.react-flow__node.dragging {
  z-index: 10 !important; /* 엣지의 zIndex(10000)보다 낮게 설정 */
}

[src/store/editor.ts]
"use client";

import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { useFS } from "@/store/files";

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export interface TabMeta {
  id: string;
  path: string;
  name: string;
}

interface State {
  tabs: TabMeta[];
  activeId?: string;
  activePath?: string;
  searchHighlights?: { line: number; query: string };
  open: (file: TabMeta) => void;
  close: (id: string) => void;
  setActive: (id: string) => void;
  setSearchHighlights: (line: number, query: string) => void;
}

export const useEditor = create<State>()(
  immer((set) => ({
    tabs: [],
    activeId: undefined,
    activePath: undefined,
    searchHighlights: undefined,
    open: (file) =>
      set((s) => {
        if (!s.tabs.find((t) => t.path === file.path)) s.tabs.push(file);
        s.activeId = s.tabs.find((t) => t.path === file.path)?.id ?? file.id;
        s.activePath = file.path;
        s.searchHighlights = undefined;
      }),
    close: (id) =>
      set((s) => {
        s.tabs = s.tabs.filter((t) => t.id !== id);
        if (s.activeId === id) {
          const lastTab = s.tabs.at(-1);
          s.activeId = lastTab?.id;
          s.activePath = lastTab?.path;
        }
        s.searchHighlights = undefined;
      }),
    setActive: (id) =>
      set((s) => {
        s.activeId = id;
        s.activePath = s.tabs.find((t) => t.id === id)?.path;
        if (s.activePath) {
          const node = findByPath(useFS.getState().tree, s.activePath);
          if (node) useFS.getState().setCurrent(node.id);
        }
        s.searchHighlights = undefined;
      }),
    setSearchHighlights: (line, query) =>
      set((s) => {
        s.searchHighlights = { line, query };
      }),
  }))
);

function findByPath(nodes: FileNode[], path: string): FileNode | undefined {
  const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

  for (const n of nodes) {
    if (n.path?.replace(regex, "") === path) return n;

    if (n.children) {
      const r = findByPath(n.children, path);
      if (r) return r;
    }
  }
}


[src/store/files.ts]
import { create } from "zustand";

const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

export type FileNode = {
  id: string;
  name: string;
  path: string;
  children?: FileNode[];
};

interface FSState {
  tree: FileNode[];
  current?: FileNode;
  fileContents: Record<string, string>;
  setCurrent: (id: string) => void;
  load: (t: FileNode[]) => void;
  loadContents: () => Promise<void>;
}

export const useFS = create<FSState>((set, get) => ({
  tree: [],
  current: undefined,
  fileContents: {},
  setCurrent: (id) => set((state) => ({ current: find(state.tree, id) })),
  load: (tree) => set({ tree }),
  loadContents: async () => {
    const paths = getAllFilePaths(get().tree, false); // 파일만 가져오기
    for (const path of paths) {
      try {
        const response = await fetch(
          `/api/file?path=${encodeURIComponent(path)}`
        );
        if (response.ok) {
          const content = await response.text();
          set((state) => ({
            fileContents: { ...state.fileContents, [path]: content },
          }));
        } else {
          console.error(
            `Failed to fetch content for ${path}: ${response.status}`
          );
        }
      } catch (err) {
        console.error(`Error loading content for ${path}:`, err);
      }
    }
  },
}));

function find(nodes: FileNode[], id: string): FileNode | undefined {
  for (const n of nodes) {
    if (n.id === id) return n;
    if (n.children) {
      const r = find(n.children, id);
      if (r) return r;
    }
  }
}

export function getAllFilePaths(
  tree: FileNode[],
  includeFolders = false
): string[] {
  const paths: string[] = [];
  const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

  const traverse = (nodes: FileNode[]) => {
    for (const node of nodes) {
      if (!node.children || includeFolders) {
        const cleanPath = node.path.replace(regex, "");

        paths.push(cleanPath);
      }
      if (node.children) traverse(node.children);
    }
  };
  traverse(tree);
  return paths;
}


[backend/app/main.py]
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
from pathlib import Path
from schemas.common import *
from llm.diagram_generator import generate_call_graph, generate_control_flow_graph
from llm.chatbot import create_session, remove_session, generate_chatbot_answer_with_session, get_session_history
from llm.utils import get_source_file_with_line_number
from fastapi.responses import JSONResponse
from llm.constants import SAMPLE_CFG_JSON

import json

# .env file loading
load_dotenv()

# FastAPI app initialization
app = FastAPI(title="Code-Diagram API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 프론트엔드 도메인으로 제한 가능
    allow_credentials=True,
    allow_methods=["*"],  # 모든 HTTP 메서드 허용
    allow_headers=["*"],  # 모든 헤더 허용
)

# Define the path to the HTML template
HTML_PATH = Path(__file__).parent / "html" / "root.html"

# API Endpoint
@app.get("/", response_class=HTMLResponse)
async def root():
    try:
        # Read the HTML content from the file
        html_content = HTML_PATH.read_text(encoding="utf-8")
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(content="<h1>Template not found</h1>", status_code=404)

@app.post("/api/generate_call_graph", response_model=CGDiagramResponse)
async def api_generate_call_graph(request: CGDiagramRequest):
    """
    Generate a call graph for the given code.
    """
    try:

        json_data = await generate_call_graph(request.path, request.file_type)
        result = {
            "data": json_data
        }
        print(f'result in main.py: \\{result}')
        return CGDiagramResponse(**result)
    except Exception as e:
        return CGDiagramResponse(status=500, data=str(e))

@app.post("/api/generate_control_flow_graph", response_model=CFGDiagramResponse)
async def api_generate_control_flow_graph(request: CFGDiagramRequest):
    """
    Generate a control flow graph for the given code.
    """
    try:
        json_data = await generate_control_flow_graph(request.file_path, request.function_name)
        result = {
            "data": json_data
        }
        print(f'result in main.py: \\{result}')
        return CFGDiagramResponse(**result)
    except Exception as e:
        return CFGDiagramResponse(status=500, data=str(e))

@app.get("/api/chatbot/session/open")
async def api_open_session():
    try:
        session_id = create_session()
        return SessionResponse(session_id=session_id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chatbot/session/close")
async def api_close_session(req: SessionRequest):
    try:
        if not req.session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        remove_session(req.session_id)
        return {"status": "closed"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chatbot/session/chat", response_model=ChatbotQueryResponse)
async def api_session_chat(req: ChatbotQueryRequest):
    try:
        if not req.session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        if not req.query:
            raise HTTPException(status_code=400, detail="Query is required")
        
        # Handle Context Files
        context = ""
        if hasattr(req, 'context_files') and req.context_files:
            context += "Below is the context from the provided files:\n"
            for file_path in req.context_files:
                context += get_source_file_with_line_number(file_path)
            context += "Please answer the question based on the above context.\n"


        print(f"Session ID: {req.session_id}")
        print(f"Query: {req.query}")
        print(f"Code: {req.code}")
        print(f"Diagram: {req.diagram}")
        print(f"Context Files: {req.context_files}")
        print(f"Context: {context}")
        answer, highlight = await generate_chatbot_answer_with_session(
            req.session_id, req.query + context, req.code, req.diagram
        )
        print(f"Answer: {answer}")
        print(f"Highlight: {highlight}")
        return ChatbotQueryResponse(answer=answer, highlight=highlight)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
@app.get("/api/chatbot/session/get_history")
async def api_get_session_history(session_id: str):
    try:
        if not session_id:
            raise HTTPException(status_code=400, detail="Session ID is required")
        history = get_session_history(session_id)
        return {"session_id": session_id, "history": history}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

[src/app/api/files/route.ts]
/** Next 15 이상: Edge → Node 런타임으로 전환 (fs 사용) */
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';     // dev · hot-reload 편하게

import fs from 'node:fs';
import path from 'node:path';
import { NextResponse } from 'next/server';

type FileNode = { id: string; name: string; path: string; children?: FileNode[] };

const POC_DIR = path.join(process.cwd(), '..', 'poc');   //   …/poc

/* ── 재귀적으로 파일/폴더 탐색해 FileNode 트리 생성 ───────────── */
function walk(dir: string): FileNode[] {
  return fs.readdirSync(dir).map((name): FileNode => {
    const full = path.join(dir, name);                   // …/poc/foo.py
    const rel  = path.relative(POC_DIR, full);           // foo.py  또는 sub/bar.py
    const id   = rel.replace(/[^\w]/g, '_');             // 고유 ID

    if (fs.statSync(full).isDirectory()) {
      return { id, name, path: rel, children: walk(full) };
    }
    return { id, name, path: rel };
  });
}

/* ── GET /api/files ─────────────────────────────────────── */
export async function GET() {
  const tree: FileNode = {
    id: 'poc',
    name: 'poc',
    path: 'poc',               // root 노드는 “poc”
    children: walk(POC_DIR),
  };
  return NextResponse.json([tree]);  // 배열로 감싸서 FileExplorer에 그대로 전달
}


[src/app/api/file/route.ts]
// frontend/src/app/api/file/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import { promises as fs } from 'node:fs';
import path from 'node:path';

const POC_DIR = path.join(process.cwd(), '..', 'poc');   // <root>/poc

export async function GET(req: Request) {
  const raw = new URL(req.url).searchParams.get('path') ?? '';

  /* ── 경로 정규화 & 보안 ─────────────────────────────── */
  const parts = raw.split(/[\\/]/).filter(p => p && p !== '..');
  // "poc/…" 또는 "../poc/…" 로 올 수 있으니 'poc' 토큰 제거
  if (parts[0] === 'poc') parts.shift();
  if (parts[0] === '..' && parts[1] === 'poc') parts.splice(0, 2);

  const rel = parts.join('/');             // ex) "main.py"  "src/App.tsx"
  const abs = path.join(POC_DIR, rel);     // <root>/poc/main.py

  try {
    const text = await fs.readFile(abs, 'utf8');
    /* 기본 텍스트 응답 */
    return new NextResponse(text);
  } catch {
    /* 파일 못 찾으면 404 JSON */
    return NextResponse.json({ error: 'File not found' }, { status: 404 });
  }
}


