  [src/components/ChatUI.tsx]
  import { useState, useEffect, useRef, FormEvent } from 'react';
  import { XMarkIcon, PlusIcon } from '@heroicons/react/24/outline';
  import { useFS, getAllFilePaths } from '@/store/files';
  import { marked } from 'marked'; // ÎßàÌÅ¨Îã§Ïö¥ ÌååÏÑú Ï∂îÍ∞Ä

  interface Message {
    role: 'user' | 'bot';
    t: string;
  }

  interface Session {
    id: string;
    log: Message[];
  }

  const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';

  export default function ChatUI() {
    const [sessions, setSessions] = useState<Session[]>([]);
    const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
    const [input, setInput] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [showDropdown, setShowDropdown] = useState(false);
    const [dropdownItems, setDropdownItems] = useState<string[]>([]);
    const [isBotTyping, setIsBotTyping] = useState(false);
    const { tree } = useFS();
    const allFiles = getAllFilePaths(tree);
    const chatContainerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
      async function init() {
        const newSessionId = await openNewSession();
        if (newSessionId) setCurrentSessionId(newSessionId);
      }
      init();

      return () => {
        sessions.forEach((session) => {
          fetch(`${apiUrl}/api/chatbot/session/close`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_id: session.id }),
          });
        });
      };
    }, []);

    const openNewSession = async () => {
      try {
        const res = await fetch(`${apiUrl}/api/chatbot/session/open`, { method: 'GET' });
        if (!res.ok) throw new Error(`Failed to open session: ${res.status}`);
        const data = await res.json();
        const newSessionId = data.session_id;
        setSessions((prev) => [...prev, { id: newSessionId, log: [] }]);
        setCurrentSessionId(newSessionId);
        return newSessionId;
      } catch (err) {
        console.error('Failed to open session:', err);
        setError('Failed to open session. Please try again.');
        return null;
      }
    };

    const closeSession = async (sessionId: string) => {
      try {
        await fetch(`${apiUrl}/api/chatbot/session/close`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId }),
        });
        setSessions((prevSessions) => {
          const newSessions = prevSessions.filter((s) => s.id !== sessionId);
          if (currentSessionId === sessionId) {
            setCurrentSessionId(newSessions.length > 0 ? newSessions[0].id : null);
          }
          return newSessions;
        });
      } catch (err) {
        console.error('Failed to close session:', err);
        setError('Failed to close session. Please try again.');
      }
    };

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const value = e.target.value;
      setInput(value);

      const atIndex = value.lastIndexOf('@');
      if (atIndex >= 0) {
        const afterAt = value.slice(atIndex + 1);
        const spaceIndex = afterAt.indexOf(' ');
        const word = spaceIndex >= 0 ? afterAt.slice(0, spaceIndex) : afterAt;
        if (word) {
          const filtered = allFiles.filter((path) =>
            path.toLowerCase().includes(word.toLowerCase())
          );
          setDropdownItems(filtered);
          setShowDropdown(true);
        } else {
          setDropdownItems(allFiles); // Show all files when just "@" is typed
          setShowDropdown(true);
        }
      } else {
        setShowDropdown(false); // Hide dropdown if no "@" present
      }
    };

    const handleSelectItem = (selected: string) => {
      const atIndex = input.lastIndexOf('@');
      if (atIndex >= 0) {
        const beforeAt = input.slice(0, atIndex + 1);
        const afterAt = input.slice(atIndex + 1);
        const spaceIndex = afterAt.indexOf(' ');
        const endIndex = spaceIndex >= 0 ? atIndex + 1 + spaceIndex : input.length;
        const newInput = beforeAt + selected + input.slice(endIndex);
        setInput(newInput); // Update input with selected file
      }
      setShowDropdown(false); // Hide dropdown after selection
    };

    const send = async (e: FormEvent) => {
      e.preventDefault();
      if (!input.trim() || !currentSessionId) return;

      setSessions((prev) =>
        prev.map((s) =>
          s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'user', t: input }] } : s
        )
      );
      setInput('');
      setIsBotTyping(true); // ÎãµÎ≥Ä ÎåÄÍ∏∞ ÏãúÏûë

      try {
        const res = await fetch(`${apiUrl}/api/chatbot/session/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: currentSessionId,
            query: input,
            code: '',
            diagram: '',
            context_files: input.match(/@(\S+)/g)?.map((m) => m.slice(1)) || [],
          }),
        });
        if (!res.ok) throw new Error(`Failed to send message: ${res.status}`);
        const data = await res.json();
        const text = data.answer;
        setSessions((prev) =>
          prev.map((s) =>
            s.id === currentSessionId ? { ...s, log: [...s.log, { role: 'bot', t: text }] } : s
          )
        );
        setIsBotTyping(false); // ÎãµÎ≥Ä ÎèÑÏ∞©
      } catch (err) {
        console.error('Failed to send message:', err);
        setSessions((prev) =>
          prev.map((s) =>
            s.id === currentSessionId
              ? { ...s, log: [...s.log, { role: 'bot', t: 'Error: Failed to send message.' }] }
              : s
          )
        );
        setIsBotTyping(false); // ÏóêÎü¨ Î∞úÏÉù ÏãúÎèÑ ÎãµÎ≥Ä ÎåÄÍ∏∞ Ï¢ÖÎ£å
      }
    };

    const currentLog = sessions.find((s) => s.id === currentSessionId)?.log || [];

    useEffect(() => {
      if (chatContainerRef.current) {
        chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
      }
    }, [currentLog, currentSessionId]);

    return (
      <div className="flex flex-col h-full bg-slate-50">
        <div className="flex items-center space-x-2 bg-slate-200 border-b border-slate-300 p-2 overflow-x-auto">
          {sessions.map((session, index) => (
            <div
              key={session.id}
              onClick={() => setCurrentSessionId(session.id)}
              className={`flex items-center px-3 py-1 cursor-pointer rounded-t-md ${
                session.id === currentSessionId ? 'bg-white border-t border-x border-slate-300' : ''
              }`}
            >
              <span style={{ fontWeight: 'bold' }}>üí¨ Chat # {index + 1}</span>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  closeSession(session.id);
                }}
                className="ml-2"
              >
                <XMarkIcon className="w-4 h-4" />
              </button>
            </div>
          ))}
          <button onClick={openNewSession} className="px-2 py-1">
            <PlusIcon className="w-5 h-5" />
          </button>
        </div>

        <div
          ref={chatContainerRef}
          className="flex-1 p-4 overflow-y-auto bg-white"
        >
          {sessions.length === 0 ? (
            <p className="text-center text-gray-500">
              No active sessions. Click '+' to start a new session.
            </p>
          ) : (
            currentLog.map((msg, i) => (
              <div key={i} className={`mb-2 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}>
                <span
                  className={`inline-block p-2 rounded ${
                    msg.role === 'user' ? 'bg-blue-100' : 'bg-gray-100'
                  }`}
                  // ÎßàÌÅ¨Îã§Ïö¥ Î†åÎçîÎßÅ
                  dangerouslySetInnerHTML={{ __html: marked.parse(msg.t) }}
                />
              </div>
            ))
          )}
          {isBotTyping && (
            <div className="mb-2 text-left">
              <span className="inline-block p-2 rounded bg-gray-100 text-gray-500 animate-pulse">
                <TypingIndicator />
              </span>
            </div>
          )}
          {error && <p className="text-red-500">{error}</p>}
        </div>

        {currentSessionId && (
          <div className="relative p-4 border-t border-slate-300 bg-white">
            <form onSubmit={send}>
              <input
                type="text"
                value={input}
                onChange={handleInputChange}
                className="w-full p-2 border rounded"
                placeholder="Type your message..."
              />
              <button type="submit" className="hidden">
                Send
              </button>
            </form>
            {showDropdown && (
              <div
                className="absolute z-10 bg-white border border-slate-300 rounded shadow-md max-h-60 overflow-y-auto"
                style={{ bottom: '100%', left: 0 }}
              >
                {dropdownItems.map((item, i) => (
                  <div
                    key={i}
                    onClick={() => handleSelectItem(item)}
                    className="px-3 py-1 hover:bg-slate-100 cursor-pointer"
                  >
                    {item}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  // Ï±ÑÌåÖ ÌÉÄÏù¥Ìïë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïª¥Ìè¨ÎÑåÌä∏
  function TypingIndicator() {
    return (
      <span>
        <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0s' }}></span>
        <span className="inline-block w-2 h-2 bg-gray-400 rounded-full mr-1 animate-bounce" style={{ animationDelay: '0.2s' }}></span>
        <span className="inline-block w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></span>
      </span>
    );
  }

  [src/components/CodeViewer.tsx]
  'use client';

  import { useEffect, useState } from 'react';
  import Editor from '@monaco-editor/react';

  export default function CodeViewer({ filePath }: { filePath: string }) {
    const [code, setCode] = useState('// loading‚Ä¶');

    /* ‚ë† Ïã§Ï†ú ÌååÏùº ÎÇ¥Ïö© Í∞ÄÏ†∏Ïò§Í∏∞ -------------------------------------- */
    useEffect(() => {
      (async () => {
        const c = await fetch(`/api/file?path=${encodeURIComponent(filePath)}`).then((r) =>
          r.text()
        );
        setCode(c);
      })();
    }, [filePath]);

    /* ‚ë° ÌôïÏû•ÏûêÎ°ú Ïñ∏Ïñ¥ Í≤∞Ï†ï ----------------------------------------- */
    const lang = (() => {
      if (filePath.endsWith('.tsx') || filePath.endsWith('.ts')) return 'typescript';
      if (filePath.endsWith('.py')) return 'python';
      if (filePath.endsWith('.md')) return 'markdown';
      return 'plaintext';
    })();

    /* ‚ë¢ ÏóêÎîîÌÑ∞ + Ï†úÎ™© Î∞î ------------------------------------------- */
    return (
      <div className="h-full bg-slate-100 rounded-md shadow-sm overflow-hidden">
        <div className="h-8 flex items-center px-3 bg-slate-200 border-b border-slate-300 text-xs">
          {filePath.split('/').pop()}
        </div>
        <Editor
          height="calc(100% - 2rem)"
          defaultLanguage={lang}
          value={code}
          theme="vs-dark"
          options={{
            minimap: { enabled: true },
            fontSize: 11.5,
            automaticLayout: true,
            readOnly: true,
          }}
        />
      </div>
    );
  }


  [src/components/DiagramViewer.tsx]
  'use client';

  import { useState, useEffect, useCallback, useMemo } from 'react';
  import {
    ReactFlow,
    Background,
    MiniMap,
    Controls,
    MarkerType,
    type Node,
    type Edge,
    type NodeMouseHandler,
    applyNodeChanges,
    NodeChange,
  } from '@xyflow/react';
  import '@xyflow/react/dist/style.css';
  import { nanoid } from 'nanoid';
  import { useEditor } from '@/store/editor';
  import { useFS, type FileNode } from '@/store/files';
  import {
    RawNode,
    RawEdge,
    CFGPanel,
    snippetCache,
    extractFunctionSnippet,
    highlightWithLineNumbers,
    isNodeHidden,
    findRepresentativeNode,
    calculateLayout,
    CustomGroupNode,
    parseApiResponse,
    cleanFilePath,
    calculateNodeWidth,
    ENDPOINTS,
    STYLES,
  } from './diagramUtils';

  // Constants
  let diagramCache: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> | null = null;
  const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';
  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

  export default function DiagramViewer() {
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<Edge[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string>();
    const [hoverId, setHoverId] = useState<string | null>(null);
    const [snippet, setSnippet] = useState<string>('');
    const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
    const [cfgMessage, setCfgMessage] = useState<string | null>(null);
    const [cfgPanels, setCfgPanels] = useState<CFGPanel[]>([]);
    const [cfgLoading, setCfgLoading] = useState(false);
    const [diagramReady, setDiagramReady] = useState(false);
    const [hoveredEdgeId, setHoveredEdgeId] = useState<string | null>(null);
    const [collapsedGroups, setCollapsedGroups] = useState<Set<string>>(new Set());
    const [cfgPanelMessage, setCfgPanelMessage] = useState<string | null>(null);

    const editorState = useEditor.getState();
    const fsState = useFS.getState();

    const activePath = editorState.tabs.find(t => t.id === editorState.activeId)?.path ?? '';

    // Handlers
    const toggleCollapse = useCallback((groupId: string) => {
      setCollapsedGroups(prev => {
        const newSet = new Set(prev);
        newSet.has(groupId) ? newSet.delete(groupId) : newSet.add(groupId);
        return newSet;
      });
    }, []);

    const openFile = useCallback((filePath: string, line?: number, highlight?: { from: number; to: number }) => {
      const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
      editorState.open({
        id: nanoid(),
        path: cleanPath,
        name: cleanPath.split(/[\\/]/).pop() ?? cleanPath,
        line,
        highlight,
      });
      const target = findByPath(fsState.tree, cleanPath);
      if (target) fsState.setCurrent(target.id);
    }, [editorState, fsState]);

    const onNodeClick: NodeMouseHandler = useCallback((_, node) => {
      if (node.type === 'group') {
        const childNode = nodes.find(n => n.parentId === node.id && !isNodeHidden(n.id, collapsedGroups, nodes));
        const filePath = (childNode?.data as any)?.file || (node.data as any)?.file;
        if (filePath) openFile(filePath, 1);
        return;
      }
      setSelectedNodeId(prev => prev === node.id ? null : node.id);
      const filePath = (node.data as any)?.file;
      if (filePath) openFile(filePath);
    }, [nodes, collapsedGroups, openFile]);

    const onNodeMouseEnter: NodeMouseHandler = useCallback(async (_, node) => {
      if (node.type === 'group') return;

      setHoverId(node.id);
      const filePath = (node.data as any)?.file;
      const functionName = (node.data as any)?.label;
      if (!filePath || !functionName) {
        setSnippet('');
        return;
      }

      const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
      const cacheKey = `${cleanPath}_${functionName}`;

      try {
        let code = snippetCache.get(cacheKey);
        if (!code) {
          const response = await fetch(`/api/file?path=${encodeURIComponent(cleanPath)}`);
          code = await response.text();
        }

        const result = extractFunctionSnippet(code, functionName);
        if (result) {
          snippetCache.set(cacheKey, result.snippet);
          setSnippet(highlightWithLineNumbers(result.snippet, result.startLine));
        } else {
          setSnippet('(function not found)');
        }
      } catch {
        setSnippet('(preview unavailable)');
      }
    }, []);

    const onNodeMouseLeave = useCallback(() => {
      setHoverId(null);
      setSnippet('');
    }, []);

    const handleCFGPanelUpdate = useCallback((id: string, updates: Partial<CFGPanel>) => {
      setCfgPanels(panels => panels.map(p => p.id === id ? { ...p, ...updates } : p));
    }, []);

    const handleCFGPanelClose = useCallback((id: string) => {
      setCfgPanels(panels => panels.filter(p => p.id !== id));
    }, []);

    const handleCFGNodeHover = useCallback(async (node: Node | null, panel: CFGPanel) => {
      if (!node) {
        setCfgPanelMessage(null);
        return;
      }

      const { line_start, line_end } = node.data as any;

      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
            ÏÑ§Î™ÖÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...
          </span>
        </div>`
      );

      try {
        const res = await fetch(`${apiUrl}${ENDPOINTS.INLINE_CODE_EXPLANATION}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_path: panel.file, line_start, line_end }),
        });
        const data = await res.json();
        const explanation = data.explanation || data.data?.explanation || 'ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';

        setCfgPanelMessage(
          `<div style="display:flex;align-items:flex-start;gap:8px;">
            <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
            <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:320px;display:inline-block;">
              ${explanation}
            </span>
          </div>`
        );
      } catch {
        setCfgPanelMessage(
          `<div style="display:flex;align-items:flex-start;gap:8px;">
            <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
            <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
              ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
            </span>
          </div>`
        );
      }

      openFile(node.data.file || panel.file, line_start, { from: line_start, to: line_end });
    }, [apiUrl, openFile]);

    const handleGenerateCFG = useCallback(async () => {
      setCfgMessage(null);
      setCfgLoading(true);

      const selectedNode = nodes.find(n => n.id === selectedNodeId && n.type !== 'group');
      if (!selectedNode) {
        setCfgMessage('ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      const { file, label: functionName } = selectedNode.data as any;
      if (!file || !functionName) {
        setCfgMessage('ÎÖ∏Îìú Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      if (cfgPanels.some(p => p.file === file && p.functionName === functionName)) {
        setCfgMessage('Ïù¥ÎØ∏ Ìï¥Îãπ Ìï®ÏàòÏùò CFG Ìå®ÎÑêÏù¥ Ïó¥Î†§ ÏûàÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      try {
        const res = await fetch(`${apiUrl}${ENDPOINTS.CFG}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_path: file, function_name: functionName }),
        });

        const data = await res.json();
        if (data.status && data.status !== 200) {
          setCfgMessage('API Ìò∏Ï∂ú Ïã§Ìå®: ' + (data.data || ''));
          return;
        }

        const cfgData = parseApiResponse(data);
        let cfgNodes = (cfgData.nodes || []).map((n: any) => ({
          id: n.id,
          data: {
            label: n.label || n.id,
            file: n.file || file,
            line_start: n.line_start || 1,
            line_end: n.line_end || 1,
          },
          position: { x: n.x ?? 0, y: n.y ?? 0 },
          style: {
            padding: 4,
            borderRadius: 3,
            border: '1px solid #0284c7',
            background: '#fff',
            fontSize: 12,
            minWidth: 40,
            minHeight: 24,
          },
        }));

        const cfgEdges = (cfgData.edges || []).map((e: any) => ({
          id: e.id || `${e.source}-${e.target}`,
          source: e.source,
          target: e.target,
          markerEnd: { type: MarkerType.ArrowClosed },
          animated: true,
          style: { stroke: '#0284c7', strokeWidth: 2 },
        }));

        if (cfgData.nodes?.length > 0 && cfgData.nodes.every((n: any) => !n.x && !n.y)) {
          const posMap = calculateLayout({ [file]: { nodes: cfgData.nodes, edges: cfgData.edges } }, {});
          cfgNodes = cfgNodes.map((n: any) => ({
            ...n,
            position: posMap[n.id] ?? { x: 0, y: 0 }
          }));
        }

        setCfgPanels(panels => [
          ...panels,
          {
            id: `${file}__${functionName}__${Date.now()}`,
            functionName,
            file,
            result: { nodes: cfgNodes, edges: cfgEdges },
            expanded: true,
            pos: { x: 24 + panels.length * 32, y: 24 + panels.length * 32 },
            dragging: false,
            dragOffset: { x: 0, y: 0 },
            width: STYLES.CFG_PANEL.WIDTH,
            height: STYLES.CFG_PANEL.HEIGHT,
          },
        ]);
        setCfgMessage(null);
      } catch (e: any) {
        setCfgMessage('API Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. error: ' + e.message);
      } finally {
        setCfgLoading(false);
      }
    }, [nodes, selectedNodeId, cfgPanels, apiUrl]);

    const hydrate = useCallback((json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>) => {
      const nodeWidths: Record<string, number> = {};
      const nodeFont = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`;

      Object.values(json).forEach(data => {
        data.nodes.forEach(node => {
          const label = node.label || node.function_name || node.id;
          nodeWidths[node.id] = calculateNodeWidth(label);
        });
      });

      let allFunctionNodes: Node[] = [];
      let allRawEdges: RawEdge[] = [];

      Object.entries(json).forEach(([file, data]) => {
        const functionNodes = data.nodes.map(n => ({
          id: n.id,
          data: { label: n.label || n.function_name || n.id, file: n.file },
          position: { x: 0, y: 0 },
          style: {
            padding: '6px 8px',
            borderRadius: 4,
            border: '1px solid #3b82f6',
            background: '#fff',
            width: nodeWidths[n.id],
            fontSize: STYLES.NODE.FONT_SIZE,
            fontFamily: STYLES.NODE.FONT_FAMILY,
          },
          zIndex: 1,
        }));
        allFunctionNodes = allFunctionNodes.concat(functionNodes);
        allRawEdges = allRawEdges.concat(data.edges);
      });

      const nodeIds = new Set(allFunctionNodes.map(n => n.id));
      const allEdges: Edge[] = allRawEdges
        .filter(e => nodeIds.has(e.source) && nodeIds.has(e.target))
        .map(e => ({
          id: e.id,
          source: e.source,
          target: e.target,
          markerEnd: {
            type: MarkerType.ArrowClosed,
            width: 15,
            height: 15,
            color: STYLES.COLORS.EDGE.DEFAULT,
          },
          animated: true,
          style: { stroke: STYLES.COLORS.EDGE.DEFAULT, strokeWidth: 2 },
          zIndex: 10000,
          type: 'step',
        }));

      const posMap = calculateLayout(json, nodeWidths);
      const laidOutNodes = allFunctionNodes.map(n => ({
        ...n,
        position: posMap[n.id] ?? { x: 0, y: 0 },
      }));

      const groupNodes: Node[] = [];
      const fileToNodes: Record<string, Node[]> = {};

      laidOutNodes.forEach(node => {
        const file = (node.data as any).file;
        if (!fileToNodes[file]) fileToNodes[file] = [];
        fileToNodes[file].push(node);
      });

      Object.entries(fileToNodes).forEach(([file, nodesInGroup]) => {
        if (nodesInGroup.length === 0) return;

        const xs = nodesInGroup.map(n => n.position.x);
        const ys = nodesInGroup.map(n => n.position.y);
        const minX = Math.min(...xs);
        const minY = Math.min(...ys);
        const maxX = Math.max(...nodesInGroup.map(n => n.position.x + ((n.style?.width as number) || STYLES.NODE.MIN_WIDTH)));
        const maxY = Math.max(...nodesInGroup.map(n => n.position.y + ((n.style?.height as number) || STYLES.NODE.HEIGHT.DEFAULT)));

        const groupId = `group-${file.replace(/[^a-zA-Z0-9]/g, '_')}`;
        groupNodes.push({
          id: groupId,
          type: 'group',
          data: {
            label: file.split('/').pop() || file,
            file: file
          },
          position: { x: minX - STYLES.GROUP.PADDING, y: minY - STYLES.GROUP.PADDING },
          style: {
            width: maxX - minX + 2 * STYLES.GROUP.PADDING,
            height: maxY - minY + 2 * STYLES.GROUP.PADDING,
            background: 'rgba(0, 0, 0, 0.05)',
            border: '1px dashed #fb923c',
            borderRadius: 8,
          },
          zIndex: 0,
        });

        nodesInGroup.forEach(node => {
          node.position = {
            x: node.position.x - (minX - STYLES.GROUP.PADDING),
            y: node.position.y - (minY - STYLES.GROUP.PADDING),
          };
          node.parentId = groupId;
          node.extent = 'parent';
        });
      });

      setNodes([...groupNodes, ...laidOutNodes]);
      setEdges(allEdges);
    }, []);

    useEffect(() => {
      if (!diagramReady) return;

      (async () => {
        if (diagramCache) {
          hydrate(diagramCache);
          setLoading(false);
          return;
        }

        setLoading(true);
        setError(undefined);

        try {
          const res = await fetch(`${apiUrl}${ENDPOINTS.CG}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: `../../${TARGET_FOLDER}`, file_type: 'py' }),
          });

          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

          const data = await res.json();
          const json = parseApiResponse(data);
          diagramCache = json;
          hydrate(json);
        } catch (e: any) {
          setError(String(e));
          setNodes([]);
          setEdges([]);
        } finally {
          setLoading(false);
        }
      })();
    }, [diagramReady, apiUrl, hydrate]);

    const processedEdges = useMemo(() => {
      const processed = edges.map(e => {
        const sourceRep = findRepresentativeNode(e.source, collapsedGroups, nodes);
        const targetRep = findRepresentativeNode(e.target, collapsedGroups, nodes);

        if (sourceRep === targetRep && collapsedGroups.has(sourceRep)) {
          return { ...e, hidden: true };
        }

        const isRedirected = sourceRep !== e.source || targetRep !== e.target;
        const finalEdge = isRedirected ? {
          ...e,
          id: `${e.id}_redirected_${sourceRep}_${targetRep}`,
          source: sourceRep,
          target: targetRep,
          data: {
            ...e.data,
            originalSource: e.source,
            originalTarget: e.target,
            isRedirected: true,
          },
        } : e;

        const isHover = hoveredEdgeId === finalEdge.id;

        return {
          ...finalEdge,
          hidden: false,
          style: {
            ...(finalEdge.style || {}),
            stroke: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
            strokeWidth: isHover ? 4 : (isRedirected ? 3 : 2),
            strokeDasharray: isRedirected ? '5 5' : undefined,
            transition: 'all 0.13s',
            cursor: 'pointer',
          },
          markerEnd: {
            ...(finalEdge.markerEnd || {}),
            color: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
          },
          zIndex: isRedirected ? 10001 : 10000,
        };
      });

      const seen = new Map<string, Edge>();
      processed.forEach(edge => {
        const key = `${edge.source}-${edge.target}`;
        if (!seen.has(key) || edge.data?.isRedirected) {
          seen.set(key, edge);
        }
      });

      return Array.from(seen.values());
    }, [edges, collapsedGroups, nodes, hoveredEdgeId]);

    const finalNodes = useMemo(() => {
      return nodes.map(n => {
        const cleanPath = cleanFilePath((n.data as any)?.file || '', TARGET_FOLDER);
        const isActive = cleanPath === activePath;
        const isHover = hoverId === n.id;
        const isSelected = selectedNodeId === n.id;
        const isGroup = n.type === 'group';
        const isCollapsed = isGroup && collapsedGroups.has(n.id);
        const isHidden = !isGroup && isNodeHidden(n.id, collapsedGroups, nodes);

        return {
          ...n,
          type: isGroup ? 'group' : (n.type || 'default'),
          hidden: isHidden,
          style: {
            ...n.style,
            background: isGroup
              ? isCollapsed
                ? STYLES.COLORS.GROUP.COLLAPSED
                : isHover
                  ? STYLES.COLORS.NODE.HOVER
                  : isSelected
                    ? STYLES.COLORS.NODE.SELECTED
                    : isActive
                      ? STYLES.COLORS.NODE.ACTIVE
                      : STYLES.COLORS.GROUP.DEFAULT
              : isHover
                ? STYLES.COLORS.NODE.HOVER
                : isSelected
                  ? STYLES.COLORS.NODE.SELECTED
                  : isActive
                    ? STYLES.COLORS.NODE.ACTIVE
                    : STYLES.COLORS.NODE.DEFAULT,
            border: isGroup
              ? isCollapsed
                ? `2px solid ${STYLES.COLORS.GROUP.BORDER_COLLAPSED}`
                : isHover
                  ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
                  : isActive
                    ? `1px solid ${STYLES.COLORS.GROUP.BORDER_ACTIVE}`
                    : `1px solid ${STYLES.COLORS.GROUP.BORDER}`
              : isHover
                ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
                : isSelected
                  ? `4px solid ${STYLES.COLORS.NODE.BORDER_SELECTED}`
                  : isActive
                    ? `1px solid ${STYLES.COLORS.NODE.BORDER_ACTIVE}`
                    : `1px solid ${STYLES.COLORS.NODE.BORDER}`,
            transition: 'all 0.1s ease-in-out',
            minWidth: isGroup ? (isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : undefined) : (n.style?.width as number),
            width: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : n.style?.width,
            height: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_HEIGHT : n.style?.height,
            cursor: isGroup && isCollapsed ? 'pointer' : 'default',
          },
          data: isGroup
            ? {
              ...n.data,
              isCollapsed,
              onToggleCollapse: () => toggleCollapse(n.id),
            }
            : n.data,
        };
      });
    }, [nodes, activePath, hoverId, selectedNodeId, collapsedGroups, toggleCollapse]);

    if (!diagramReady) {
      return (
        <div className="flex items-center justify-center h-full w-full">
          <button
            onClick={() => setDiagramReady(true)}
            className="min-w-[180px] px-8 py-3 rounded-lg bg-white text-gray-700 font-semibold text-lg border border-gray-300 shadow-sm hover:bg-gray-50 hover:border-indigo-500 hover:text-indigo-700 transition-all"
          >
            <span className="inline-block mr-2 text-indigo-500">‚ñ∂</span>
            Generate Diagram
          </button>
        </div>
      );
    }

    if (loading) {
      return (
        <div className="flex items-center justify-center h-full w-full">
          <svg className="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" />
          </svg>
          <span className="ml-3 text-sm text-slate-500">diagram loading‚Ä¶</span>
        </div>
      );
    }

    if (error) {
      return <div className="p-4 text-sm text-red-600 whitespace-pre-wrap">{error}</div>;
    }

    return (
      <div className="relative h-full w-full border-l border-slate-300">
        <ReactFlow
          nodes={finalNodes}
          edges={processedEdges}
          onNodesChange={(changes) => setNodes(nds => applyNodeChanges(changes, nds))}
          onNodeClick={onNodeClick}
          onNodeMouseEnter={onNodeMouseEnter}
          onNodeMouseLeave={onNodeMouseLeave}
          onEdgeMouseEnter={(_, edge) => setHoveredEdgeId(edge.id)}
          onEdgeMouseLeave={() => setHoveredEdgeId(null)}
          fitView
          minZoom={0.2}
          maxZoom={2}
          className="bg-gray-50"
          nodeTypes={{ group: CustomGroupNode }}
          onPaneClick={() => {
            setSelectedNodeId(null);
            setCfgMessage(null);
          }}
        >
          <Background variant="dots" gap={16} size={1} />
          <MiniMap
            pannable
            zoomable
            nodeColor={n => {
              if (n.type === 'group') return collapsedGroups.has(n.id) ? '#6b7280' : '#bdbdbd';
              const bg = n.style?.background;
              return bg === STYLES.COLORS.NODE.HOVER ? '#facc15' :
                bg === STYLES.COLORS.NODE.ACTIVE ? '#0284c7' : '#2563eb';
            }}
            nodeStrokeColor={n => {
              if (n.type === 'group') return collapsedGroups.has(n.id) ? '#374151' : '#757575';
              const border = n.style?.border;
              return border?.includes(STYLES.COLORS.NODE.BORDER_HOVER) ? STYLES.COLORS.NODE.BORDER_HOVER :
                border?.includes(STYLES.COLORS.NODE.BORDER_ACTIVE) ? STYLES.COLORS.NODE.BORDER_ACTIVE : '#1e40af';
            }}
            nodeStrokeWidth={2}
            maskColor="rgba(255,255,255,0.7)"
            style={{
              background: '#f3f4f6',
              border: '1.5px solid #cbd5e1',
              borderRadius: 6,
              boxShadow: '0 2px 8px #0002',
            }}
          />
          <Controls>
            <button
              type="button"
              title="Re-layout"
              onClick={() => diagramCache && hydrate(diagramCache)}
              className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow"
            >
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                <rect x="2" y="2" width="4" height="4" rx="1" fill="#222" />
                <rect x="10" y="2" width="4" height="4" rx="1" fill="#222" />
                <rect x="2" y="10" width="4" height="4" rx="1" fill="#222" />
                <rect x="6" y="6" width="4" height="4" rx="1" fill="#222" />
                <rect x="10" y="10" width="4" height="4" rx="1" fill="#222" />
              </svg>
            </button>
            <button
              type="button"
              title="Generate Control Flow Graph"
              onClick={handleGenerateCFG}
              disabled={cfgLoading}
              className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow relative disabled:cursor-not-allowed"
            >
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style={{ opacity: cfgLoading ? 0.3 : 1 }}>
                <circle cx="6" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <circle cx="14" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <circle cx="10" cy="14" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <line x1="7.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
                <line x1="12.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
                <line x1="8.2" y1="6" x2="11.8" y2="6" stroke="#222" strokeWidth="1.2" />
                <g>
                  <circle cx="16.5" cy="16.5" r="3.2" fill="#222" />
                  <rect x="16" y="14.2" width="1" height="4.6" rx="0.5" fill="#fff" />
                  <rect x="14.2" y="16" width="4.6" height="1" rx="0.5" fill="#fff" />
                </g>
              </svg>
              {cfgLoading && (
                <span className="absolute inset-0 flex items-center justify-center bg-white/70 rounded">
                  <svg className="animate-spin" width="16" height="16" viewBox="0 0 16 16">
                    <circle cx="8" cy="8" r="6" stroke="#0284c7" strokeWidth="2" fill="none" strokeDasharray="28" strokeDashoffset="10" />
                  </svg>
                </span>
              )}
            </button>
          </Controls>
        </ReactFlow>

        {cfgMessage && (
          <div className="absolute top-[60px] right-6 bg-red-100 text-red-800 px-4 py-2 rounded-md z-[100] text-sm shadow-md">
            {cfgMessage}
          </div>
        )}

        {cfgPanels.map((panel, idx) => (
          <CFGPanelComponent
            key={panel.id}
            panel={panel}
            index={idx}
            onUpdate={handleCFGPanelUpdate}
            onClose={handleCFGPanelClose}
            onNodeHover={handleCFGNodeHover}
            message={cfgPanelMessage}
          />
        ))}

        {hoverId && snippet && (
          <div
            className="fixed z-50 top-4 right-4 min-w-[320px] max-w-[40vw] min-h-[40px] max-h-[80vh] bg-gray-50 text-slate-800 text-xs rounded-lg shadow-lg p-4 overflow-auto font-mono pointer-events-none"
            dangerouslySetInnerHTML={{ __html: `<pre class="hljs">${snippet}</pre>` }}
          />
        )}
      </div>
    );
  }

  // CFG Panel Component
  function CFGPanelComponent({
    panel,
    index,
    onUpdate,
    onClose,
    onNodeHover,
    message,
  }: {
    panel: CFGPanel;
    index: number;
    onUpdate: (id: string, updates: Partial<CFGPanel>) => void;
    onClose: (id: string) => void;
    onNodeHover: (node: Node | null, panel: CFGPanel) => void;
    message?: string | null;
  }) {
    const [isDragging, setIsDragging] = useState(false);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
      if ((e.target as HTMLElement).closest('button')) return;

      const startX = e.clientX;
      const startY = e.clientY;
      const origX = panel.pos.x;
      const origY = panel.pos.y;

      setIsDragging(true);
      onUpdate(panel.id, { dragging: true });

      const onMouseMove = (moveEvent: MouseEvent) => {
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;

        const newX = origX - dx;
        const newY = origY + dy;

        const panelWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
        const panelHeight = panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : 44;

        const boundedX = Math.max(20, Math.min(newX, window.innerWidth - panelWidth - 20));
        const boundedY = Math.max(20, Math.min(newY, window.innerHeight - panelHeight - 20));

        onUpdate(panel.id, { pos: { x: boundedX, y: boundedY } });
      };

      const onMouseUp = () => {
        setIsDragging(false);
        onUpdate(panel.id, { dragging: false });
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      e.preventDefault();
    }, [panel, onUpdate]);

    const handleResize = useCallback((e: React.MouseEvent) => {
      e.preventDefault();
      const startX = e.clientX;
      const startY = e.clientY;
      const startWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
      const startHeight = panel.height ?? STYLES.CFG_PANEL.HEIGHT;

      onUpdate(panel.id, { resizing: true });

      const onMouseMove = (moveEvent: MouseEvent) => {
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;

        const newWidth = Math.max(300, Math.min(1600, startWidth + dx));
        const newHeight = Math.max(200, Math.min(1200, startHeight + dy));

        onUpdate(panel.id, { width: newWidth, height: newHeight });
      };

      const onMouseUp = () => {
        onUpdate(panel.id, { resizing: false });
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    }, [panel, onUpdate]);

    return (
      <div
        style={{
          position: 'fixed',
          top: panel.pos.y,
          right: panel.pos.x,
          background: '#f1f5f9',
          color: '#222',
          padding: panel.expanded ? '12px 18px 18px 18px' : '8px 18px',
          borderRadius: 8,
          zIndex: 200 + index,
          fontSize: 13,
          minWidth: 220,
          maxWidth: 1600,
          maxHeight: panel.expanded ? 1200 : 44,
          boxShadow: '0 2px 8px #0002',
          overflow: panel.expanded ? 'auto' : 'hidden',
          transition: 'all 0.2s cubic-bezier(.4,2,.6,1)',
          display: 'flex',
          flexDirection: 'column',
          cursor: isDragging ? 'move' : 'default',
          userSelect: isDragging ? 'none' : 'auto',
          width: panel.width ?? STYLES.CFG_PANEL.WIDTH,
          height: panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : undefined,
        }}
      >
        {message && (
          <div
            style={{
              position: 'absolute',
              top: 8,
              right: 12,
              zIndex: 300,
              fontSize: 13,
              fontWeight: 500,
              pointerEvents: 'none',
              maxWidth: 340,
            }}
            dangerouslySetInnerHTML={{ __html: message }}
          />
        )}

        <div
          style={{
            width: '100%',
            minHeight: 28,
            display: 'flex',
            alignItems: 'center',
            fontWeight: 600,
            fontSize: 13,
            color: '#555',
            userSelect: 'none',
            marginBottom: panel.expanded ? 8 : 0,
            gap: 4,
            cursor: 'move',
          }}
          onMouseDown={handleMouseDown}
        >
          <span style={{ flex: 1 }}>
            CFG ({panel.functionName}
            {panel.file && <> @ {panel.file.split(/[\\/]/).pop()}</>})
          </span>
          <button
            onClick={e => {
              e.stopPropagation();
              onUpdate(panel.id, { expanded: !panel.expanded });
            }}
            style={{
              background: 'transparent',
              border: 'none',
              color: '#888',
              cursor: 'pointer',
              padding: 0,
              width: 24,
              height: 24,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              transition: 'transform 0.15s',
              transform: panel.expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
            }}
            aria-label={panel.expanded ? 'Collapse' : 'Expand'}
          >
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <path d="M4 6l4 4 4-4" stroke="#888" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
            </svg>
          </button>
          <button
            onClick={e => {
              e.stopPropagation();
              onClose(panel.id);
            }}
            style={{
              background: 'transparent',
              border: 'none',
              color: '#888',
              cursor: 'pointer',
              padding: 0,
              width: 24,
              height: 24,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
            aria-label="Close"
          >
            √ó
          </button>
        </div>

        {panel.expanded && (
          <div style={{ width: '100%', height: panel.height ?? STYLES.CFG_PANEL.HEIGHT, overflow: 'auto', position: 'relative' }}>
            {panel.result?.nodes && panel.result?.edges ? (
              <div style={{ width: '100%', height: '100%', background: '#f8fafc', borderRadius: 6 }}>
                <ReactFlow
                  nodes={panel.result.nodes}
                  edges={panel.result.edges}
                  fitView
                  minZoom={0.2}
                  maxZoom={2}
                  className="bg-gray-50"
                  style={{ width: '100%', height: '100%' }}
                  defaultViewport={{ x: 0, y: 0, zoom: 1.2 }}
                  onNodeMouseEnter={(_, node) => onNodeHover(node, panel)}
                  onNodeMouseLeave={() => onNodeHover(null, panel)}
                >
                  <Background variant="dots" gap={16} size={1} />
                  <Controls showInteractive={false} />
                </ReactFlow>
              </div>
            ) : (
              <pre style={{
                margin: 0,
                fontSize: 13,
                background: 'none',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
                maxWidth: 560,
                maxHeight: 520,
                padding: 0,
              }}>
                {typeof panel.result === 'string' ? panel.result : JSON.stringify(panel.result, null, 2)}
              </pre>
            )}

            <div
              style={{
                position: 'absolute',
                right: 2,
                bottom: 2,
                width: 18,
                height: 18,
                cursor: 'nwse-resize',
                zIndex: 10,
                userSelect: 'none',
              }}
              onMouseDown={handleResize}
            >
              <svg width="18" height="18" style={{ pointerEvents: 'none' }}>
                <polyline points="4,18 18,4" stroke="#888" strokeWidth="2" fill="none" />
                <rect x="12" y="12" width="5" height="5" fill="#e5e7eb" stroke="#888" strokeWidth="1" />
              </svg>
            </div>
          </div>
        )}
      </div>
    );
  }

  // Helper function
  function findByPath(nodes: FileNode[] = [], p: string): FileNode | undefined {
    const regex = new RegExp(`^${process.env.NEXT_PUBLIC_TARGET_FOLDER}[\\\\/]`);
    for (const n of nodes) {
      if (n.path?.replace(regex, '') === p) return n;
      if (n.children) {
        const r = findByPath(n.children, p);
        if (r) return r;
      }
    }
  }

  [src/components/EditorTabs.tsx]
  'use client';

  import { useEffect, useState } from 'react';
  import Editor from '@monaco-editor/react';
  import { useEditor } from '@/store/editor';

  function CodePane({
    path,
    highlights,
    highlight,
  }: {
    path: string;
    highlights?: { line: number; query: string };
    highlight?: { from: number; to: number };
  }) {
    const [code, setCode] = useState('// loading‚Ä¶');
    const [err, setErr] = useState<string>();
    const [editor, setEditor] = useState<any>(null);

    useEffect(() => {
      let active = true;
      (async () => {
        const res = await fetch(`/api/file?path=${encodeURIComponent(path)}`);
        if (!active) return;

        if (res.ok) {
          setCode(await res.text());
        } else {
          const { error } = await res.json().catch(() => ({ error: res.statusText }));
          setErr(`${res.status}: ${error}`);
        }
      })();
      return () => {
        active = false;
      };
    }, [path]);

    useEffect(() => {
      if (!editor) return;

      // Remove all decorations first
      editor.deltaDecorations(
        editor.__currentDecorations || [],
        []
      );
      let decorations: any[] = [];

      // Highlight search results
      if (highlights) {
        const { line, query } = highlights;
        editor.revealLineInCenter(line);
        decorations.push({
          range: new monaco.Range(line, 1, line, 1),
          options: { isWholeLine: true, className: 'highlight-line' },
        });
        const matches = editor.getModel().findMatches(query, true, false, true, null, true);
        decorations = decorations.concat(
          matches.map((match) => ({
            range: match.range,
            options: { inlineClassName: 'highlight-text' },
          }))
        );
      }
      console.log('highlight', highlight);
      // Highlight range
      if (highlight && highlight.from !== undefined && highlight.to !== undefined) {
        const model = editor.getModel();
        if (model) {
          const line_start = highlight.from;
          const line_end = highlight.to;
          decorations.push({
            range: new monaco.Range(
              line_start,
              1,
              line_end,
              1
            ),
            options: { isWholeLine: true, className: 'highlight-line' },
          });
        }
      }

      editor.__currentDecorations = editor.deltaDecorations(
        editor.__currentDecorations || [],
        decorations
      );
    }, [editor, highlights, highlight]);

    const lang = (() => {
      if (path.endsWith('.py')) return 'python';
      if (path.endsWith('.tsx') || path.endsWith('.ts')) return 'typescript';
      if (path.endsWith('.md')) return 'markdown';
      return 'plaintext';
    })();

    if (err) {
      return (
        <pre className="p-4 text-sm text-red-600 whitespace-pre-wrap">{err}</pre>
      );
    }

    return (
      <Editor
        height="calc(100% - 2rem)"
        defaultLanguage={lang}
        value={code}
        theme="vs"
        onMount={(editor) => setEditor(editor)}
        options={{
          readOnly: true,
          fontSize: 11.5,
          minimap: { enabled: true },
          automaticLayout: true,
          wordWrap: 'on',
        }}
      />
    );
  }

  export default function EditorTabs() {
    const { tabs, activeId, setActive, close, searchHighlights, highlight } = useEditor();

    if (!tabs.length) {
      return (
        <div className="h-full flex items-center justify-center text-sm text-slate-500">
          Open a file to begin
        </div>
      );
    }

    const active = tabs.find((t) => t.id === activeId) ?? tabs[0];

    return (
      <div className="flex flex-col h-full">
        {/* ‚≠êÔ∏è ÌÉ≠ Î∞îÏóê Ïä§ÌÅ¨Î°§ Ï∂îÍ∞Ä */}
        <div
          className="h-8 flex items-center bg-slate-200 border-b border-slate-300 select-none overflow-x-auto"
          style={{ whiteSpace: 'nowrap' }}
        >
          <div className="flex flex-row flex-nowrap">
            {tabs.map((t) => {
              const on = t.id === active.id;
              return (
                <div
                  key={t.id}
                  onClick={() => setActive(t.id)}
                  className={
                    'h-full flex items-center px-3 text-xs cursor-pointer border-r border-slate-300 transition-colors ' +
                    (on
                      ? 'bg-white text-sky-700 font-semibold border-b-2 border-b-sky-600'
                      : 'text-slate-600 hover:bg-slate-100 border-b-2 border-b-transparent')
                  }
                  style={{ flex: '0 0 auto' }} // ‚≠êÔ∏è ÌÉ≠Ïù¥ Ï§ÑÎ∞îÍøàÎêòÏßÄ ÏïäÎèÑÎ°ù
                >
                  {t.name}
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      close(t.id);
                    }}
                    className="ml-2 text-slate-400 hover:text-slate-600 transition-colors"
                  >
                    √ó
                  </button>
                </div>
              );
            })}
          </div>
        </div>
        <div className="flex-1">
          <CodePane path={active.path} highlights={searchHighlights} highlight={highlight} />
        </div>
      </div>
    );
  }

  [src/components/FileExplorer.tsx]
  'use client';

  import { useEffect, useState } from 'react';
  import clsx from 'clsx';
  import { useFS, FileNode } from '@/store/files';
  import { useEditor } from '@/store/editor';
  import { nanoid } from 'nanoid';

  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER ?? 'study1/face_classification';

  function filterTree(nodes: FileNode[] = []): FileNode[] {
    return nodes
      .filter((n) => n.name !== '__pycache__' && n.name !== '.DS_Store')
      .sort((a, b) => {
        const aIsDir = Array.isArray(a.children);
        const bIsDir = Array.isArray(b.children);
        if (aIsDir && !bIsDir) return -1;
        if (!aIsDir && bIsDir) return 1;
        return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
      })
      .map((n) =>
        Array.isArray(n.children)
          ? { ...n, children: filterTree(n.children) }
          : n
      );
  }

  const arr = (x: FileNode[] | FileNode | undefined): FileNode[] =>
    Array.isArray(x) ? x : x ? [x] : [];

  function getIcon(n: FileNode, isDir: boolean, isOpen: boolean) {
    if (isDir) {
      // VSCode Ïä§ÌÉÄÏùº Ìè¥Îçî ÏïÑÏù¥ÏΩò (Ïó¥Î¶º/Îã´Ìûò)
      return isOpen ? (
        <svg
          width="16"
          height="16"
          viewBox="0 0 16 16"
          style={{ marginRight: 4, display: 'inline' }}
          fill="none"
        >
          <path
            d="M2 4.5A1.5 1.5 0 0 1 3.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H13a1 1 0 0 1 1 1v6.5A1.5 1.5 0 0 1 12.5 14h-9A1.5 1.5 0 0 1 2 12.5v-8Z"
            fill="#eab308"
            stroke="#b45309"
            strokeWidth="0.7"
          />
        </svg>
      ) : (
        <svg
          width="16"
          height="16"
          viewBox="0 0 16 16"
          style={{ marginRight: 4, display: 'inline' }}
          fill="none"
        >
          <rect
            x="2"
            y="4"
            width="12"
            height="8"
            rx="1.5"
            fill="#fde68a"
            stroke="#b45309"
            strokeWidth="0.7"
          />
          <path
            d="M5.5 3h2.38a1.5 1.5 0 0 1 1.06.44l.62.62A1.5 1.5 0 0 0 8.62 5H2V4.5A1.5 1.5 0 0 1 3.5 3h2Z"
            fill="#fbbf24"
            stroke="#b45309"
            strokeWidth="0.7"
          />
        </svg>
      );
    }
    if (n.name.endsWith('.py')) {
      // Python ÏïÑÏù¥ÏΩò (Ïã¨Ìîå)
      return (
        <svg
          width="16"
          height="16"
          viewBox="0 0 32 32"
          style={{ marginRight: 4, display: 'inline' }}
          fill="none"
        >
          <rect x="4" y="7" width="24" height="18" rx="6" fill="#3776AB" />
          <rect x="4" y="7" width="24" height="9" rx="4.5" fill="#FFD43B" />
          <circle cx="10" cy="12" r="1.5" fill="#222" />
          <circle cx="22" cy="20" r="1.5" fill="#fff" />
        </svg>
      );
    }
    // Í∏∞Î≥∏ ÌååÏùº ÏïÑÏù¥ÏΩò
    return (
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        style={{ marginRight: 4, display: 'inline' }}
        fill="none"
      >
        <rect
          x="3"
          y="2"
          width="10"
          height="12"
          rx="2"
          fill="#e5e7eb"
          stroke="#94a3b8"
          strokeWidth="0.7"
        />
        <rect x="5" y="5" width="6" height="1" rx="0.5" fill="#94a3b8" />
        <rect x="5" y="8" width="6" height="1" rx="0.5" fill="#94a3b8" />
      </svg>
    );
  }

  function Row({
    n,
    depth,
    isDir,
    isOpen,
    isActive,
    onClick,
  }: {
    n: FileNode;
    depth: number;
    isDir: boolean;
    isOpen: boolean;
    isActive: boolean;
    onClick: () => void;
  }) {
    return (
      <div
        style={{ paddingLeft: depth * 12 }}
        className={clsx(
          'cursor-pointer select-none text-xs py-[2px] px-1',
          'hover:bg-slate-100 transition-colors',
          isActive && 'bg-sky-100 text-sky-700'
        )}
        onClick={onClick}
      >
        {getIcon(n, isDir, isOpen)}
        {n.name}
      </div>
    );
  }

  export default function FileExplorer() {
    const { tree, current, setCurrent, load } = useFS();
    const [open, setOpen] = useState<Record<string, boolean>>({ [TARGET_FOLDER]: true });
    const { activePath } = useEditor();

    useEffect(() => {
      (async () => {
        const data: FileNode[] = await fetch('/api/files').then((r) => r.json());
        const filteredTree = filterTree(data);
        load(filteredTree);
        useFS.getState().loadContents(); // ÌååÏùº ÎÇ¥Ïö© Î°úÎìú
      })();
    }, [load]);

    const click = (n: FileNode) => {
      if (Array.isArray(n.children)) {
        setOpen((o) => ({ ...o, [n.path ?? '']: !o[n.path ?? ''] }));
      } else if (n.path) {
        const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
        const clean = n.path.replace(regex, '');
        setCurrent(n.id);
        useEditor.getState().open({
          id: nanoid(),
          path: clean,
          name: n.name,
        });
      }
    };

    const render = (nodes: FileNode[] | FileNode | undefined, depth = 0): JSX.Element[] =>
      arr(nodes).map((n) => {
        const isDir = Array.isArray(n.children);
        const isOpen = !!open[n.path ?? ''];
        const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);
        const isActive = n.path?.replace(regex, '') === activePath;

        return (
          <div key={n.id}>
            <Row
              n={n}
              depth={depth}
              isDir={isDir}
              isOpen={isOpen}
              isActive={isActive}
              onClick={() => click(n)}
            />
            {isDir && isOpen && render(n.children, depth + 1)}
          </div>
        );
      });

    return (
      <aside className="w-full pl-2 h-full overflow-y-auto border-r border-slate-300 bg-slate-50">
        {render(tree)}
      </aside>
    );
  }

  [src/components/IconBar.tsx]
  import {
    FolderIcon,
    MagnifyingGlassIcon,
    Squares2X2Icon,
    ChatBubbleLeftRightIcon,
  } from '@heroicons/react/24/outline';
  import type { ComponentType, SVGProps } from 'react';

  type IconType = ComponentType<SVGProps<SVGSVGElement>>;
  interface Props {
    states?: {
      explorer?: boolean;
      search?: boolean;
      diagram?: boolean;
      chat?: boolean;
    };
    toggle?: {
      explorer?: () => void;
      search?: () => void;
      diagram?: () => void;
      chat?: () => void;
    };
  }

  export default function IconBar({ states = {}, toggle = {} }: Props) {
    const Btn = ({
      on = false,
      click = () => {},
      Icon,
    }: {
      on?: boolean;
      click?: () => void;
      Icon: IconType;
    }) => (
      <button
        onClick={click}
        className={
          'w-10 h-10 flex items-center justify-center transition-colors ' +
          (on ? 'bg-white' : 'hover:bg-slate-100')
        }
      >
        <Icon className={'w-6 ' + (on ? 'stroke-sky-600' : 'stroke-slate-600')} />
      </button>
    );

    return (
      <div className="flex flex-col border-r border-slate-300 bg-slate-200">
        <Btn on={states.explorer} click={toggle.explorer} Icon={FolderIcon} />
        <Btn on={states.search} click={toggle.search} Icon={MagnifyingGlassIcon} />
        <Btn on={states.diagram} click={toggle.diagram} Icon={Squares2X2Icon} />
        <Btn on={states.chat} click={toggle.chat} Icon={ChatBubbleLeftRightIcon} />
      </div>
    );
  }

  [src/components/SearchPanel.tsx]
  'use client';

  import { useState, useEffect, useMemo } from 'react';
  import { useEditor } from '@/store/editor';
  import { nanoid } from 'nanoid';
  import { useFS, getAllFilePaths } from '@/store/files';

  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

  // ÌÉÄÏûÖ Ï†ïÏùò: Í≤ÄÏÉâ Í≤∞Í≥ºÎäî ÌååÏùº, ÎùºÏù∏, ÎùºÏù∏ ÌÖçÏä§Ìä∏
  type SearchResult = {
    file: string;
    line: number;
    text: string;
  };

  export default function SearchPanel() {
    const [query, setQuery] = useState('');
    const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
    const [expandedFiles, setExpandedFiles] = useState<{ [file: string]: boolean }>({});
    const { tree, fileContents } = useFS();

    const allFiles = useMemo(() => getAllFilePaths(tree, false), [tree]); // Ìè¥Îçî Ï†úÏô∏, ÌååÏùºÎßå

    useEffect(() => {
      if (!query.trim()) {
        setSearchResults([]);
        return;
      }
      const results: SearchResult[] = [];
      for (const file of allFiles) {
        const content = fileContents[file];
        if (!content) continue;
        const lines = content.split('\n');
        lines.forEach((lineText, idx) => {
          if (lineText.toLowerCase().includes(query.toLowerCase())) {
            results.push({
              file,
              line: idx + 1,
              text: lineText.trim(),
            });
          }
        });
      }
      setSearchResults(results);
    }, [query, allFiles, fileContents]);

    // ÌååÏùºÎ≥ÑÎ°ú Í≤∞Í≥ºÎ•º Í∑∏Î£πÌôî
    const groupedResults = useMemo(() => {
      const groups: { [file: string]: SearchResult[] } = {};
      for (const result of searchResults) {
        if (!groups[result.file]) groups[result.file] = [];
        groups[result.file].push(result);
      }
      return groups;
    }, [searchResults]);

    // Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä Î∞îÎÄåÎ©¥ Î™®Îì† ÌååÏùºÏùÑ expand
    useEffect(() => {
      const initial: { [file: string]: boolean } = {};
      Object.keys(groupedResults).forEach((file) => {
        initial[file] = true;
      });
      setExpandedFiles(initial);
    }, [groupedResults]);

    const handleToggleFile = (file: string) => {
      setExpandedFiles((prev) => ({
        ...prev,
        [file]: !prev[file],
      }));
    };

    const handleResultClick = (result: SearchResult) => {
      const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

      const cleanPath = result.file.replace(regex, '');
      const name = cleanPath.split('/').pop() || cleanPath;
      const editorState = useEditor.getState();
      editorState.open({
        id: nanoid(),
        path: cleanPath,
        name,
      });
      // Í≤ÄÏÉâÏñ¥Í∞Ä ÏûàÏúºÎ©¥ ÌïòÏù¥ÎùºÏù¥Ìä∏Î•º ÏúÑÌï¥ Ï†ÄÏû•
      if (query.trim()) {
        editorState.setSearchHighlights(result.line, query);
      }
    };

    return (
      <div className="w-full h-full p-2 bg-slate-50 border-r border-slate-300">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search in all files..."
          className="w-full p-2 mb-2 border rounded"
        />
        <div className="overflow-y-auto max-h-[calc(100%-2rem)]">
          {query.trim() === '' ? (
            <p className="text-xs text-gray-500">Enter a keyword</p>
          ) : searchResults.length > 0 ? (
            Object.entries(groupedResults).map(([file, results]) => (
              <div key={file} className="mb-2">
                <div
                  className="font-mono text-xs font-semibold text-slate-700 mb-1 flex items-center cursor-pointer select-none"
                  onClick={() => handleToggleFile(file)}
                >
                  <span className="mr-1">
                    {expandedFiles[file] ? '‚ñº' : '‚ñ∂'}
                  </span>
                  {file}
                  <span className="ml-2 text-slate-400">({results.length})</span>
                </div>
                {expandedFiles[file] && results.map((result, i) => (
                  <div
                    key={i}
                    onClick={() => handleResultClick(result)}
                    className="text-xs py-1 px-2 hover:bg-slate-100 cursor-pointer flex"
                  >
                    <span className="text-slate-400 mr-2">:{result.line}</span>
                    <span className="truncate text-slate-600">{result.text}</span>
                  </div>
                ))}
              </div>
            ))
          ) : (
            <p className="text-xs text-gray-500">No search results found</p>
          )}
        </div>
      </div>
    );
  }

  [src/components/diagramUtils.tsx]
  import { Node, Edge, NodeProps, Handle, Position } from '@xyflow/react';
  import dagre from 'dagre';
  import hljs from 'highlight.js/lib/core';
  import python from 'highlight.js/lib/languages/python';
  import 'highlight.js/styles/atom-one-light.css';

  hljs.registerLanguage('python', python);

  // Constants
  export const ENDPOINTS = {
    CG: '/api/generate_call_graph',
    CFG: '/api/generate_control_flow_graph',
    INLINE_CODE_EXPLANATION: '/api/inline_code_explanation',
  } as const;

  export const STYLES = {
    NODE: {
      MIN_WIDTH: 60,
      PADDING: 16,
      HEIGHT: { SMALL: 35, DEFAULT: 40 },
      FONT_SIZE: '12px',
      FONT_FAMILY: 'Arial, sans-serif',
    },
    GROUP: {
      PADDING: 20, // Reduced from 40 to 20
      COLLAPSED_WIDTH: 200,
      COLLAPSED_HEIGHT: 50,
    },
    COLORS: {
      NODE: {
        DEFAULT: '#ffffff',
        HOVER: '#fef9c3',
        SELECTED: '#fca5a5',
        ACTIVE: '#dbeafe',
        BORDER: '#4A90E2',
        BORDER_HOVER: '#eab308',
        BORDER_SELECTED: '#b91c1c',
        BORDER_ACTIVE: '#0284c7',
      },
      GROUP: {
        DEFAULT: '#FAFAFA',
        COLLAPSED: '#f3f4f6',
        BORDER: '#b9bfc9',
        BORDER_COLLAPSED: '#6b7280',
        BORDER_ACTIVE: '#fb923c',
      },
      EDGE: {
        DEFAULT: '#34A853',
        HOVER: '#f59e42',
      },
    },
    CFG_PANEL: {
      WIDTH: 800,
      HEIGHT: 600,
    },
  } as const;

  // Types
  export interface RawNode {
    id: string;
    label?: string;
    function_name?: string;
    file: string;
  }

  export interface RawEdge {
    id: string;
    source: string;
    target: string;
    type?: string;
  }

  export interface CFGPanel {
    id: string;
    functionName: string;
    file: string;
    result: any;
    expanded: boolean;
    pos: { x: number; y: number };
    dragging: boolean;
    dragOffset: { x: number; y: number };
    width?: number;
    height?: number;
    resizing?: boolean;
  }

  // Cache
  export const snippetCache = new Map<string, string>();

  // Helper Functions
  export function getTextWidth(text: string, font: string = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`): number {
    if (typeof document === 'undefined') return text.length * 7;
    const canvas = (getTextWidth as any).canvas || ((getTextWidth as any).canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    if (!context) return text.length * 7;
    context.font = font;
    return context.measureText(text).width;
  }

  export function extractFunctionSnippet(code: string, functionName: string): { snippet: string, startLine: number } | null {
    const lines = code.split('\n');
    const startIndex = lines.findIndex(line => line.trim().startsWith(`def ${functionName}(`));
    if (startIndex === -1) return null;
    
    for (let i = startIndex + 1; i < lines.length; i++) {
      if (lines[i].trim() === '') continue;
      if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
        return { snippet: lines.slice(startIndex, i).join('\n'), startLine: startIndex + 1 };
      }
    }
    return { snippet: lines.slice(startIndex).join('\n'), startLine: startIndex + 1 };
  }

  export function highlightWithLineNumbers(snippet: string, startLine: number = 1): string {
    const highlighted = hljs.highlight(snippet, { language: 'python' }).value;
    const lines = highlighted.split('\n');
    const padding = String(startLine + lines.length - 1).length;
    return lines
      .map((line, idx) => `<span style="color:#64748b">${String(startLine + idx).padStart(padding, ' ')}</span>  ${line}`)
      .join('\n');
  }

  export function isNodeHidden(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): boolean {
    const node = nodes.find(n => n.id === nodeId);
    if (!node?.parentId) return false;
    return collapsedGroups.has(node.parentId) || isNodeHidden(node.parentId, collapsedGroups, nodes);
  }

  export function findRepresentativeNode(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): string {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return nodeId;
    if (node.type === 'group' || !node.parentId) return nodeId;
    if (collapsedGroups.has(node.parentId)) return node.parentId;
    
    let current = node;
    while (current.parentId) {
      const parent = nodes.find(n => n.id === current.parentId);
      if (!parent) break;
      if (parent.type === 'group' && collapsedGroups.has(parent.id)) return parent.id;
      current = parent;
    }
    return nodeId;
  }

  // Mindmap-style layout function with adjusted spacing
  export function calculateLayout(
    files: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>,
    nodeWidths: Record<string, number>
  ): Record<string, { x: number; y: number }> {
    const positions: Record<string, { x: number; y: number }> = {};
    const groupNodes = new Set<string>(); // Í∑∏Î£π ÎÖ∏Îìú Ï∂îÏ†Å
    
    // Îçî Ïª¥Ìå©Ìä∏Ìïú Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
    const LAYOUT_CONFIG = {
      HORIZONTAL_SPACING: 150,     
      VERTICAL_SPACING: 60,        
      LEVEL_RADIUS_INCREMENT: 40,  
      INITIAL_RADIUS: 50,          
      SIBLING_ANGLE_SPREAD: Math.PI * 0.15, 
      FILE_SPACING_X: 450,         // 350ÏóêÏÑú 450ÏúºÎ°ú Îçî Ï¶ùÍ∞Ä
      FILE_SPACING_Y: 400,         // 300ÏóêÏÑú 400ÏúºÎ°ú Îçî Ï¶ùÍ∞Ä
      GROUP_MIN_DISTANCE: 300,     // 200ÏóêÏÑú 300ÏúºÎ°ú Ï¶ùÍ∞Ä
    };
    
    // Í∑∏Î£π ÎÖ∏Îìú Ï∂©Îèå Í∞êÏßÄ Ìï®Ïàò (Îçî ÌÅ∞ Ïó¨Î∞± Ìè¨Ìï®)
    function isGroupColliding(pos1: { x: number; y: number }, pos2: { x: number; y: number }): boolean {
      const distance = Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
      return distance < LAYOUT_CONFIG.GROUP_MIN_DISTANCE;
    }
    
    // Í∑∏Î£π ÏúÑÏπò Ï°∞Ï†ï Ìï®Ïàò (Îçî Í∞ïÎ†•Ìïú Î∂ÑÎ¶¨ Î°úÏßÅ)
    function adjustGroupPositions() {
      const maxIterations = 50; // ÏµúÎåÄ Î∞òÎ≥µ ÌöüÏàò
      let iteration = 0;
      
      while (iteration < maxIterations) {
        const groupPositions = Object.entries(positions)
          .filter(([id]) => groupNodes.has(id))
          .map(([id, pos]) => ({ id, pos }));
        
        let hasCollision = false;
        
        for (let i = 0; i < groupPositions.length; i++) {
          for (let j = i + 1; j < groupPositions.length; j++) {
            const group1 = groupPositions[i];
            const group2 = groupPositions[j];
            
            if (isGroupColliding(group1.pos, group2.pos)) {
              hasCollision = true;
              
              const dx = group2.pos.x - group1.pos.x;
              const dy = group2.pos.y - group1.pos.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance === 0) {
                // ÏôÑÏ†ÑÌûà Í∞ôÏùÄ ÏúÑÏπòÏù∏ Í≤ΩÏö∞ Í∞ÅÎèÑ Í∏∞Î∞òÏúºÎ°ú Î∂ÑÏÇ∞
                const angle = (j * 2 * Math.PI) / groupPositions.length;
                group2.pos.x = group1.pos.x + Math.cos(angle) * LAYOUT_CONFIG.GROUP_MIN_DISTANCE;
                group2.pos.y = group1.pos.y + Math.sin(angle) * LAYOUT_CONFIG.GROUP_MIN_DISTANCE;
              } else {
                // Ï∂©Îèå Î∞©Ìñ•ÏúºÎ°ú Î∞ÄÏñ¥ÎÇ¥Í∏∞ (Îçî Í∞ïÌïú ÌûòÏúºÎ°ú)
                const pushDistance = LAYOUT_CONFIG.GROUP_MIN_DISTANCE - distance + 50; // Ï∂îÍ∞Ä Ïó¨Î∞±
                const pushX = (dx / distance) * pushDistance;
                const pushY = (dy / distance) * pushDistance;
                
                // ÏñëÏ™Ω Í∑∏Î£πÏùÑ Î™®Îëê Ïù¥Îèô (Îçî ÏïàÏ†ïÏ†ÅÏù∏ Î∂ÑÎ¶¨)
                const moveDistance = pushDistance / 2;
                group1.pos.x -= (dx / distance) * moveDistance * 0.3;
                group1.pos.y -= (dy / distance) * moveDistance * 0.3;
                group2.pos.x += (dx / distance) * moveDistance * 0.7;
                group2.pos.y += (dy / distance) * moveDistance * 0.7;
              }
              
              // ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏúÑÏπòÎ•º positionsÏóê Î∞òÏòÅ
              positions[group1.id] = { ...group1.pos };
              positions[group2.id] = { ...group2.pos };
            }
          }
        }
        
        if (!hasCollision) break;
        iteration++;
      }
    }
    
    // Î®ºÏ†Ä Í∑∏Î£π ÎÖ∏ÎìúÎì§Ïùò Í∏∞Î≥∏ ÏúÑÏπòÎ•º ÏÑ§Ï†ï
    const fileEntries = Object.entries(files);
    const filesPerRow = Math.max(2, Math.ceil(Math.sqrt(fileEntries.length)));
    
    fileEntries.forEach(([file], fileIndex) => {
      groupNodes.add(file);
      
      const fileRow = Math.floor(fileIndex / filesPerRow);
      const fileCol = fileIndex % filesPerRow;
      
      const fileOffsetX = fileCol * LAYOUT_CONFIG.FILE_SPACING_X;
      const fileOffsetY = fileRow * LAYOUT_CONFIG.FILE_SPACING_Y;
      
      // Í∑∏Î£π ÎÖ∏Îìú ÏúÑÏπò Î®ºÏ†Ä ÏÑ§Ï†ï
      positions[file] = {
        x: 200 + fileOffsetX,
        y: 200 + fileOffsetY
      };
    });
    
    // Í∑∏Î£π ÎÖ∏Îìú Ï∂©Îèå Ìï¥Í≤∞
    adjustGroupPositions();
    
    let globalOffsetX = 0;
    let globalOffsetY = 0;
    
    Object.entries(files).forEach(([file, { nodes, edges }], fileIndex) => {
      const children: Record<string, string[]> = {};
      const parents: Record<string, string[]> = {};
      
      edges.forEach(edge => {
        if (!children[edge.source]) children[edge.source] = [];
        if (!parents[edge.target]) parents[edge.target] = [];
        children[edge.source].push(edge.target);
        parents[edge.target].push(edge.source);
      });
      
      const roots = nodes.filter(node => !parents[node.id] || parents[node.id].length === 0);
      const rootNodes = roots.length > 0 ? roots : 
        nodes.sort((a, b) => (children[b.id]?.length || 0) - (children[a.id]?.length || 0)).slice(0, 1);
      
      // Í∑∏Î£πÏùò Ï§ëÏã¨Ï†êÏùÑ Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î∂Ä ÎÖ∏ÎìúÎì§ Î∞∞Ïπò
      const groupCenter = positions[file];
      
      rootNodes.forEach((root, rootIndex) => {
        const rootOffsetX = rootIndex * LAYOUT_CONFIG.FILE_SPACING_X * 0.2;
        
        const visited = new Set<string>();
        const queue: { 
          id: string; 
          level: number; 
          angle: number; 
          parentPos?: { x: number; y: number };
          sectorStart?: number;
          sectorEnd?: number;
        }[] = [];
        
        const rootX = groupCenter.x + rootOffsetX;
        const rootY = groupCenter.y;
        positions[root.id] = { x: rootX, y: rootY };
        visited.add(root.id);
        
        const rootChildren = children[root.id] || [];
        const childCount = rootChildren.length;
        
        if (childCount > 0) {
          const angleStep = (2 * Math.PI) / childCount;
          const startAngle = -Math.PI / 2;
          
          rootChildren.forEach((childId, index) => {
            const angle = startAngle + index * angleStep;
            queue.push({ 
              id: childId, 
              level: 1, 
              angle,
              parentPos: positions[root.id],
              sectorStart: angle - angleStep / 2,
              sectorEnd: angle + angleStep / 2
            });
          });
        }
        
        while (queue.length > 0) {
          const { id, level, angle, parentPos, sectorStart = 0, sectorEnd = 2 * Math.PI } = queue.shift()!;
          
          if (visited.has(id)) continue;
          visited.add(id);
          
          const radius = LAYOUT_CONFIG.INITIAL_RADIUS + (level - 1) * LAYOUT_CONFIG.LEVEL_RADIUS_INCREMENT;
          const x = parentPos!.x + Math.cos(angle) * radius;
          const y = parentPos!.y + Math.sin(angle) * radius;
          
          positions[id] = { x, y };
          
          const nodeChildren = children[id] || [];
          const unvisitedChildren = nodeChildren.filter(c => !visited.has(c));
          const childChildCount = unvisitedChildren.length;
          
          if (childChildCount > 0) {
            const sectorSize = Math.min(sectorEnd - sectorStart, LAYOUT_CONFIG.SIBLING_ANGLE_SPREAD);
            const childSectorStart = angle - sectorSize / 2;
            const childSectorEnd = angle + sectorSize / 2;
            const childAngleStep = sectorSize / (childChildCount + 1);
            
            unvisitedChildren.forEach((childId, index) => {
              const childAngle = childSectorStart + (index + 1) * childAngleStep;
              const childSectorSize = sectorSize / childChildCount;
              
              queue.push({ 
                id: childId, 
                level: level + 1, 
                angle: childAngle,
                parentPos: positions[id],
                sectorStart: childAngle - childSectorSize / 2,
                sectorEnd: childAngle + childSectorSize / 2
              });
            });
          }
        }
        
        // Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ ÎÖ∏ÎìúÎì§ Î∞∞Ïπò
        nodes.forEach(node => {
          if (!visited.has(node.id)) {
            const unvisitedIndex = Array.from(visited).length;
            const gridCol = unvisitedIndex % 3;
            const gridRow = Math.floor(unvisitedIndex / 3);
            
            positions[node.id] = {
              x: rootX + LAYOUT_CONFIG.INITIAL_RADIUS * 2 + gridCol * LAYOUT_CONFIG.HORIZONTAL_SPACING,
              y: rootY - LAYOUT_CONFIG.INITIAL_RADIUS + gridRow * LAYOUT_CONFIG.VERTICAL_SPACING
            };
            visited.add(node.id);
          }
        });
      });
      
      globalOffsetX = Math.max(globalOffsetX, ...Object.values(positions).map(p => p.x));
      globalOffsetY = Math.max(globalOffsetY, ...Object.values(positions).map(p => p.y));
    });
    
    // Ï†ÑÏ≤¥ Îã§Ïù¥Ïñ¥Í∑∏Îû® Ï§ëÏïô Ï†ïÎ†¨
    const allX = Object.values(positions).map(p => p.x);
    const allY = Object.values(positions).map(p => p.y);
    const minX = Math.min(...allX);
    const minY = Math.min(...allY);
    const maxX = Math.max(...allX);
    const maxY = Math.max(...allY);
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    Object.keys(positions).forEach(id => {
      positions[id].x -= centerX - 400;
      positions[id].y -= centerY - 400;
    });
    
    return positions;
  }

  // Custom Group Node Component
  export function CustomGroupNode({ data }: NodeProps) {
    const { label, isCollapsed, onToggleCollapse } = data;

    const ChevronIcon = ({ direction = 'down' }: { direction: 'down' | 'right' }) => (
      <svg
        width={20}
        height={20}
        viewBox="0 0 24 24"
        style={{
          color: '#6366f1',
          transition: 'transform 0.15s',
          transform: direction === 'right' ? 'rotate(-90deg)' : 'none',
        }}
        fill="none"
        stroke="currentColor"
        strokeWidth={2.5}
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        <polyline points="6 9 12 15 18 9" />
      </svg>
    );

    if (isCollapsed) {
      return (
        <>
          <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
          <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
          <div
            style={{
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontWeight: 600,
              fontSize: 13,
              color: '#444',
              cursor: 'pointer',
              gap: 8,
            }}
            onClick={(e) => {
              e.stopPropagation();
              onToggleCollapse();
            }}
          >
            <ChevronIcon direction="right" />
            <span>{label}</span>
          </div>
        </>
      );
    }

    return (
      <>
        <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
        <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
        <div
          style={{
            position: 'absolute',
            top: -32,
            left: 0,
            width: '100%',
            fontWeight: 600,
            fontSize: 13,
            color: '#444',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 8,
            height: 32,
          }}
        >
          <span
            onClick={(e) => {
              e.stopPropagation();
              onToggleCollapse();
            }}
            style={{ cursor: 'pointer', display: 'flex', alignItems: 'center' }}
          >
            <ChevronIcon direction="down" />
          </span>
          <span>{label}</span>
        </div>
      </>
    );
  }

  // Utility functions
  export function parseApiResponse(response: any): any {
    return typeof response?.data === 'string' ? JSON.parse(response.data) : response.data;
  }

  export function cleanFilePath(path: string, targetFolder?: string): string {
    if (!targetFolder) return path;
    const regex = new RegExp(`^${targetFolder}[\\\\/]`);
    return path.replace(regex, '');
  }

  export function calculateNodeWidth(label: string): number {
    const textWidth = getTextWidth(label);
    return Math.max(STYLES.NODE.MIN_WIDTH, textWidth + STYLES.NODE.PADDING);
  }

  [src/components/export_code.py]
  from pathlib import Path

  COMP = Path(__file__).resolve().parent

  # ÌäπÏ†ï Ïª¥Ìè¨ÎÑåÌä∏ ÌååÏùºÎßå ÏÑ†ÌÉù
  target_components = [
      COMP / "diagramUtils.tsx",
      COMP / "DiagramViewer.tsx"
  ]

  # Ï°¥Ïû¨ÌïòÎäî ÌååÏùºÎßå ÌïÑÌÑ∞ÎßÅ
  targets = [f for f in target_components if f.is_file()]

  # ÏÉÅÎåÄ Í≤ΩÎ°ú Ï∂úÎ†• Ìï®Ïàò
  def get_rel_path(p: Path) -> str:
      try:
          return p.relative_to(COMP).as_posix()
      except ValueError:
          return p.relative_to(COMP.parent).as_posix()

  print("ÏÑ†ÌÉùÎêú ÌååÏùºÎì§:")
  print([get_rel_path(p) for p in targets])

  # ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
  out_path = COMP / "selected_components.txt"
  with out_path.open("w", encoding="utf-8") as out:
      for file_path in targets:
          rel_path = get_rel_path(file_path)
          out.write(f"[{rel_path}]\n")
          out.write(file_path.read_text(encoding="utf-8"))
          out.write("\n\n")

  print(f"‚úÖ ÏôÑÎ£å: {out_path.relative_to(COMP)} ÏÉùÏÑ±")

  [src/components/selected_components.txt]
  [diagramUtils.tsx]
  import { Node, Edge, NodeProps, Handle, Position } from '@xyflow/react';
  import dagre from 'dagre';
  import hljs from 'highlight.js/lib/core';
  import python from 'highlight.js/lib/languages/python';
  import 'highlight.js/styles/atom-one-light.css';

  hljs.registerLanguage('python', python);

  // Constants
  export const ENDPOINTS = {
    CG: '/api/generate_call_graph',
    CFG: '/api/generate_control_flow_graph',
    INLINE_CODE_EXPLANATION: '/api/inline_code_explanation',
  } as const;

  export const STYLES = {
    NODE: {
      MIN_WIDTH: 60,
      PADDING: 16,
      HEIGHT: { SMALL: 35, DEFAULT: 40 },
      FONT_SIZE: '12px',
      FONT_FAMILY: 'Arial, sans-serif',
    },
    GROUP: {
      PADDING: 20,
      COLLAPSED_WIDTH: 200,
      COLLAPSED_HEIGHT: 50,
    },
    COLORS: {
      NODE: {
        DEFAULT: '#ffffff',
        HOVER: '#fef9c3',
        SELECTED: '#fca5a5',
        ACTIVE: '#dbeafe',
        BORDER: '#4A90E2',
        BORDER_HOVER: '#eab308',
        BORDER_SELECTED: '#b91c1c',
        BORDER_ACTIVE: '#0284c7',
      },
      GROUP: {
        DEFAULT: '#FAFAFA',
        COLLAPSED: '#f3f4f6',
        BORDER: '#b9bfc9',
        BORDER_COLLAPSED: '#6b7280',
        BORDER_ACTIVE: '#fb923c',
      },
      EDGE: {
        DEFAULT: '#34A853',
        HOVER: '#f59e42',
      },
    },
    CFG_PANEL: {
      WIDTH: 800,
      HEIGHT: 600,
    },
  } as const;

  // Types
  export interface RawNode {
    id: string;
    label?: string;
    function_name?: string;
    file: string;
  }

  export interface RawEdge {
    id: string;
    source: string;
    target: string;
    type?: string;
  }

  export interface CFGPanel {
    id: string;
    functionName: string;
    file: string;
    result: any;
    expanded: boolean;
    pos: { x: number; y: number };
    dragging: boolean;
    dragOffset: { x: number; y: number };
    width?: number;
    height?: number;
    resizing?: boolean;
  }

  // Cache
  export const snippetCache = new Map<string, string>();

  // Helper Functions
  export function getTextWidth(text: string, font: string = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`): number {
    if (typeof document === 'undefined') return text.length * 7;
    const canvas = (getTextWidth as any).canvas || ((getTextWidth as any).canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    if (!context) return text.length * 7;
    context.font = font;
    return context.measureText(text).width;
  }

  export function extractFunctionSnippet(code: string, functionName: string): { snippet: string, startLine: number } | null {
    const lines = code.split('\n');
    const startIndex = lines.findIndex(line => line.trim().startsWith(`def ${functionName}(`));
    if (startIndex === -1) return null;
    
    for (let i = startIndex + 1; i < lines.length; i++) {
      if (lines[i].trim() === '') continue;
      if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
        return { snippet: lines.slice(startIndex, i).join('\n'), startLine: startIndex + 1 };
      }
    }
    return { snippet: lines.slice(startIndex).join('\n'), startLine: startIndex + 1 };
  }

  export function highlightWithLineNumbers(snippet: string, startLine: number = 1): string {
    const highlighted = hljs.highlight(snippet, { language: 'python' }).value;
    const lines = highlighted.split('\n');
    const padding = String(startLine + lines.length - 1).length;
    return lines
      .map((line, idx) => `<span style="color:#64748b">${String(startLine + idx).padStart(padding, ' ')}</span>  ${line}`)
      .join('\n');
  }

  export function isNodeHidden(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): boolean {
    const node = nodes.find(n => n.id === nodeId);
    if (!node?.parentId) return false;
    return collapsedGroups.has(node.parentId) || isNodeHidden(node.parentId, collapsedGroups, nodes);
  }

  export function findRepresentativeNode(nodeId: string, collapsedGroups: Set<string>, nodes: Node[]): string {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return nodeId;
    if (node.type === 'group' || !node.parentId) return nodeId;
    if (collapsedGroups.has(node.parentId)) return node.parentId;
    
    let current = node;
    while (current.parentId) {
      const parent = nodes.find(n => n.id === current.parentId);
      if (!parent) break;
      if (parent.type === 'group' && collapsedGroups.has(parent.id)) return parent.id;
      current = parent;
    }
    return nodeId;
  }

  // Mindmap-style layout function with better horizontal spreading
  export function calculateLayout(
    files: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>,
    nodeWidths: Record<string, number>
  ): Record<string, { x: number; y: number }> {
    const positions: Record<string, { x: number; y: number }> = {};
    
    // Layout configuration - Ïù¥ Í∞íÎì§ÏùÑ Ï°∞Ï†ïÌïòÏó¨ ÌçºÏßê Ï†ïÎèÑÎ•º Ï†úÏñ¥
    const LAYOUT_CONFIG = {
      HORIZONTAL_SPACING: 1500,     // Í∞ÄÎ°ú Î∞©Ìñ• Í∏∞Î≥∏ Í∞ÑÍ≤© (Í∞íÏù¥ ÌÅ¥ÏàòÎ°ù Îçî ÎÑìÍ≤å ÌçºÏßê)
      VERTICAL_SPACING: 100,       // ÏÑ∏Î°ú Î∞©Ìñ• Í∏∞Î≥∏ Í∞ÑÍ≤©
      LEVEL_RADIUS_INCREMENT: 10, // Î†àÎ≤®Î≥Ñ Î∞òÍ≤Ω Ï¶ùÍ∞ÄÎüâ (Í∞íÏù¥ ÌÅ¥ÏàòÎ°ù Î†àÎ≤®Í∞Ñ Í±∞Î¶¨Í∞Ä Î©ÄÏñ¥Ïßê)
      INITIAL_RADIUS: 100,         // Ï≤´ Î≤àÏß∏ Î†àÎ≤®Ïùò Î∞òÍ≤Ω
      SIBLING_ANGLE_SPREAD: Math.PI * 0.1, // ÌòïÏ†ú ÎÖ∏ÎìúÎì§Ïù¥ ÌçºÏßÄÎäî Í∞ÅÎèÑ (ÎùºÎîîÏïà, ÏµúÎåÄ 2*PI)
      FILE_SPACING_X: 600,        // ÌååÏùº Í∞Ñ Í∞ÄÎ°ú Í∞ÑÍ≤©
      FILE_SPACING_Y: 500,         // ÌååÏùº Í∞Ñ ÏÑ∏Î°ú Í∞ÑÍ≤©
    };
    
    let globalOffsetX = 0;
    let globalOffsetY = 0;
    
    // Process each file separately
    Object.entries(files).forEach(([file, { nodes, edges }], fileIndex) => {
      // Create adjacency lists
      const children: Record<string, string[]> = {};
      const parents: Record<string, string[]> = {};
      
      edges.forEach(edge => {
        if (!children[edge.source]) children[edge.source] = [];
        if (!parents[edge.target]) parents[edge.target] = [];
        children[edge.source].push(edge.target);
        parents[edge.target].push(edge.source);
      });
      
      // Find root nodes (nodes with no parents)
      const roots = nodes.filter(node => !parents[node.id] || parents[node.id].length === 0);
      
      // If no roots found, select nodes with the most children
      const rootNodes = roots.length > 0 ? roots : 
        nodes.sort((a, b) => (children[b.id]?.length || 0) - (children[a.id]?.length || 0)).slice(0, 1);
      
      // Calculate file offset in a grid pattern for better space usage
      const filesPerRow = Math.ceil(Math.sqrt(Object.keys(files).length));
      const fileRow = Math.floor(fileIndex / filesPerRow);
      const fileCol = fileIndex % filesPerRow;
      
      const fileOffsetX = fileCol * LAYOUT_CONFIG.FILE_SPACING_X;
      const fileOffsetY = fileRow * LAYOUT_CONFIG.FILE_SPACING_Y;
      
      rootNodes.forEach((root, rootIndex) => {
        const rootOffsetX = rootIndex * LAYOUT_CONFIG.FILE_SPACING_X * 0.5;
        
        // BFS to assign levels and distribute nodes
        const visited = new Set<string>();
        const queue: { 
          id: string; 
          level: number; 
          angle: number; 
          parentPos?: { x: number; y: number };
          sectorStart?: number;
          sectorEnd?: number;
        }[] = [];
        
        // Start with root at center
        const rootX = 400 + fileOffsetX + rootOffsetX;
        const rootY = 400 + fileOffsetY;
        positions[root.id] = { x: rootX, y: rootY };
        visited.add(root.id);
        
        // Add children to queue with angles
        const rootChildren = children[root.id] || [];
        const childCount = rootChildren.length;
        
        if (childCount > 0) {
          // Distribute children around the full circle for root
          const angleStep = (2 * Math.PI) / childCount;
          const startAngle = -Math.PI / 2; // Start from top
          
          rootChildren.forEach((childId, index) => {
            const angle = startAngle + index * angleStep;
            queue.push({ 
              id: childId, 
              level: 1, 
              angle,
              parentPos: positions[root.id],
              sectorStart: angle - angleStep / 2,
              sectorEnd: angle + angleStep / 2
            });
          });
        }
        
        // Process queue
        while (queue.length > 0) {
          const { id, level, angle, parentPos, sectorStart = 0, sectorEnd = 2 * Math.PI } = queue.shift()!;
          
          if (visited.has(id)) continue;
          visited.add(id);
          
          // Calculate position based on angle and level
          const radius = LAYOUT_CONFIG.INITIAL_RADIUS + (level - 1) * LAYOUT_CONFIG.LEVEL_RADIUS_INCREMENT;
          const x = parentPos!.x + Math.cos(angle) * radius;
          const y = parentPos!.y + Math.sin(angle) * radius;
          
          positions[id] = { x, y };
          
          // Add children with adjusted angles
          const nodeChildren = children[id] || [];
          const unvisitedChildren = nodeChildren.filter(c => !visited.has(c));
          const childChildCount = unvisitedChildren.length;
          
          if (childChildCount > 0) {
            // Calculate the sector for this node's children
            const sectorSize = Math.min(sectorEnd - sectorStart, LAYOUT_CONFIG.SIBLING_ANGLE_SPREAD);
            const childSectorStart = angle - sectorSize / 2;
            const childSectorEnd = angle + sectorSize / 2;
            const childAngleStep = sectorSize / (childChildCount + 1);
            
            unvisitedChildren.forEach((childId, index) => {
              const childAngle = childSectorStart + (index + 1) * childAngleStep;
              const childSectorSize = sectorSize / childChildCount;
              
              queue.push({ 
                id: childId, 
                level: level + 1, 
                angle: childAngle,
                parentPos: positions[id],
                sectorStart: childAngle - childSectorSize / 2,
                sectorEnd: childAngle + childSectorSize / 2
              });
            });
          }
        }
        
        // Handle any unvisited nodes (disconnected components)
        nodes.forEach(node => {
          if (!visited.has(node.id)) {
            // Place disconnected nodes in a grid to the right
            const unvisitedIndex = Array.from(visited).length;
            const gridCol = unvisitedIndex % 4;
            const gridRow = Math.floor(unvisitedIndex / 4);
            
            positions[node.id] = {
              x: rootX + LAYOUT_CONFIG.INITIAL_RADIUS * 3 + gridCol * LAYOUT_CONFIG.HORIZONTAL_SPACING,
              y: rootY - LAYOUT_CONFIG.INITIAL_RADIUS + gridRow * LAYOUT_CONFIG.VERTICAL_SPACING
            };
            visited.add(node.id);
          }
        });
      });
      
      // Update global offset for next file
      globalOffsetX = Math.max(globalOffsetX, ...Object.values(positions).map(p => p.x));
      globalOffsetY = Math.max(globalOffsetY, ...Object.values(positions).map(p => p.y));
    });
    
    // Center the entire diagram
    const allX = Object.values(positions).map(p => p.x);
    const allY = Object.values(positions).map(p => p.y);
    const minX = Math.min(...allX);
    const minY = Math.min(...allY);
    const maxX = Math.max(...allX);
    const maxY = Math.max(...allY);
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Adjust all positions to center
    Object.keys(positions).forEach(id => {
      positions[id].x -= centerX - 400;
      positions[id].y -= centerY - 400;
    });
    
    return positions;
  }

  // Custom Group Node Component
  export function CustomGroupNode({ data }: NodeProps) {
    const { label, isCollapsed, onToggleCollapse } = data;

    const ChevronIcon = ({ direction = 'down' }: { direction: 'down' | 'right' }) => (
      <svg
        width={20}
        height={20}
        viewBox="0 0 24 24"
        style={{
          color: '#6366f1',
          transition: 'transform 0.15s',
          transform: direction === 'right' ? 'rotate(-90deg)' : 'none',
        }}
        fill="none"
        stroke="currentColor"
        strokeWidth={2.5}
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        <polyline points="6 9 12 15 18 9" />
      </svg>
    );

    if (isCollapsed) {
      return (
        <>
          <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
          <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
          <div
            style={{
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontWeight: 600,
              fontSize: 13,
              color: '#444',
              cursor: 'pointer',
              gap: 8,
            }}
            onClick={(e) => {
              e.stopPropagation();
              onToggleCollapse();
            }}
          >
            <ChevronIcon direction="right" />
            <span>{label}</span>
          </div>
        </>
      );
    }

    return (
      <>
        <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
        <Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
        <div
          style={{
            position: 'absolute',
            top: -32,
            left: 0,
            width: '100%',
            fontWeight: 600,
            fontSize: 13,
            color: '#444',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 8,
            height: 32,
          }}
        >
          <span
            onClick={(e) => {
              e.stopPropagation();
              onToggleCollapse();
            }}
            style={{ cursor: 'pointer', display: 'flex', alignItems: 'center' }}
          >
            <ChevronIcon direction="down" />
          </span>
          <span>{label}</span>
        </div>
      </>
    );
  }

  // Utility functions
  export function parseApiResponse(response: any): any {
    return typeof response?.data === 'string' ? JSON.parse(response.data) : response.data;
  }

  export function cleanFilePath(path: string, targetFolder?: string): string {
    if (!targetFolder) return path;
    const regex = new RegExp(`^${targetFolder}[\\\\/]`);
    return path.replace(regex, '');
  }

  export function calculateNodeWidth(label: string): number {
    const textWidth = getTextWidth(label);
    return Math.max(STYLES.NODE.MIN_WIDTH, textWidth + STYLES.NODE.PADDING);
  }

  [DiagramViewer.tsx]
  'use client';

  import { useState, useEffect, useCallback, useMemo } from 'react';
  import {
    ReactFlow,
    Background,
    MiniMap,
    Controls,
    MarkerType,
    type Node,
    type Edge,
    type NodeMouseHandler,
    applyNodeChanges,
    NodeChange,
  } from '@xyflow/react';
  import '@xyflow/react/dist/style.css';
  import { nanoid } from 'nanoid';
  import { useEditor } from '@/store/editor';
  import { useFS, type FileNode } from '@/store/files';
  import {
    RawNode,
    RawEdge,
    CFGPanel,
    snippetCache,
    extractFunctionSnippet,
    highlightWithLineNumbers,
    isNodeHidden,
    findRepresentativeNode,
    calculateLayout,
    CustomGroupNode,
    parseApiResponse,
    cleanFilePath,
    calculateNodeWidth,
    ENDPOINTS,
    STYLES,
  } from './diagramUtils';

  // Constants
  let diagramCache: Record<string, { nodes: RawNode[]; edges: RawEdge[] }> | null = null;
  const apiUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '';
  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

  export default function DiagramViewer() {
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<Edge[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string>();
    const [hoverId, setHoverId] = useState<string | null>(null);
    const [snippet, setSnippet] = useState<string>('');
    const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
    const [cfgMessage, setCfgMessage] = useState<string | null>(null);
    const [cfgPanels, setCfgPanels] = useState<CFGPanel[]>([]);
    const [cfgLoading, setCfgLoading] = useState(false);
    const [diagramReady, setDiagramReady] = useState(false);
    const [hoveredEdgeId, setHoveredEdgeId] = useState<string | null>(null);
    const [collapsedGroups, setCollapsedGroups] = useState<Set<string>>(new Set());
    const [cfgPanelMessage, setCfgPanelMessage] = useState<string | null>(null);

    const editorState = useEditor.getState();
    const fsState = useFS.getState();

    const activePath = editorState.tabs.find(t => t.id === editorState.activeId)?.path ?? '';

    // Handlers
    const toggleCollapse = useCallback((groupId: string) => {
      setCollapsedGroups(prev => {
        const newSet = new Set(prev);
        newSet.has(groupId) ? newSet.delete(groupId) : newSet.add(groupId);
        return newSet;
      });
    }, []);

    const openFile = useCallback((filePath: string, line?: number, highlight?: { from: number; to: number }) => {
      const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
      editorState.open({
        id: nanoid(),
        path: cleanPath,
        name: cleanPath.split(/[\\/]/).pop() ?? cleanPath,
        line,
        highlight,
      });
      const target = findByPath(fsState.tree, cleanPath);
      if (target) fsState.setCurrent(target.id);
    }, [editorState, fsState]);

    const onNodeClick: NodeMouseHandler = useCallback((_, node) => {
      if (node.type === 'group') {
        const childNode = nodes.find(n => n.parentId === node.id && !isNodeHidden(n.id, collapsedGroups, nodes));
        const filePath = (childNode?.data as any)?.file || (node.data as any)?.file;
        if (filePath) openFile(filePath, 1);
        return;
      }
      setSelectedNodeId(prev => prev === node.id ? null : node.id);
      const filePath = (node.data as any)?.file;
      if (filePath) openFile(filePath);
    }, [nodes, collapsedGroups, openFile]);

    const onNodeMouseEnter: NodeMouseHandler = useCallback(async (_, node) => {
      if (node.type === 'group') return;

      setHoverId(node.id);
      const filePath = (node.data as any)?.file;
      const functionName = (node.data as any)?.label;
      if (!filePath || !functionName) {
        setSnippet('');
        return;
      }

      const cleanPath = cleanFilePath(filePath, TARGET_FOLDER);
      const cacheKey = `${cleanPath}_${functionName}`;

      try {
        let code = snippetCache.get(cacheKey);
        if (!code) {
          const response = await fetch(`/api/file?path=${encodeURIComponent(cleanPath)}`);
          code = await response.text();
        }

        const result = extractFunctionSnippet(code, functionName);
        if (result) {
          snippetCache.set(cacheKey, result.snippet);
          setSnippet(highlightWithLineNumbers(result.snippet, result.startLine));
        } else {
          setSnippet('(function not found)');
        }
      } catch {
        setSnippet('(preview unavailable)');
      }
    }, []);

    const onNodeMouseLeave = useCallback(() => {
      setHoverId(null);
      setSnippet('');
    }, []);

    const handleCFGPanelUpdate = useCallback((id: string, updates: Partial<CFGPanel>) => {
      setCfgPanels(panels => panels.map(p => p.id === id ? { ...p, ...updates } : p));
    }, []);

    const handleCFGPanelClose = useCallback((id: string) => {
      setCfgPanels(panels => panels.filter(p => p.id !== id));
    }, []);

    const handleCFGNodeHover = useCallback(async (node: Node | null, panel: CFGPanel) => {
      if (!node) {
        setCfgPanelMessage(null);
        return;
      }

      const { line_start, line_end } = node.data as any;

      setCfgPanelMessage(
        `<div style="display:flex;align-items:flex-start;gap:8px;">
          <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
          <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
            ÏÑ§Î™ÖÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...
          </span>
        </div>`
      );

      try {
        const res = await fetch(`${apiUrl}${ENDPOINTS.INLINE_CODE_EXPLANATION}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_path: panel.file, line_start, line_end }),
        });
        const data = await res.json();
        const explanation = data.explanation || data.data?.explanation || 'ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';

        setCfgPanelMessage(
          `<div style="display:flex;align-items:flex-start;gap:8px;">
            <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
            <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:320px;display:inline-block;">
              ${explanation}
            </span>
          </div>`
        );
      } catch {
        setCfgPanelMessage(
          `<div style="display:flex;align-items:flex-start;gap:8px;">
            <span style="font-size:22px;line-height:1.1;">üßë‚Äçüî¨</span>
            <span style="background:#fffbe9;border-radius:8px;padding:7px 13px;box-shadow:0 1px 4px #0001;font-size:13px;color:#b45309;max-width:220px;display:inline-block;">
              ÏÑ§Î™ÖÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
            </span>
          </div>`
        );
      }

      openFile(node.data.file || panel.file, line_start, { from: line_start, to: line_end });
    }, [apiUrl, openFile]);

    const handleGenerateCFG = useCallback(async () => {
      setCfgMessage(null);
      setCfgLoading(true);

      const selectedNode = nodes.find(n => n.id === selectedNodeId && n.type !== 'group');
      if (!selectedNode) {
        setCfgMessage('ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      const { file, label: functionName } = selectedNode.data as any;
      if (!file || !functionName) {
        setCfgMessage('ÎÖ∏Îìú Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      if (cfgPanels.some(p => p.file === file && p.functionName === functionName)) {
        setCfgMessage('Ïù¥ÎØ∏ Ìï¥Îãπ Ìï®ÏàòÏùò CFG Ìå®ÎÑêÏù¥ Ïó¥Î†§ ÏûàÏäµÎãàÎã§.');
        setCfgLoading(false);
        return;
      }

      try {
        const res = await fetch(`${apiUrl}${ENDPOINTS.CFG}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_path: file, function_name: functionName }),
        });

        const data = await res.json();
        if (data.status && data.status !== 200) {
          setCfgMessage('API Ìò∏Ï∂ú Ïã§Ìå®: ' + (data.data || ''));
          return;
        }

        const cfgData = parseApiResponse(data);
        let cfgNodes = (cfgData.nodes || []).map((n: any) => ({
          id: n.id,
          data: {
            label: n.label || n.id,
            file: n.file || file,
            line_start: n.line_start || 1,
            line_end: n.line_end || 1,
          },
          position: { x: n.x ?? 0, y: n.y ?? 0 },
          style: {
            padding: 4,
            borderRadius: 3,
            border: '1px solid #0284c7',
            background: '#fff',
            fontSize: 12,
            minWidth: 40,
            minHeight: 24,
          },
        }));

        const cfgEdges = (cfgData.edges || []).map((e: any) => ({
          id: e.id || `${e.source}-${e.target}`,
          source: e.source,
          target: e.target,
          markerEnd: { type: MarkerType.ArrowClosed },
          animated: true,
          style: { stroke: '#0284c7', strokeWidth: 2 },
        }));

        if (cfgData.nodes?.length > 0 && cfgData.nodes.every((n: any) => !n.x && !n.y)) {
          const posMap = calculateLayout({ [file]: { nodes: cfgData.nodes, edges: cfgData.edges } }, {});
          cfgNodes = cfgNodes.map((n: any) => ({
            ...n,
            position: posMap[n.id] ?? { x: 0, y: 0 }
          }));
        }

        setCfgPanels(panels => [
          ...panels,
          {
            id: `${file}__${functionName}__${Date.now()}`,
            functionName,
            file,
            result: { nodes: cfgNodes, edges: cfgEdges },
            expanded: true,
            pos: { x: 24 + panels.length * 32, y: 24 + panels.length * 32 },
            dragging: false,
            dragOffset: { x: 0, y: 0 },
            width: STYLES.CFG_PANEL.WIDTH,
            height: STYLES.CFG_PANEL.HEIGHT,
          },
        ]);
        setCfgMessage(null);
      } catch (e: any) {
        setCfgMessage('API Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. error: ' + e.message);
      } finally {
        setCfgLoading(false);
      }
    }, [nodes, selectedNodeId, cfgPanels, apiUrl]);

    const hydrate = useCallback((json: Record<string, { nodes: RawNode[]; edges: RawEdge[] }>) => {
      const nodeWidths: Record<string, number> = {};
      const nodeFont = `${STYLES.NODE.FONT_SIZE} ${STYLES.NODE.FONT_FAMILY}`;

      // Calculate node widths
      Object.values(json).forEach(data => {
        data.nodes.forEach(node => {
          const label = node.label || node.function_name || node.id;
          nodeWidths[node.id] = calculateNodeWidth(label);
        });
      });

      // Create nodes
      let allFunctionNodes: Node[] = [];
      let allRawEdges: RawEdge[] = [];

      Object.entries(json).forEach(([file, data]) => {
        const functionNodes = data.nodes.map(n => ({
          id: n.id,
          data: { label: n.label || n.function_name || n.id, file: n.file },
          position: { x: 0, y: 0 },
          style: {
            padding: '6px 8px',
            borderRadius: 4,
            border: '1px solid #3b82f6',
            background: '#fff',
            width: nodeWidths[n.id],
            fontSize: STYLES.NODE.FONT_SIZE,
            fontFamily: STYLES.NODE.FONT_FAMILY,
          },
          zIndex: 1,
        }));
        allFunctionNodes = allFunctionNodes.concat(functionNodes);
        allRawEdges = allRawEdges.concat(data.edges);
      });

      // Create edges
      const nodeIds = new Set(allFunctionNodes.map(n => n.id));
      const allEdges: Edge[] = allRawEdges
        .filter(e => nodeIds.has(e.source) && nodeIds.has(e.target))
        .map(e => ({
          id: e.id,
          source: e.source,
          target: e.target,
          markerEnd: {
            type: MarkerType.ArrowClosed,
            width: 15,
            height: 15,
            color: STYLES.COLORS.EDGE.DEFAULT,
          },
          animated: true,
          style: { stroke: STYLES.COLORS.EDGE.DEFAULT, strokeWidth: 2 },
          zIndex: 10000,
          type: 'step',
        }));

      // Calculate layout
      const posMap = calculateLayout(json, nodeWidths);
      const laidOutNodes = allFunctionNodes.map(n => ({
        ...n,
        position: posMap[n.id] ?? { x: 0, y: 0 },
      }));

      // Create groups
      const groupNodes: Node[] = [];
      const fileToNodes: Record<string, Node[]> = {};

      laidOutNodes.forEach(node => {
        const file = (node.data as any).file;
        if (!fileToNodes[file]) fileToNodes[file] = [];
        fileToNodes[file].push(node);
      });

      Object.entries(fileToNodes).forEach(([file, nodesInGroup]) => {
        if (nodesInGroup.length === 0) return;

        const xs = nodesInGroup.map(n => n.position.x);
        const ys = nodesInGroup.map(n => n.position.y);
        const minX = Math.min(...xs);
        const minY = Math.min(...ys);
        const maxX = Math.max(...nodesInGroup.map(n => n.position.x + ((n.style?.width as number) || STYLES.NODE.MIN_WIDTH)));
        const maxY = Math.max(...nodesInGroup.map(n => n.position.y + ((n.style?.height as number) || STYLES.NODE.HEIGHT.DEFAULT)));

        const groupId = `group-${file.replace(/[^a-zA-Z0-9]/g, '_')}`;
        groupNodes.push({
          id: groupId,
          type: 'group',
          data: {
            label: file.split('/').pop() || file,
            file: file
          },
          position: { x: minX - STYLES.GROUP.PADDING, y: minY - STYLES.GROUP.PADDING },
          style: {
            width: maxX - minX + 2 * STYLES.GROUP.PADDING,
            height: maxY - minY + 2 * STYLES.GROUP.PADDING,
            background: 'rgba(0, 0, 0, 0.05)',
            border: '1px dashed #fb923c',
            borderRadius: 8,
          },
          zIndex: 0,
        });

        nodesInGroup.forEach(node => {
          node.position = {
            x: node.position.x - (minX - STYLES.GROUP.PADDING),
            y: node.position.y - (minY - STYLES.GROUP.PADDING),
          };
          node.parentId = groupId;
          node.extent = 'parent';
        });
      });

      setNodes([...groupNodes, ...laidOutNodes]);
      setEdges(allEdges);
    }, []);

    // Load diagram
    useEffect(() => {
      if (!diagramReady) return;

      (async () => {
        if (diagramCache) {
          hydrate(diagramCache);
          setLoading(false);
          return;
        }

        setLoading(true);
        setError(undefined);

        try {
          const res = await fetch(`${apiUrl}${ENDPOINTS.CG}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: `../../${TARGET_FOLDER}`, file_type: 'py' }),
          });

          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

          const data = await res.json();
          const json = parseApiResponse(data);
          diagramCache = json;
          hydrate(json);
        } catch (e: any) {
          setError(String(e));
          setNodes([]);
          setEdges([]);
        } finally {
          setLoading(false);
        }
      })();
    }, [diagramReady, apiUrl, hydrate]);

    // Process edges for collapsed groups
    const processedEdges = useMemo(() => {
      const processed = edges.map(e => {
        const sourceRep = findRepresentativeNode(e.source, collapsedGroups, nodes);
        const targetRep = findRepresentativeNode(e.target, collapsedGroups, nodes);

        if (sourceRep === targetRep && collapsedGroups.has(sourceRep)) {
          return { ...e, hidden: true };
        }

        const isRedirected = sourceRep !== e.source || targetRep !== e.target;
        const finalEdge = isRedirected ? {
          ...e,
          id: `${e.id}_redirected_${sourceRep}_${targetRep}`,
          source: sourceRep,
          target: targetRep,
          data: {
            ...e.data,
            originalSource: e.source,
            originalTarget: e.target,
            isRedirected: true,
          },
        } : e;

        const isHover = hoveredEdgeId === finalEdge.id;

        return {
          ...finalEdge,
          hidden: false,
          style: {
            ...(finalEdge.style || {}),
            stroke: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
            strokeWidth: isHover ? 4 : (isRedirected ? 3 : 2),
            strokeDasharray: isRedirected ? '5 5' : undefined,
            transition: 'all 0.13s',
            cursor: 'pointer',
          },
          markerEnd: {
            ...(finalEdge.markerEnd || {}),
            color: isHover ? STYLES.COLORS.EDGE.HOVER : STYLES.COLORS.EDGE.DEFAULT,
          },
          zIndex: isRedirected ? 10001 : 10000,
        };
      });

      // Remove duplicates
      const seen = new Map<string, Edge>();
      processed.forEach(edge => {
        const key = `${edge.source}-${edge.target}`;
        if (!seen.has(key) || edge.data?.isRedirected) {
          seen.set(key, edge);
        }
      });

      return Array.from(seen.values());
    }, [edges, collapsedGroups, nodes, hoveredEdgeId]);

    // Process nodes for styling
    const finalNodes = useMemo(() => {
      return nodes.map(n => {
        const cleanPath = cleanFilePath((n.data as any)?.file || '', TARGET_FOLDER);
        const isActive = cleanPath === activePath;
        const isHover = hoverId === n.id;
        const isSelected = selectedNodeId === n.id;
        const isGroup = n.type === 'group';
        const isCollapsed = isGroup && collapsedGroups.has(n.id);
        const isHidden = !isGroup && isNodeHidden(n.id, collapsedGroups, nodes);

        return {
          ...n,
          type: isGroup ? 'group' : (n.type || 'default'),
          hidden: isHidden,
          style: {
            ...n.style,
            background: isGroup
              ? isCollapsed
                ? STYLES.COLORS.GROUP.COLLAPSED
                : isHover
                  ? STYLES.COLORS.NODE.HOVER
                  : isSelected
                    ? STYLES.COLORS.NODE.SELECTED
                    : isActive
                      ? STYLES.COLORS.NODE.ACTIVE
                      : STYLES.COLORS.GROUP.DEFAULT
              : isHover
                ? STYLES.COLORS.NODE.HOVER
                : isSelected
                  ? STYLES.COLORS.NODE.SELECTED
                  : isActive
                    ? STYLES.COLORS.NODE.ACTIVE
                    : STYLES.COLORS.NODE.DEFAULT,
            border: isGroup
              ? isCollapsed
                ? `2px solid ${STYLES.COLORS.GROUP.BORDER_COLLAPSED}`
                : isHover
                  ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
                  : isActive
                    ? `1px solid ${STYLES.COLORS.GROUP.BORDER_ACTIVE}`
                    : `1px solid ${STYLES.COLORS.GROUP.BORDER}`
              : isHover
                ? `4px solid ${STYLES.COLORS.NODE.BORDER_HOVER}`
                : isSelected
                  ? `4px solid ${STYLES.COLORS.NODE.BORDER_SELECTED}`
                  : isActive
                    ? `1px solid ${STYLES.COLORS.NODE.BORDER_ACTIVE}`
                    : `1px solid ${STYLES.COLORS.NODE.BORDER}`,
            transition: 'all 0.1s ease-in-out',
            minWidth: isGroup ? (isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : undefined) : (n.style?.width as number),
            width: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_WIDTH : n.style?.width,
            height: isGroup && isCollapsed ? STYLES.GROUP.COLLAPSED_HEIGHT : n.style?.height,
            cursor: isGroup && isCollapsed ? 'pointer' : 'default',
          },
          data: isGroup
            ? {
              ...n.data,
              isCollapsed,
              onToggleCollapse: () => toggleCollapse(n.id),
            }
            : n.data,
        };
      });
    }, [nodes, activePath, hoverId, selectedNodeId, collapsedGroups, toggleCollapse]);

    if (!diagramReady) {
      return (
        <div className="flex items-center justify-center h-full w-full">
          <button
            onClick={() => setDiagramReady(true)}
            className="min-w-[180px] px-8 py-3 rounded-lg bg-white text-gray-700 font-semibold text-lg border border-gray-300 shadow-sm hover:bg-gray-50 hover:border-indigo-500 hover:text-indigo-700 transition-all"
          >
            <span className="inline-block mr-2 text-indigo-500">‚ñ∂</span>
            Generate Diagram
          </button>
        </div>
      );
    }

    if (loading) {
      return (
        <div className="flex items-center justify-center h-full w-full">
          <svg className="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" />
          </svg>
          <span className="ml-3 text-sm text-slate-500">diagram loading‚Ä¶</span>
        </div>
      );
    }

    if (error) {
      return <div className="p-4 text-sm text-red-600 whitespace-pre-wrap">{error}</div>;
    }

    return (
      <div className="relative h-full w-full border-l border-slate-300">
        <ReactFlow
          nodes={finalNodes}
          edges={processedEdges}
          onNodesChange={(changes) => setNodes(nds => applyNodeChanges(changes, nds))}
          onNodeClick={onNodeClick}
          onNodeMouseEnter={onNodeMouseEnter}
          onNodeMouseLeave={onNodeMouseLeave}
          onEdgeMouseEnter={(_, edge) => setHoveredEdgeId(edge.id)}
          onEdgeMouseLeave={() => setHoveredEdgeId(null)}
          fitView
          minZoom={0.2}
          maxZoom={2}
          className="bg-gray-50"
          nodeTypes={{ group: CustomGroupNode }}
          onPaneClick={() => {
            setSelectedNodeId(null);
            setCfgMessage(null);
          }}
        >
          <Background variant="dots" gap={16} size={1} />
          <MiniMap
            pannable
            zoomable
            nodeColor={n => {
              if (n.type === 'group') return collapsedGroups.has(n.id) ? '#6b7280' : '#bdbdbd';
              const bg = n.style?.background;
              return bg === STYLES.COLORS.NODE.HOVER ? '#facc15' :
                bg === STYLES.COLORS.NODE.ACTIVE ? '#0284c7' : '#2563eb';
            }}
            nodeStrokeColor={n => {
              if (n.type === 'group') return collapsedGroups.has(n.id) ? '#374151' : '#757575';
              const border = n.style?.border;
              return border?.includes(STYLES.COLORS.NODE.BORDER_HOVER) ? STYLES.COLORS.NODE.BORDER_HOVER :
                border?.includes(STYLES.COLORS.NODE.BORDER_ACTIVE) ? STYLES.COLORS.NODE.BORDER_ACTIVE : '#1e40af';
            }}
            nodeStrokeWidth={2}
            maskColor="rgba(255,255,255,0.7)"
            style={{
              background: '#f3f4f6',
              border: '1.5px solid #cbd5e1',
              borderRadius: 6,
              boxShadow: '0 2px 8px #0002',
            }}
          />
          <Controls>
            <button
              type="button"
              title="Re-layout"
              onClick={() => diagramCache && hydrate(diagramCache)}
              className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow"
            >
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                <rect x="2" y="2" width="4" height="4" rx="1" fill="#222" />
                <rect x="10" y="2" width="4" height="4" rx="1" fill="#222" />
                <rect x="2" y="10" width="4" height="4" rx="1" fill="#222" />
                <rect x="6" y="6" width="4" height="4" rx="1" fill="#222" />
                <rect x="10" y="10" width="4" height="4" rx="1" fill="#222" />
              </svg>
            </button>
            <button
              type="button"
              title="Generate Control Flow Graph"
              onClick={handleGenerateCFG}
              disabled={cfgLoading}
              className="w-5 h-5 bg-white p-0 m-1 cursor-pointer flex items-center justify-center shadow-sm hover:shadow-md transition-shadow relative disabled:cursor-not-allowed"
            >
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style={{ opacity: cfgLoading ? 0.3 : 1 }}>
                <circle cx="6" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <circle cx="14" cy="6" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <circle cx="10" cy="14" r="2.2" fill="#000" fillOpacity="0.12" stroke="#222" strokeWidth="1.2" />
                <line x1="7.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
                <line x1="12.5" y1="7.5" x2="10" y2="12" stroke="#222" strokeWidth="1.2" />
                <line x1="8.2" y1="6" x2="11.8" y2="6" stroke="#222" strokeWidth="1.2" />
                <g>
                  <circle cx="16.5" cy="16.5" r="3.2" fill="#222" />
                  <rect x="16" y="14.2" width="1" height="4.6" rx="0.5" fill="#fff" />
                  <rect x="14.2" y="16" width="4.6" height="1" rx="0.5" fill="#fff" />
                </g>
              </svg>
              {cfgLoading && (
                <span className="absolute inset-0 flex items-center justify-center bg-white/70 rounded">
                  <svg className="animate-spin" width="16" height="16" viewBox="0 0 16 16">
                    <circle cx="8" cy="8" r="6" stroke="#0284c7" strokeWidth="2" fill="none" strokeDasharray="28" strokeDashoffset="10" />
                  </svg>
                </span>
              )}
            </button>
          </Controls>
        </ReactFlow>

        {cfgMessage && (
          <div className="absolute top-[60px] right-6 bg-red-100 text-red-800 px-4 py-2 rounded-md z-[100] text-sm shadow-md">
            {cfgMessage}
          </div>
        )}

        {cfgPanels.map((panel, idx) => (
          <CFGPanelComponent
            key={panel.id}
            panel={panel}
            index={idx}
            onUpdate={handleCFGPanelUpdate}
            onClose={handleCFGPanelClose}
            onNodeHover={handleCFGNodeHover}
            message={cfgPanelMessage}
          />
        ))}

        {hoverId && snippet && (
          <div
            className="fixed z-50 top-4 right-4 min-w-[320px] max-w-[40vw] min-h-[40px] max-h-[80vh] bg-gray-50 text-slate-800 text-xs rounded-lg shadow-lg p-4 overflow-auto font-mono pointer-events-none"
            dangerouslySetInnerHTML={{ __html: `<pre class="hljs">${snippet}</pre>` }}
          />
        )}
      </div>
    );
  }

  // CFG Panel Component
  function CFGPanelComponent({
    panel,
    index,
    onUpdate,
    onClose,
    onNodeHover,
    message,
  }: {
    panel: CFGPanel;
    index: number;
    onUpdate: (id: string, updates: Partial<CFGPanel>) => void;
    onClose: (id: string) => void;
    onNodeHover: (node: Node | null, panel: CFGPanel) => void;
    message?: string | null;
  }) {
    const [isDragging, setIsDragging] = useState(false);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
      if ((e.target as HTMLElement).closest('button')) return;

      const startX = e.clientX;
      const startY = e.clientY;
      const origX = panel.pos.x;
      const origY = panel.pos.y;

      setIsDragging(true);
      onUpdate(panel.id, { dragging: true });

      const onMouseMove = (moveEvent: MouseEvent) => {
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;

        const newX = origX - dx;
        const newY = origY + dy;

        const panelWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
        const panelHeight = panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : 44;

        const boundedX = Math.max(20, Math.min(newX, window.innerWidth - panelWidth - 20));
        const boundedY = Math.max(20, Math.min(newY, window.innerHeight - panelHeight - 20));

        onUpdate(panel.id, { pos: { x: boundedX, y: boundedY } });
      };

      const onMouseUp = () => {
        setIsDragging(false);
        onUpdate(panel.id, { dragging: false });
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      e.preventDefault();
    }, [panel, onUpdate]);

    const handleResize = useCallback((e: React.MouseEvent) => {
      e.preventDefault();
      const startX = e.clientX;
      const startY = e.clientY;
      const startWidth = panel.width ?? STYLES.CFG_PANEL.WIDTH;
      const startHeight = panel.height ?? STYLES.CFG_PANEL.HEIGHT;

      onUpdate(panel.id, { resizing: true });

      const onMouseMove = (moveEvent: MouseEvent) => {
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;

        const newWidth = Math.max(300, Math.min(1600, startWidth + dx));
        const newHeight = Math.max(200, Math.min(1200, startHeight + dy));

        onUpdate(panel.id, { width: newWidth, height: newHeight });
      };

      const onMouseUp = () => {
        onUpdate(panel.id, { resizing: false });
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    }, [panel, onUpdate]);

    return (
      <div
        style={{
          position: 'fixed',
          top: panel.pos.y,
          right: panel.pos.x,
          background: '#f1f5f9',
          color: '#222',
          padding: panel.expanded ? '12px 18px 18px 18px' : '8px 18px',
          borderRadius: 8,
          zIndex: 200 + index,
          fontSize: 13,
          minWidth: 220,
          maxWidth: 1600,
          maxHeight: panel.expanded ? 1200 : 44,
          boxShadow: '0 2px 8px #0002',
          overflow: panel.expanded ? 'auto' : 'hidden',
          transition: 'all 0.2s cubic-bezier(.4,2,.6,1)',
          display: 'flex',
          flexDirection: 'column',
          cursor: isDragging ? 'move' : 'default',
          userSelect: isDragging ? 'none' : 'auto',
          width: panel.width ?? STYLES.CFG_PANEL.WIDTH,
          height: panel.expanded ? (panel.height ?? STYLES.CFG_PANEL.HEIGHT) : undefined,
        }}
      >
        {message && (
          <div
            style={{
              position: 'absolute',
              top: 8,
              right: 12,
              zIndex: 300,
              fontSize: 13,
              fontWeight: 500,
              pointerEvents: 'none',
              maxWidth: 340,
            }}
            dangerouslySetInnerHTML={{ __html: message }}
          />
        )}

        <div
          style={{
            width: '100%',
            minHeight: 28,
            display: 'flex',
            alignItems: 'center',
            fontWeight: 600,
            fontSize: 13,
            color: '#555',
            userSelect: 'none',
            marginBottom: panel.expanded ? 8 : 0,
            gap: 4,
            cursor: 'move',
          }}
          onMouseDown={handleMouseDown}
        >
          <span style={{ flex: 1 }}>
            CFG ({panel.functionName}
            {panel.file && <> @ {panel.file.split(/[\\/]/).pop()}</>})
          </span>
          <button
            onClick={e => {
              e.stopPropagation();
              onUpdate(panel.id, { expanded: !panel.expanded });
            }}
            style={{
              background: 'transparent',
              border: 'none',
              color: '#888',
              cursor: 'pointer',
              padding: 0,
              width: 24,
              height: 24,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              transition: 'transform 0.15s',
              transform: panel.expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
            }}
            aria-label={panel.expanded ? 'Collapse' : 'Expand'}
          >
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <path d="M4 6l4 4 4-4" stroke="#888" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
            </svg>
          </button>
          <button
            onClick={e => {
              e.stopPropagation();
              onClose(panel.id);
            }}
            style={{
              background: 'transparent',
              border: 'none',
              color: '#888',
              cursor: 'pointer',
              padding: 0,
              width: 24,
              height: 24,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
            aria-label="Close"
          >
            √ó
          </button>
        </div>

        {panel.expanded && (
          <div style={{ width: '100%', height: panel.height ?? STYLES.CFG_PANEL.HEIGHT, overflow: 'auto', position: 'relative' }}>
            {panel.result?.nodes && panel.result?.edges ? (
              <div style={{ width: '100%', height: '100%', background: '#f8fafc', borderRadius: 6 }}>
                <ReactFlow
                  nodes={panel.result.nodes}
                  edges={panel.result.edges}
                  fitView
                  minZoom={0.2}
                  maxZoom={2}
                  className="bg-gray-50"
                  style={{ width: '100%', height: '100%' }}
                  defaultViewport={{ x: 0, y: 0, zoom: 1.2 }}
                  onNodeMouseEnter={(_, node) => onNodeHover(node, panel)}
                  onNodeMouseLeave={() => onNodeHover(null, panel)}
                >
                  <Background variant="dots" gap={16} size={1} />
                  <Controls showInteractive={false} />
                </ReactFlow>
              </div>
            ) : (
              <pre style={{
                margin: 0,
                fontSize: 13,
                background: 'none',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
                maxWidth: 560,
                maxHeight: 520,
                padding: 0,
              }}>
                {typeof panel.result === 'string' ? panel.result : JSON.stringify(panel.result, null, 2)}
              </pre>
            )}

            <div
              style={{
                position: 'absolute',
                right: 2,
                bottom: 2,
                width: 18,
                height: 18,
                cursor: 'nwse-resize',
                zIndex: 10,
                userSelect: 'none',
              }}
              onMouseDown={handleResize}
            >
              <svg width="18" height="18" style={{ pointerEvents: 'none' }}>
                <polyline points="4,18 18,4" stroke="#888" strokeWidth="2" fill="none" />
                <rect x="12" y="12" width="5" height="5" fill="#e5e7eb" stroke="#888" strokeWidth="1" />
              </svg>
            </div>
          </div>
        )}
      </div>
    );
  }

  // Helper function
  function findByPath(nodes: FileNode[] = [], p: string): FileNode | undefined {
    const regex = new RegExp(`^${process.env.NEXT_PUBLIC_TARGET_FOLDER}[\\\\/]`);
    for (const n of nodes) {
      if (n.path?.replace(regex, '') === p) return n;
      if (n.children) {
        const r = findByPath(n.children, p);
        if (r) return r;
      }
    }
  }



  [src/app/page.tsx]
  'use client';

  import { useState, useEffect } from 'react';
  import dynamic from 'next/dynamic';
  import { useFS } from '@/store/files';
  import { useEditor } from '@/store/editor';
  import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';

  import IconBar from '@/components/IconBar';
  import FileExplorer from '@/components/FileExplorer';
  import SearchPanel from '@/components/SearchPanel';

  const EditorTabs = dynamic(() => import('@/components/EditorTabs'), { ssr: false });
  const DiagramViewer = dynamic(() => import('@/components/DiagramViewer'), { ssr: false });
  const ChatUI = dynamic(() => import('@/components/ChatUI'), { ssr: false });

  const HHandle = () => (
    <PanelResizeHandle className="w-[4px] bg-slate-300 hover:bg-sky-600 cursor-col-resize transition-colors" />
  );
  const VHandle = () => (
    <PanelResizeHandle className="h-[4px] bg-slate-300 hover:bg-sky-600 cursor-row-resize transition-colors" />
  );

  export default function Home() {
    const { current } = useFS();
    const { tabs } = useEditor(); // tabs ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
    const [showSidebar, setShowSidebar] = useState(true);
    const [sidebarContent, setSidebarContent] = useState<'explorer' | 'search'>('explorer');
    const [showDia, setDia] = useState(true);
    const [showChat, setChat] = useState(true);

    useEffect(() => {
      setSidebarContent('explorer');
      setShowSidebar(true);
    }, []);

    const toggleExplorer = () => {
      if (sidebarContent === 'explorer' && showSidebar) {
        setShowSidebar(false);
      } else {
        setSidebarContent('explorer');
        setShowSidebar(true);
      }
    };

    const toggleSearch = () => {
      if (sidebarContent === 'search' && showSidebar) {
        setShowSidebar(false);
      } else {
        setSidebarContent('search');
        setShowSidebar(true);
      }
    };

    const toggleDia = () => setDia(!showDia);
    const toggleChat = () => setChat(!showChat);

    // ÌÉ≠Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const hasOpenTabs = tabs.length > 0;

    return (
      <div className="flex h-full">
        <IconBar
          states={{
            explorer: sidebarContent === 'explorer' && showSidebar,
            search: sidebarContent === 'search' && showSidebar,
            diagram: showDia,
            chat: showChat,
          }}
          toggle={{
            explorer: toggleExplorer,
            search: toggleSearch,
            diagram: toggleDia,
            chat: toggleChat,
          }}
        />
        <PanelGroup direction="horizontal" className="flex-1">
          {showSidebar && (
            <>
              <Panel defaultSize={15} minSize={12}>
                <PanelGroup direction="vertical">
                  <Panel defaultSize={showChat ? 70 : 100} minSize={30}>
                    {sidebarContent === 'explorer' ? <FileExplorer /> : <SearchPanel />}
                  </Panel>
                  {showChat && (
                    <>
                      <VHandle />
                      <Panel defaultSize={30} minSize={20}>
                        <ChatUI />
                      </Panel>
                    </>
                  )}
                </PanelGroup>
              </Panel>
              <HHandle />
            </>
          )}
          
          {/* ÏóêÎîîÌÑ∞ Ìå®ÎÑê - ÌÉ≠Ïù¥ ÏóÜÏúºÎ©¥ ÌÅ¨Í∏∞Í∞Ä 0 */}
          <Panel 
            defaultSize={hasOpenTabs ? 55 : 0} 
            minSize={hasOpenTabs ? 30 : 0}
            maxSize={hasOpenTabs ? 70 : 0}
            className={hasOpenTabs ? "border-x border-slate-300" : ""}
          >
            {hasOpenTabs && <EditorTabs />}
          </Panel>
          
          {/* ÏóêÎîîÌÑ∞ÏôÄ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÇ¨Ïù¥Ïùò Ìï∏Îì§ - ÌÉ≠Ïù¥ ÏûàÏùÑ ÎïåÎßå ÌëúÏãú */}
          {hasOpenTabs && showDia && <HHandle />}
          
          {/* Îã§Ïù¥Ïñ¥Í∑∏Îû® Ìå®ÎÑê - Ìï≠ÏÉÅ Ï°¥Ïû¨ÌïòÏßÄÎßå ÌÅ¨Í∏∞Í∞Ä Î≥ÄÌï® */}
          {showDia && (
            <Panel 
              defaultSize={hasOpenTabs ? 45 : 85} 
              minSize={hasOpenTabs ? 18 : 30}
            >
              <DiagramViewer />
            </Panel>
          )}
        </PanelGroup>
      </div>
    );
  }

  [src/app/globals.css]
  /* src/app/globals.css */
  @import 'tailwindcss';

  /* ‚îÄ‚îÄ‚îÄ ÎùºÏù¥Ìä∏ ÌåîÎ†àÌä∏ ‚îÄ‚îÄ‚îÄ */
  :root{
    --background: #ffffff;
    --foreground: #171717;
    --panel:      #f3f3f3;
    --border:     #e5e5e5;
    --side:       #eeeeee;
    --accent:     #0078d4;
  }

  /* ‚îÄ‚îÄ‚îÄ Îã§ÌÅ¨ ÌåîÎ†àÌä∏ ‚îÄ‚îÄ‚îÄ */
  @media (prefers-color-scheme:dark){
    :root{
      --background: #1e1e1e;
      --foreground: #ededed;
      --panel:      #252526;
      --border:     #3c3c3c;
      --side:       #333337;
      --accent:     #569cd6;
    }
  }

  /* Í∏∞Î≥∏ Î†àÏù¥ÏïÑÏõÉ */
  html, body {
    height: 100%;
  }
  body {
    background: var(--background);
    color: var(--foreground);
    font-family: system-ui, Arial, Helvetica, sans-serif;
    font-size: 14px;
    margin: 0;
    padding: 0;
    overscroll-behavior: none;
  }

  /* Custom Scrollbar */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  ::-webkit-scrollbar-thumb {
    background-color: var(--border);
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background-color: var(--accent);
  }

  /* ÏÑ†ÌÉù Ìñâ ÌïòÏù¥ÎùºÏù¥Ìä∏ */
  .vscode-tree-active{
    background: var(--side);
    color: var(--accent);
  }

  /* Transition classes for smoother toggles, hovers, etc. */
  .transition-colors {
    transition: color 0.15s ease, background-color 0.15s ease;
  }

  .highlight-line {
    background-color: rgba(255, 255, 0, 0.2);
  }
  .highlight-text {
    background-color: rgba(255, 255, 0, 0.5);
  }

  /* ÎìúÎûòÍ∑∏ Ï§ë ÎÖ∏ÎìúÏùò zIndex Ï†úÌïú */
  .react-flow__node.dragging {
    z-index: 10 !important; /* Ïó£ÏßÄÏùò zIndex(10000)Î≥¥Îã§ ÎÇÆÍ≤å ÏÑ§Ï†ï */
  }

  [src/store/editor.ts]
  "use client";

  import { create } from "zustand";
  import { immer } from "zustand/middleware/immer";
  import { useFS } from "@/store/files";

  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

  export interface TabMeta {
    id: string;
    path: string;
    name: string;
  }

  interface State {
    tabs: TabMeta[];
    activeId?: string;
    activePath?: string;
    searchHighlights?: { line: number; query: string };
    highlight?: { from: number; to: number }; // Ï∂îÍ∞Ä: highlight Î≤îÏúÑ
    open: (file: TabMeta & { line?: number; highlight?: { from: number; to: number } }) => void;
    close: (id: string) => void;
    setActive: (id: string, highlight?: { from: number; to: number }) => void; // highlight Ïù∏Ïûê Ï∂îÍ∞Ä
    setSearchHighlights: (line: number, query: string) => void;
  }

  export const useEditor = create<State>()(
    immer((set) => ({
      tabs: [],
      activeId: undefined,
      activePath: undefined,
      searchHighlights: undefined,
      highlight: undefined,
      open: (file) =>
        set((s) => {
          if (!s.tabs.find((t) => t.path === file.path)) s.tabs.push(file);
          s.activeId = s.tabs.find((t) => t.path === file.path)?.id ?? file.id;
          s.activePath = file.path;
          s.searchHighlights = undefined;
          if (file.highlight) {
            s.highlight = file.highlight;
          } else {
            s.highlight = undefined;
          }
        }),
      close: (id) =>
        set((s) => {
          s.tabs = s.tabs.filter((t) => t.id !== id);
          if (s.activeId === id) {
            const lastTab = s.tabs.at(-1);
            s.activeId = lastTab?.id;
            s.activePath = lastTab?.path;
          }
          s.searchHighlights = undefined;
          s.highlight = undefined;
        }),
      setActive: (id, highlight) =>
        set((s) => {
          s.activeId = id;
          s.activePath = s.tabs.find((t) => t.id === id)?.path;
          if (s.activePath) {
            const node = findByPath(useFS.getState().tree, s.activePath);
            if (node) useFS.getState().setCurrent(node.id);
          }
          s.searchHighlights = undefined;
          if (highlight) {
            s.highlight = highlight;
          } else {
            s.highlight = undefined;
          }
        }),
      setSearchHighlights: (line, query) =>
        set((s) => {
          s.searchHighlights = { line, query };
        }),
    }))
  );

  function findByPath(nodes: FileNode[], path: string): FileNode | undefined {
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

    for (const n of nodes) {
      if (n.path?.replace(regex, "") === path) return n;

      if (n.children) {
        const r = findByPath(n.children, path);
        if (r) return r;
      }
    }
  }


  [src/store/files.ts]
  import { create } from "zustand";

  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER;

  export type FileNode = {
    id: string;
    name: string;
    path: string;
    children?: FileNode[];
  };

  interface FSState {
    tree: FileNode[];
    current?: FileNode;
    fileContents: Record<string, string>;
    setCurrent: (id: string) => void;
    load: (t: FileNode[]) => void;
    loadContents: () => Promise<void>;
  }

  export const useFS = create<FSState>((set, get) => ({
    tree: [],
    current: undefined,
    fileContents: {},
    setCurrent: (id) => set((state) => ({ current: find(state.tree, id) })),
    load: (tree) => set({ tree }),
    loadContents: async () => {
      const paths = getAllFilePaths(get().tree, false); // ÌååÏùºÎßå Í∞ÄÏ†∏Ïò§Í∏∞
      for (const path of paths) {
        try {
          const response = await fetch(
            `/api/file?path=${encodeURIComponent(path)}`
          );
          if (response.ok) {
            const content = await response.text();
            set((state) => ({
              fileContents: { ...state.fileContents, [path]: content },
            }));
          } else {
            console.error(
              `Failed to fetch content for ${path}: ${response.status}`
            );
          }
        } catch (err) {
          console.error(`Error loading content for ${path}:`, err);
        }
      }
    },
  }));

  function find(nodes: FileNode[], id: string): FileNode | undefined {
    for (const n of nodes) {
      if (n.id === id) return n;
      if (n.children) {
        const r = find(n.children, id);
        if (r) return r;
      }
    }
  }

  export function getAllFilePaths(
    tree: FileNode[],
    includeFolders = false
  ): string[] {
    const paths: string[] = [];
    const regex = new RegExp(`^${TARGET_FOLDER}[\\\\/]`);

    const traverse = (nodes: FileNode[]) => {
      for (const node of nodes) {
        if (!node.children || includeFolders) {
          const cleanPath = node.path.replace(regex, "");

          paths.push(cleanPath);
        }
        if (node.children) traverse(node.children);
      }
    };
    traverse(tree);
    return paths;
  }


  [backend/app/main.py]
  from fastapi import FastAPI, HTTPException
  from fastapi.responses import HTMLResponse
  from fastapi.middleware.cors import CORSMiddleware
  from dotenv import load_dotenv
  from pathlib import Path
  from schemas.common import *
  from llm.diagram_generator import generate_call_graph, generate_control_flow_graph
  from llm.chatbot import create_session, remove_session, generate_chatbot_answer_with_session, get_session_history
  from llm.utils import get_source_file_with_line_number
  from llm.inline_explanation import generate_inline_code_explanation
  from fastapi.responses import JSONResponse
  from llm.constants import SAMPLE_CFG_JSON

  import json

  # .env file loading
  load_dotenv()

  # FastAPI app initialization
  app = FastAPI(title="Code-Diagram API")

  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],  # ÌîÑÎ°†Ìä∏ÏóîÎìú ÎèÑÎ©îÏù∏ÏúºÎ°ú Ï†úÌïú Í∞ÄÎä•
      allow_credentials=True,
      allow_methods=["*"],  # Î™®Îì† HTTP Î©îÏÑúÎìú ÌóàÏö©
      allow_headers=["*"],  # Î™®Îì† Ìó§Îçî ÌóàÏö©
  )

  # Define the path to the HTML template
  HTML_PATH = Path(__file__).parent / "html" / "root.html"

  # API Endpoint
  @app.get("/", response_class=HTMLResponse)
  async def root():
      try:
          # Read the HTML content from the file
          html_content = HTML_PATH.read_text(encoding="utf-8")
          return HTMLResponse(content=html_content)
      except FileNotFoundError:
          return HTMLResponse(content="<h1>Template not found</h1>", status_code=404)

  @app.post("/api/generate_call_graph", response_model=CGDiagramResponse)
  async def api_generate_call_graph(request: CGDiagramRequest):
      """
      Generate a call graph for the given code.
      """
      try:

          json_data = await generate_call_graph(request.path, request.file_type)
          result = {
              "data": json_data
          }
          print(f'result in main.py: \\{result}')
          return CGDiagramResponse(**result)
      except Exception as e:
          return CGDiagramResponse(status=500, data=str(e))

  @app.post("/api/generate_control_flow_graph", response_model=CFGDiagramResponse)
  async def api_generate_control_flow_graph(request: CFGDiagramRequest):
      """
      Generate a control flow graph for the given code.
      """
      try:
          json_data = await generate_control_flow_graph(request.file_path, request.function_name)
          result = {
              "data": json_data
          }
          print(f'result in main.py: \\{result}')
          return CFGDiagramResponse(**result)
      except Exception as e:
          return CFGDiagramResponse(status=500, data=str(e))

  @app.get("/api/chatbot/session/open")
  async def api_open_session():
      try:
          session_id = create_session()
          return SessionResponse(session_id=session_id)
      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.post("/api/chatbot/session/close")
  async def api_close_session(req: SessionRequest):
      try:
          if not req.session_id:
              raise HTTPException(status_code=400, detail="Session ID is required")
          remove_session(req.session_id)
          return {"status": "closed"}
      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.post("/api/chatbot/session/chat", response_model=ChatbotQueryResponse)
  async def api_session_chat(req: ChatbotQueryRequest):
      try:
          if not req.session_id:
              raise HTTPException(status_code=400, detail="Session ID is required")
          if not req.query:
              raise HTTPException(status_code=400, detail="Query is required")
          
          # Handle Context Files
          context = ""
          if hasattr(req, 'context_files') and req.context_files:
              context += "Below is the context from the provided files:\n"
              for file_path in req.context_files:
                  context += get_source_file_with_line_number(file_path)
              context += "Please answer the question based on the above context.\n"


          print(f"Session ID: {req.session_id}")
          print(f"Query: {req.query}")
          print(f"Code: {req.code}")
          print(f"Diagram: {req.diagram}")
          print(f"Context Files: {req.context_files}")
          print(f"Context: {context}")
          answer, highlight = await generate_chatbot_answer_with_session(
              req.session_id, req.query + context, req.code, req.diagram
          )
          print(f"Answer: {answer}")
          print(f"Highlight: {highlight}")
          return ChatbotQueryResponse(answer=answer, highlight=highlight)
      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))
      
  @app.get("/api/chatbot/session/get_history")
  async def api_get_session_history(session_id: str):
      try:
          if not session_id:
              raise HTTPException(status_code=400, detail="Session ID is required")
          history = get_session_history(session_id)
          return {"session_id": session_id, "history": history}
      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))
      
  @app.post("/api/inline_code_explanation")
  async def api_inline_code_explanation(req: InlineCodeExplanationRequest):
      """
      Generate an inline explanation for the given code.
      """
      try:
          print(f"Inline Code: {req.file_path}, {req.line_start}, {req.line_end}, {req.context}")
          if not req.file_path:
              raise HTTPException(status_code=400, detail="File path is required")
          if not req.line_start or not req.line_end:
              raise HTTPException(status_code=400, detail="Line start and end are required")
          explanation = await generate_inline_code_explanation(req.file_path, req.line_start, req.line_end, req.context)
          print(f"Explanation: {explanation}")
          return {"explanation": explanation}
      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  [src/app/api/files/route.ts]
  /** Next 15 Ïù¥ÏÉÅ: Edge ‚Üí Node Îü∞ÌÉÄÏûÑÏúºÎ°ú Ï†ÑÌôò (fs ÏÇ¨Ïö©) */
  export const runtime = 'nodejs';
  export const dynamic = 'force-dynamic';     // dev ¬∑ hot-reload Ìé∏ÌïòÍ≤å

  import fs from 'node:fs';
  import path from 'node:path';
  import { NextResponse } from 'next/server';

  type FileNode = { id: string; name: string; path: string; children?: FileNode[] };

  // ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÌÉÄÍ≤ü Ìè¥Îçî ÏùΩÍ∏∞
  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER!;
  const TARGET_DIR = path.join(process.cwd(), '..', TARGET_FOLDER);

  /* ‚îÄ‚îÄ Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú ÌååÏùº/Ìè¥Îçî ÌÉêÏÉâÌï¥ FileNode Ìä∏Î¶¨ ÏÉùÏÑ± ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function walk(dir: string): FileNode[] {
    return fs.readdirSync(dir).map((name): FileNode => {
      const full = path.join(dir, name);                   
      const rel  = path.relative(path.join(process.cwd(), '..'), full); // Ï†ÑÏ≤¥ ÏÉÅÎåÄÍ≤ΩÎ°ú
      const id   = rel.replace(/[^\w]/g, '_');             // Í≥†Ïú† ID

      if (fs.statSync(full).isDirectory()) {
        return { id, name, path: rel, children: walk(full) };
      }
      return { id, name, path: rel };
    });
  }

  /* ‚îÄ‚îÄ GET /api/files ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  export async function GET() {
    try {
      const tree: FileNode = {
        id: TARGET_FOLDER.replace(/[^\w]/g, '_'),
        name: TARGET_FOLDER,
        path: TARGET_FOLDER,               
        children: walk(TARGET_DIR),
      };
      return NextResponse.json([tree]);  // Î∞∞Ïó¥Î°ú Í∞êÏã∏ÏÑú FileExplorerÏóê Í∑∏ÎåÄÎ°ú Ï†ÑÎã¨
    } catch (error) {
      console.error('Error reading directory:', error);
      return NextResponse.json({ error: 'Directory not found' }, { status: 404 });
    }
  }

  [src/app/api/file/route.ts]
  // frontend/src/app/api/file/route.ts
  export const runtime = 'nodejs';
  export const dynamic = 'force-dynamic';

  import { NextResponse } from 'next/server';
  import { promises as fs } from 'node:fs';
  import path from 'node:path';

  // ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÌÉÄÍ≤ü Ìè¥Îçî ÏùΩÍ∏∞
  const TARGET_FOLDER = process.env.NEXT_PUBLIC_TARGET_FOLDER!;
  const TARGET_DIR = path.join(process.cwd(), '..', TARGET_FOLDER);

  export async function GET(req: Request) {
    const raw = new URL(req.url).searchParams.get('path') ?? '';

    /* ‚îÄ‚îÄ Í≤ΩÎ°ú Ï†ïÍ∑úÌôî & Î≥¥Ïïà ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const parts = raw.split(/[\\/]/).filter(p => p && p !== '..');
    
    // TARGET_FOLDER Ï†ëÎëêÏÇ¨ Ï†úÍ±∞ (Ïòà: "study1/face_classification/main.py" ‚Üí "main.py")
    const targetParts = TARGET_FOLDER.split(/[\\/]/);
    for (let i = 0; i < targetParts.length && i < parts.length; i++) {
      if (parts[0] === targetParts[i]) {
        parts.shift();
      }
    }

    const rel = parts.join('/');             // ex) "main.py", "utils/helper.py"
    const abs = path.join(TARGET_DIR, rel);  // <root>/study1/face_classification/main.py

    try {
      // Î≥¥Ïïà Ï≤¥ÌÅ¨: TARGET_DIR Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎäî Í≤É Î∞©ÏßÄ
      const resolvedPath = path.resolve(abs);
      const resolvedTargetDir = path.resolve(TARGET_DIR);
      
      if (!resolvedPath.startsWith(resolvedTargetDir)) {
        return NextResponse.json({ error: 'Access denied' }, { status: 403 });
      }

      const text = await fs.readFile(abs, 'utf8');
      /* Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ ÏùëÎãµ */
      return new NextResponse(text);
    } catch (error) {
      console.error('Error reading file:', error);
      /* ÌååÏùº Î™ª Ï∞æÏúºÎ©¥ 404 JSON */
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }
  }

